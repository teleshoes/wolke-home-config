#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Digest::SHA qw(hmac_sha256_hex);

my $EXEC = basename $0;
my $API_KEY_NAME = "accreadonly";
my $SECRETS_FILE = "$ENV{HOME}/.secrets";
my $API_URL = "https://api.coinbase.com";
my $CACHE_DIR = "$ENV{HOME}/.cache/coinbase";
my $CACHE_FILE_BTC_BALANCE= "$CACHE_DIR/btc-balance";

sub fetchBTCToUSDExchangeRate();
sub fetchBTCBalance($$);
sub getSignature($$$$$);
sub readBTCBalanceCache();
sub writeBTCBalanceCache($);
sub readCoinbaseKeyAndSecret();
sub readSecrets();
sub decrypt($);

my $usage = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS]
  $EXEC [OPTS] --print
    -fetch BTC=>USD conversion rate using API
    -fetch BTC balance if not cached using API
    -print balance in USD and BTC

  OPTS
    --fetch-default
      fetch BTC balance only if there is no cached value
      (this is the default)
    -f | --fetch-always | --fetch
      always fetch BTC balance, never use cache
    --fetch-never
      never fetch BTC balance, always use cache
";

my $COMMAND_PRINT = "print";

my $FETCH_MODE_DEFAULT = "default";
my $FETCH_MODE_ALWAYS = "always";
my $FETCH_MODE_NEVER = "never";

sub main(@){
  my $command = $COMMAND_PRINT;
  my $fetchMode = $FETCH_MODE_DEFAULT;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(--print)$/){
      $command = $COMMAND_PRINT;
    }elsif($arg =~ /^(--fetch-default)$/){
      $fetchMode = $FETCH_MODE_DEFAULT;
    }elsif($arg =~ /^(-f|--fetch-always|--fetch)$/){
      $fetchMode = $FETCH_MODE_ALWAYS;
    }elsif($arg =~ /^(--fetch-never)$/){
      $fetchMode = $FETCH_MODE_NEVER;
    }else{
      die "$usage\nERROR: unknown arg $arg\n";
    }
  }

  if($command eq $COMMAND_PRINT){
    my $btcBalance = undef;
    my $cachedBTCBalance = readBTCBalanceCache();

    my $fetch = 0;
    $fetch = 1 if $fetchMode eq $FETCH_MODE_DEFAULT and not defined $cachedBTCBalance;
    $fetch = 1 if $fetchMode eq $FETCH_MODE_ALWAYS;
    $fetch = 0 if $fetchMode eq $FETCH_MODE_NEVER;

    if($fetch){
      my ($key, $secret) = readCoinbaseKeyAndSecret();
      $btcBalance = fetchBTCBalance($key, $secret);
      writeBTCBalanceCache($btcBalance);
    }else{
      $btcBalance = $cachedBTCBalance;
    }

    die "ERROR: unable to get BTC balance\n" if not defined $btcBalance;

    my $exRate = fetchBTCToUSDExchangeRate();
    my $usdBalance = $btcBalance*$exRate;

    printf ""
      . "%.2fUSD  (%.8fBTC)\n"
      . "  (1 BTC = %.2f USD)\n",
      $usdBalance,
      $btcBalance,
      $exRate;
  }else{
    die "ERROR: unknown command $command\n";
  }
}

sub fetchBTCToUSDExchangeRate(){
  my $out = `curl --silent https://api.coinbase.com/v2/exchange-rates?currency=BTC`;
  if($out =~ /"currency":"BTC","rates":\{[^}]*"USD":"(\d*\.\d*)"/){
    return $1;
  }
  die "could not get exchanged rate\n";
}

sub fetchBTCBalance($$){
  my ($key, $secret) = @_;

  my $timestamp = time;
  my $path = "/v2/accounts";
  my $method = "GET";
  my $body = "";
  my $sig = getSignature($secret, $timestamp, $method, $path, $body);

  my @cmd = ("curl",
    "$API_URL$path",
    "--silent",
    "--header", "CB-ACCESS-KEY: $key",
    "--header", "CB-ACCESS-SIGN: $sig",
    "--header", "CB-ACCESS-TIMESTAMP: $timestamp",
  );
  open CMD, "-|", @cmd or die "error running curl\n";
  my $out = join '', <CMD>;
  close CMD;
  my $btcBalance;
  if($out =~ /"balance":\{"amount":"(\d*\.\d*)","currency":"BTC"}/){
    $btcBalance = $1;
  }else{
    die "ERROR: malformed coinbase output:\n$out\n";
  }
  return $btcBalance;
}

sub getSignature($$$$$){
  my ($secret, $timestamp, $method, $path, $body) = @_;
  my $prehash = $timestamp . $method . $path . $body;
  return hmac_sha256_hex($prehash, $secret);
}

sub readBTCBalanceCache(){
  if(not -f $CACHE_FILE_BTC_BALANCE){
    return undef;
  }else{
    my $btcBalance = `cat $CACHE_FILE_BTC_BALANCE`;
    chomp $btcBalance;
    if($btcBalance =~ /^(\d+|\d*\.\d+)$/){
      return $btcBalance;
    }else{
      die "ERROR: malformed BTC balance cache: $btcBalance\n";
    }
  }
}
sub writeBTCBalanceCache($){
  my ($btcBalance) = @_;
  system "mkdir", "-p", $CACHE_DIR;

  if(defined $btcBalance){
    open FH, "> $CACHE_FILE_BTC_BALANCE"
      or die "ERROR: could not write $CACHE_FILE_BTC_BALANCE\n$!\n";
    print FH "$btcBalance\n";
    close FH;
  }else{
    system "rm", "-f", $CACHE_FILE_BTC_BALANCE;
  }
}

sub readCoinbaseKeyAndSecret(){
  my $conf = readSecrets();
  my ($key, $secret);
  $key = $$conf{"$API_KEY_NAME.key"};
  $secret = $$conf{"$API_KEY_NAME.secret"};

  if(not defined $key){
    die "could not find secret 'coinbase.api.$API_KEY_NAME.key\n";
  }
  if(not defined $secret){
    die "could not find secret 'coinbase.api.$API_KEY_NAME.secret\n";
  }

  return ($key, $secret);
}

sub readSecrets(){
  my @lines = `cat $SECRETS_FILE 2>/dev/null`;
  my $cfg = {};
  for my $line(@lines){
    if($line =~ /^coinbase\.api\.(.+\.(?:key|secret))=(.+)$/){
      $$cfg{$1} = $2;
    }
  }
  for my $key(sort keys %$cfg){
    $$cfg{$key} = decrypt $$cfg{$key};
  }
  return $cfg;
}

sub decrypt($){
  my ($s) = @_;
  open GPG, "-|", "gpg-sym", $s or die "could not run gpg-sym\n";
  my @contents = <GPG>;
  close GPG;
  die "error running gpg-sym\n$!\n" if $? != 0;
  my $value = join '', @contents;
  chomp $value;
  return $value;
}

&main(@ARGV);
