#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(time);
use JSON;

sub getSavesFromSaveArgs($@);
sub parseSaveInfo($);
sub extractTarToSaveDir($$);
sub removeCurrentSave($);
sub ensureSaveCached($$);
sub fetchCurrentSaveTar($);
sub fetchCurrentSaveMtime($);
sub readCacheDirSavesInfo($);
sub getSaveInfoFromTarFile($);
sub readOrCalculateTarFileSHA1($);
sub calculateTarFileSHA1($);
sub runSha1Cmd($);

sub notifySend($);
sub mtime($);
sub nowMillis();
sub run(@);
sub runQuiet(@);
sub readFile($);
sub globOne($);

my $DEFAULT_LIST_LIMIT = 10;
my $NOTIFY_SEND_MILLIS = 1500;

my $SAVE_DIR_LINUX = "$ENV{HOME}/.config/unity3d/noio/KingdomTwoCrowns/Release";

my $SAVE_DIR_PROTON_PATTERN = ""
  . "$ENV{HOME}/.steam/steam/"
  . "steamapps/compatdata/"
  . "*/" #app ID, should be: 701160
  . "pfx/drive_c/users/steamuser/"
  . "AppData/LocalLow/noio/KingdomTwoCrowns/Release"
;
my $SAVE_DIR_PROTON = globOne($SAVE_DIR_PROTON_PATTERN);

my $DEFAULT_SAVE_DIR = $SAVE_DIR_LINUX;

my $CACHE_DIR = "$ENV{HOME}/.cache/kingdom-saves";

my $CMD_BACKUP = "backup";
my $CMD_RESTORE = "restore";
my $CMD_INFO = "info";
my $CMD_LIST = "list";

my $EXEC = basename $0;

my $usage = "Usage:
  $EXEC -h|--help
    show this message

  $EXEC
  $EXEC --backup|--save [SAVE_DIR]
    take files from <SAVE_DIR>/* and make an xz'd tar file in $CACHE_DIR
      skips storing the tar file if an identical one already exists
    (default <SAVE_DIR> is $DEFAULT_SAVE_DIR)


  $EXEC --restore TAR_FILE [SAVE_DIR]
    move current game save files to a tmp dir
    takes a (compressed or uncompressed) tar file
      and extracts it to the save dir, after backing up the contents

      -MOVE files from
        $DEFAULT_SAVE_DIR/
        to
        /tmp/kingdom-save-backup-<MILLIS>
      -extract <TAR_FILE> to
        $DEFAULT_SAVE_DIR

  $EXEC --restore INDEX [SAVE_DIR]
    same as: $EXEC --restore \$($EXEC --get-tar INDEX)


  $EXEC --info TAR_FILE
    print detailed info about a save

  $EXEC --info INDEX
    same as: $EXEC --info \$($EXEC --get-tar INDEX)

  $EXEC --info
    same as: $EXEC --info 0


  $EXEC --list [INDEX_ARG INDEX_ARG...]
    print a summary of each indicated cached save (default is 0-9)
    print the most recent LIST_LIMIT cached saves (default is $DEFAULT_LIST_LIMIT)
    oldest to newest, formatted like:
      <INDEX> <MTIME> <DAYS>D <LAND_CHG> <SHA1SUM>
        INDEX:    the index to pass to --restore, 0 is most recent backup
        MTIME:    tarfile mtime formatted: YYYY-MM-DD HH:MM:SS
        DAYS:     the current in-game days counter
        LAND_CHG: the current land in campaign formatted \"LAND<LAND>/5\",
                    or the name of the challenge island if known,
                    or the challenge island NUMBER formatted \"CHG#<NUMBER>\"
                    e.g.: \"LAND5/5\", \"SKULL\", \"PLAGUE\"
        SHA1SUM:  the sha1sum of the tarfile, also contained in the filename

  SAVE_DIR
    use SAVE_DIR instead of $DEFAULT_SAVE_DIR

  INDEX_ARG
    either an INDEX or an INDEX_RANGE

  INDEX_RANGE
    low index to high index (inclusive on both sides), formated LOW-HIGH or LOW..HIGH
    e.g.: 0-5    => 0 1 2 3 4 5
          99-99  => 99

  INDEX
    non-negative integer for save index
    most recent save is 0, next most recent is 1
";

sub main(@){
  my $cmd = $CMD_BACKUP;
  my $saveDir = $DEFAULT_SAVE_DIR;
  my @saveArgs;

  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(--backup|--save)$/){
      $cmd = $CMD_BACKUP;
    }elsif($arg =~ /^(--restore)$/){
      $cmd = $CMD_RESTORE;
    }elsif($arg =~ /^(--info)$/){
      $cmd = $CMD_INFO;
    }elsif($arg =~ /^(--list)$/){
      $cmd = $CMD_LIST;
    }elsif($arg =~ /^(\d+)$/){
      push @saveArgs, $1;
    }elsif($arg =~ /^(\d+)(?:-|\.\.|\.\.\.)(\d+)$/){
      my ($minIndex, $maxIndex) = ($1, $2);
      @saveArgs = (@saveArgs, ($minIndex..$maxIndex));
    }elsif(-f $arg){
      push @saveArgs, $arg;
    }elsif(-d $arg){
      $saveDir = $arg;
    }else{
      die "$usage\nERROR: unknown arg $arg\n";
    }
  }

  if($cmd eq $CMD_BACKUP){
    die "ERROR: SAVE_DIR \"$saveDir\" does not exist\n" if not -d $saveDir;
    die "ERROR: cannot specify saves by TAR_FILE or INDEX for $cmd\n" if @saveArgs > 0;
    ensureSaveCached($saveDir, $CACHE_DIR);
  }elsif($cmd eq $CMD_RESTORE){
    my @saves = getSavesFromSaveArgs($CACHE_DIR, @saveArgs);
    if(@saves != 1){
      die "ERROR: must specify exactly one save by TAR_FILE or INDEX for $cmd\n";
    }
    my $tarFile = $saves[0]{file};

    print "\nREMOVING CURRENT SAVE:\n";
    removeCurrentSave($saveDir);

    print "\nEXTRACTING NEW SAVE:\n";
    extractTarToSaveDir($tarFile, $saveDir);
  }elsif($cmd eq $CMD_INFO){
    @saveArgs = qw(0) if @saveArgs == 0;
    my @saves = getSavesFromSaveArgs($CACHE_DIR, @saveArgs);

    for my $save(@saves){
      my $saveInfo = parseSaveInfo $$save{file};
      print "DAYS:  $$saveInfo{daysFmt}\n";
      print "LAND:  $$saveInfo{landChg}\n";
      for my $islandName(sort keys %{$$saveInfo{islands}}){
        my $islandInfo = $$saveInfo{islands}{$islandName};
        print "$$islandInfo{landFmt}: $$islandInfo{countFmt}\n";
      }
    }
  }elsif($cmd eq $CMD_LIST){
    @saveArgs = qw(0 1 2 3 4 5 6 7 8 9) if @saveArgs == 0;
    my @saves = getSavesFromSaveArgs($CACHE_DIR, @saveArgs);

    for my $save(reverse @saves){
      my $saveInfo = parseSaveInfo $$save{file};

      printf "%-3d %19s %4s %5s %s\n",
        $$save{index}, $$save{mtimeFmt}, $$saveInfo{daysFmt}, $$saveInfo{landChg}, $$save{sha1};
    }
  }else{
    die "ERROR: unknown command $cmd\n";
  }
}

sub getSavesFromSaveArgs($@){
  my ($cacheDir, @saveArgs) = @_;

  my $cacheDirSavesInfo = readCacheDirSavesInfo($cacheDir);

  my @saves;
  for my $arg(@saveArgs){
    my $save;
    if($arg =~ /^(\d+)$/){
      my $index = $arg;
      my $cachedSave = $$cacheDirSavesInfo{savesByIndex}{$index};

      if(defined $cachedSave){
        $save = $cachedSave;
      }else{
        die "ERROR: index $index not found in $cacheDir\n";
      }
    }elsif(-f $arg){
      my $tarFile = $arg;
      my $sha1 = readOrCalculateTarFileSHA1($tarFile);
      my $cachedSave = $$cacheDirSavesInfo{savesBySha1}{$sha1};

      my $save;
      if(defined $cachedSave){
        $save = $cachedSave;
      }else{
        $save = getSaveInfoFromTarFile($tarFile);
        $$save{index} = -1;
      }
    }else{
      die "ERROR: invalid save arg $arg\n";
    }

    push @saves, $save;
  }

  return @saves;
}

sub parseSaveInfo($){
  my ($tarFile) = @_;
  my $workDir = "/tmp/kingdom-save-tmp-" . nowMillis();
  runQuiet "mkdir", "-p", $workDir;
  runQuiet "tar", "-xf", $tarFile, "-C", $workDir;

  my $info = {
    land => "?",
    days => "?",
    islands => {},
  };

  my $challengeNames = {
    1 => 'SKULL',
    2 => 'PLAGUE',
    4 => 'DIRE',
    8 => 'TRADE',
  };

  my $globalFile = globOne "$workDir/global-*";
  if(-f $globalFile){
    my $globalJson = readFile $globalFile;
    my ($campaigns, $challenges, $currentCampaign, $currentChallenge);

    my $obj = JSON->new->decode($globalJson);
    if(ref $obj eq "HASH" and defined $$obj{campaigns}){
      $campaigns = $$obj{campaigns};
      $challenges = $$obj{challenges};
      $currentCampaign = $$obj{_currentCampaign};
      $currentChallenge = $$obj{_currentChallenge};
    };

    my $cur;
    if(
      ref $campaigns eq "ARRAY"
      and defined $currentCampaign
      and $currentCampaign =~ /^(\d+)$/
      and $currentCampaign < @$campaigns
    ){
      $cur = $$campaigns[$currentCampaign];
      $$info{landChg} = sprintf "LAND%d/5", ($$cur{currentLand}+1);
    }elsif(
      ref $challenges eq "ARRAY"
      and defined $currentChallenge
      and $currentChallenge =~ /^(\d+)$/
    ){
      for my $challenge(@$challenges){
        if(ref $challenge eq "HASH"){
          my $challengeId = $$challenge{challengeId};
          if($currentChallenge == $challengeId){
            $cur = $challenge;
            my $challengeFmt = defined $$challengeNames{$currentChallenge}
              ? $$challengeNames{$currentChallenge}
              : sprintf "CHNG#%02d", $currentChallenge;
            $$info{landChg} = sprintf "%-7s", $challengeFmt;
            last;
          }
        }
      }
    }
    if(defined $cur and defined $$cur{playTimeDays}){
      $$info{days} = $$cur{playTimeDays};
    }
  }

  my @islandFiles = glob "$workDir/island-*";
  for my $islandFile(@islandFiles){
    my $islandName = $islandFile;
    $islandName =~ s/.*\///;
    $$info{islands}{$islandName} = {};

    my $landFmt;
    if($islandName =~ /^island-v\d+-c([012])-l([01234])$/){
      my ($campaignIndex, $landIndex) = ($1, $2);
      $landFmt = sprintf "SLOT %d/3 - LAND %2d/5",
        ($campaignIndex+1),
        ($landIndex+1),
      ;
    }elsif($islandName =~ /^island-v\d+-ch(\d+)-l(\d+)$/){
      my ($challengeIndex, $landIndex) = ($1, $2);
      my $challengeFmt = defined $$challengeNames{$challengeIndex}
        ? $$challengeNames{$challengeIndex}
        : sprintf "CHLNG#%02d", $challengeIndex;

      my $maxLand = 1 if $challengeFmt =~ /^(SKULL|PLAGUE)$/;
      $maxLand = 2 if $challengeFmt =~ /^(TRADE)$/;
      $maxLand = '?' if $challengeFmt =~ /^(DIRE)$/;
      $maxLand = '?' if not defined $maxLand;

      $landFmt = sprintf "%-8s - LAND %2d/%s",
        $challengeFmt,
        ($landIndex+1),
        $maxLand,
      ;
    }else{
      $landFmt = $islandName;
    }

    $$info{islands}{$islandName}{"landFmt"} = $landFmt;

    my $json = `gzip --force --decompress --stdout $islandFile`;
    if($? != 0){
      die "ERROR: could not gzip decompress $islandFile\n";
    }

    my $bankFmt;
    if($json =~ /{[^}]*"name":"Banker"[^}]*\\"stashedCoins\\":(\d+)/){
      $bankFmt = sprintf "B\$%03d", $1;
    }else{
      $bankFmt = "B\$???";
    }

    my %objNameAbbrevs = (
      Archer  => "Ar",
      Peasant => "Ps",
      Worker  => "Wk",
      Farmer  => "Fa",
      Pikeman => "Pk",
      Squire  => "Sq",
      Knight  => "Kn",
    );
    my @countFmts;
    for my $objName(sort keys %objNameAbbrevs){
      my $objAbbrev = $objNameAbbrevs{$objName};
      my @ids = $json =~ /"uniqueID"\s*:\s*"($objName \w+ \[\w+\]--\d+)"/g;
      my %uniqIds = map {$_ => 1} @ids;
      @ids = sort keys %uniqIds;
      my $count = @ids;
      $$info{islands}{$islandName}{"count$objName"} = $count;
      push @countFmts, sprintf("%3d%s", $count, $objAbbrev);
    }

    $$info{islands}{$islandName}{"countFmt"} = join(" ", @countFmts) . " ${bankFmt}";
  }

  if(defined $$info{days} and $$info{days} =~ /^-?(\d+|\d*\.\d+)$/){
    $$info{daysFmt} = sprintf "%03dD", int($$info{days} + 1 + 0.5);
  }else{
    $$info{daysFmt} = "?D";
  }

  runQuiet "rm", "-rf", $workDir;
  return $info;
}

sub extractTarToSaveDir($$){
  my ($tarFile, $saveDir) = @_;
  run "tar", "-xf", $tarFile, "-C", $saveDir;
}

sub removeCurrentSave($){
  my ($saveDir) = @_;
  my $millis = nowMillis();
  my $tmpDir = "/tmp/kingdom-save-backup-$millis";
  my @files = glob "$saveDir/*";
  if(@files > 0){
    run "mkdir", "-p", $tmpDir;
    run "mv", glob("$saveDir/*"), "$tmpDir/";
  }else{
    print "no files to remove\n";
  }
}

sub ensureSaveCached($$){
  my ($saveDir, $cacheDir) = @_;
  if(not defined $saveDir or not -d $saveDir){
    $saveDir = "";
    my $msg = "ERROR: save dir does not exist: $saveDir";
    notifySend $msg;
    die "$msg\n";
  }

  my $currentSaveTar = fetchCurrentSaveTar($saveDir);
  my $currentSaveMtime = fetchCurrentSaveMtime($saveDir);
  my $currentSaveSha1 = calculateTarFileSHA1 $currentSaveTar;

  run "mkdir", "-p", $cacheDir if not -d $cacheDir;
  if(not -d $cacheDir){
    my $msg = "ERROR: cache dir does not exist: $cacheDir";
    notifySend $msg;
    die "$msg\n";
  }

  my $cacheDirSavesInfo = readCacheDirSavesInfo($cacheDir);

  my $cachedSave = $$cacheDirSavesInfo{savesBySha1}{$currentSaveSha1};

  if(defined $cachedSave){
    my $file = $$cachedSave{file};
    my $msg = "save already cached: $file\n";
    notifySend $msg;
    print "$msg\n";
  }else{
    my $datetimeFmt = `date --date \@$currentSaveMtime +%Y%m%d_%H%M%S`;
    chomp $datetimeFmt;
    my $cacheFileName = "${datetimeFmt}_${currentSaveSha1}.tar.xz";

    my $saveFileCachePath = "$cacheDir/$cacheFileName";
    run "xz --compress --stdout $currentSaveTar > $saveFileCachePath";
    if(not -f $saveFileCachePath){
      my $msg = "ERROR: could not create file $saveFileCachePath";
      notifySend $msg;
      die "$msg\n";
    }
    my $saveInfo = parseSaveInfo $saveFileCachePath;

    run "touch", $saveFileCachePath, "--date", "\@$currentSaveMtime";

    run "rm", "-f", "$cacheDir/latest.tar.xz";
    run "ln", "-s", $cacheFileName, "$cacheDir/latest.tar.xz";

    my $mtimeFmt = `date --date \@$currentSaveMtime '+%Y-%m-%d %H:%M:%S'`;
    my $msg = "SAVED: $mtimeFmt  $$saveInfo{daysFmt}  $$saveInfo{landChg}";
    notifySend $msg;
    print "$msg\n";
  }

  run "rm", $currentSaveTar;
}

sub fetchCurrentSaveTar($){
  my ($saveDir) = @_;
  die "ERROR: could not find dir $saveDir\n" if not -d $saveDir;

  my $millis = nowMillis();
  my $oldPWD = $ENV{PWD};
  chdir $saveDir;
  $ENV{PWD} = $saveDir;

  my $tmpTar = "/tmp/kingdom-save-$millis.tar";
  run "tar", "-cf", $tmpTar, glob("*");

  chdir $oldPWD;
  $ENV{PWD} = $oldPWD;

  return $tmpTar;
}

sub fetchCurrentSaveMtime($){
  my ($saveDir) = @_;
  my @files = glob("$saveDir/*");
  my $maxMtime = undef;
  for my $file(@files){
    my $mtime = mtime $file;
    if(not defined $maxMtime or $mtime > $maxMtime){
      $maxMtime = $mtime;
    }
  }
  return $maxMtime;
}

sub readCacheDirSavesInfo($){
  my ($cacheDir) = @_;

  my @tarFiles = glob("$cacheDir/*.tar.xz");

  #get save files
  my @saves = map {getSaveInfoFromTarFile $_} @tarFiles;

  #remove duplicate save files using SHA-1 sums, keeping the latest by filename
  my %seenSha1;
  my @uniqueSaves;
  for my $save(reverse sort @saves){
    next if defined $seenSha1{$$save{sha1}};
    $seenSha1{$$save{sha1}} = 1;
    push @uniqueSaves, $save;
  }

  #sort save files by mtime, newest first
  @uniqueSaves = sort {$$b{mtime} <=> $$a{mtime}} @uniqueSaves;

  #add indexes to saves
  my $index = 0;
  for my $save(@uniqueSaves){
    $$save{index} = $index++;
  }

  #parse index=>save and save=>index
  my $savesByIndex = {};
  my $savesBySha1 = {};

  for my $save(@uniqueSaves){
    $$savesByIndex{$$save{index}} = $save;
    $$savesBySha1{$$save{sha1}} = $save;
  }

  return {
    savesByIndex => $savesByIndex,
    savesBySha1 => $savesBySha1,
  };
}

sub getSaveInfoFromTarFile($){
  my ($tarFile) = @_;

  my $mtime = mtime $tarFile;
  my $mtimeFmt = `date --date \@$mtime +'%Y-%m-%d %H:%M:%S'`;
  chomp $mtimeFmt;

  my $sha1 = readOrCalculateTarFileSHA1($tarFile);

  return {
    file     => $tarFile,
    sha1     => $sha1,
    mtime    => $mtime,
    mtimeFmt => $mtimeFmt,
    index    => undef,
  };
}

sub readOrCalculateTarFileSHA1($){
  my ($tarFile) = @_;
  my $sha1;
  if($tarFile =~ /(?:^|\/)(\d\d\d\d\d\d\d\d)_(\d\d\d\d\d\d)_([0-9a-f]{40})\.tar\.xz$/){
    my ($date, $time, $sha1sum) = ($1, $2, $3);
    $sha1 = $sha1sum;
  }else{
    $sha1 = calculateTarFileSHA1($tarFile);
  }
  return $sha1;
}

sub calculateTarFileSHA1($){
  my ($tarFile) = @_;
  my $sha1Cmd = "";
  $sha1Cmd .= "cat \"$tarFile\"";
  $sha1Cmd .= " | xz --decompress --stdout" if $tarFile =~ /\.xz$/i;
  $sha1Cmd .= " | sha1sum";

  my $sha1 = runSha1Cmd($sha1Cmd);

  my $emptySha1 = runSha1Cmd(": | sha1sum");

  die "ERROR: empty sha1sum returned for $tarFile\n" if $sha1 eq $emptySha1;

  return $sha1;
}

sub runSha1Cmd($){
  my ($sha1ShellCmd) = @_;
  open FH, "-|", $sha1ShellCmd or die "ERROR: cmd failed $sha1ShellCmd\n$!\n";
  my $out = join '', <FH>;
  close FH;

  if($out =~ /^([0-9a-f]{40})\s+-$/){
    return $1;
  }else{
    die "ERROR: cmd failed $sha1ShellCmd\n";
  }
}

sub notifySend($){
  system "notify-send", "-t", $NOTIFY_SEND_MILLIS, @_;
}

sub mtime($){
  return (stat $_[0])[9];
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

sub run(@){
  print "@_\n";
  runQuiet @_;
}
sub runQuiet(@){
  system @_;
  if($? != 0){
    die "ERROR: \"@_\" failed\n";
  }
}

sub readFile($){
  my ($file) = @_;
  open FH, "<", $file or die "could not read $file\n$!\n";
  my $contents = join '', <FH>;
  close FH;
  return $contents;
}

sub globOne($){
  my ($ptrn) = @_;
  my @files = glob($ptrn);
  if(@files == 0){
    return undef;
  }elsif(@files > 1){
    die "glob pattern matched more than one file: $ptrn\n";
  }else{
    return $files[0];
  }
}

&main(@ARGV);
