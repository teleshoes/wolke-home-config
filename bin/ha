#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(sleep time);

sub getState($$$);
sub setState($$$$);
sub getCurl($$$);
sub setCurl($$$$);
sub readSecrets();
sub decrypt($);
sub readFile($);
sub readProc(@);
sub nowMillis();

my $DELAY_MILLIS = 150;
my $MAX_DELAY_MILLIS = 3 * 1000;

my $SECRETS_FILE = "$ENV{HOME}/.secrets";
my $SECRETS_PREFIX = "homeassistant";
my $SECRETS_KEYS_REGEX = join "|", qw(token);
my %SECRETS_ENC_KEYS = map {$_ => 1} qw(token);

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  TOKEN
    read the ENCRYPTED_TOKEN from $SECRETS_FILE
    formatted:
      homeassistant.token = ENCRYPTED_TOKEN
    decrypt to the homeassistant long-lived access TOKEN
";

sub main(@){
  my $token = ${readSecrets()}{token};

  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }
}

sub getState($$$){
  my ($host, $token, $entityID) = @_;
  my $json = getCurl($host, $token, $entityID);
  if($json =~ /\"state\":\"(off|on)\"/i){
    return lc $1;
  }else{
    print STDERR "WARNING: could not parse state for $entityID:\n$json\n";
    return undef;
  }
}

sub setState($$$$){
  my ($host, $token, $entityID, $state) = @_;
  $state = lc $state;

  my $startMillis = nowMillis();

  my $curState = getState($host, $token, $entityID);
  my $oldState = $curState;

  if($curState ne $state){
    #skip set() if state already matches
    setCurl($host, $token, $entityID, $state);
    $curState = getState($host, $token, $entityID);
  }

  while($curState ne $state and (nowMillis() - $startMillis) < $MAX_DELAY_MILLIS){
    sleep $DELAY_MILLIS/1000.0;
    $curState = getState($host, $token, $entityID);
  }

  if($curState ne $state){
    die "ERROR: $entityID state=$curState, not $state\n";
  }

  my $newState = $curState;

  return ($oldState, $newState);
}

sub getCurl($$$){
  my ($host, $token, $entityID) = @_;
  my $out = readProc("curl",
    "--silent",
    "-X", "GET",
    "-H", "Authorization: Bearer $token",
    "-H", "Content-Type: application/json",
    "http://$host:8123/api/states/$entityID",
  );

  return $out;
}

sub setCurl($$$$){
  my ($host, $token, $entityID, $state) = @_;
  my $domain = "switch";
  my $service = $state =~ /on/ ? "turn_on" : "turn_off";
  my $out = readProc("curl",
    "--silent",
    "-X", "POST",
    "-H", "Authorization: Bearer $token",
    "-H", "Content-Type: application/json",
    "-d", "{\"entity_id\": \"$entityID\"}",
    "http://$host:8123/api/services/$domain/$service",
  );

  #ignore output, there is no guarantee it reflects the set()
}

sub readSecrets(){
  my @lines = readFile($SECRETS_FILE);
  my $secrets = {};
  for my $line(@lines){
    if($line =~ /^$SECRETS_PREFIX\.($SECRETS_KEYS_REGEX)\s*=\s*(.+)$/){
      $$secrets{$1} = $2;
    }
  }
  for my $key(sort keys %$secrets){
    $$secrets{$key} = decrypt $$secrets{$key} if defined $SECRETS_ENC_KEYS{$key};
  }
  return $secrets;
}

sub decrypt($){
  my ($s) = @_;
  open GPG, "-|", "gpg-sym", $s or die "could not run gpg-sym\n";
  my @contents = <GPG>;
  close GPG;
  die "error running gpg-sym\n$!\n" if $? != 0;
  my $value = join '', @contents;
  chomp $value;
  return $value;
}

sub readFile($){
  my ($file) = @_;
  my @lines;
  if(-f $file){
    open my $fh, "<", $file
      or die "ERROR: could not read file $file\n$!\n";
    @lines = <$fh>;
    close $fh;
  }
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;
  }
}

sub readProc(@){
  my @cmd = @_;
  open CMD, "-|", @cmd or die "ERROR: \"@cmd\" failed\n$!\n";
  my @lines = <CMD>;
  close CMD;
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;
  }
}

sub nowMillis(){
  return int(time * 1000.0);
}

&main(@ARGV);
