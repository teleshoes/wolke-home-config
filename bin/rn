#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

sub calculateRenameCommandInfo($$$);
sub formatCmd(@);

my $EXEC = basename $0;

my $USAGE = "USAGE:
  $EXEC -h|--help
    show this message

  $EXEC [OPTS] PERLEXPR FILE [FILE ...]
    similar to `file-rename` command from File::Rename
    for each file:
      -run PERLEXPR to generate a new filename,
      -generate a `mv` command to rename the file
      -print the `mv` command, formatting with quotes for shell interpolation
      -run the `mv` command (as a direct system call without shell interpolation)
    e.g.:  > $EXEC s/a/b/  a.txt aa.txt
           mv a.txt b.txt
           mv aa.txt ba.txt
    NOTE: arguments are NOT actually positional, and can be given in any order
            -`$EXEC -n file1 s/a/b/` is the same as `$EXEC s/a/b/ file1 -n`
            -PERLEXPR cannot be an existing file on the filesystem
            -neither FILE nor PERLEXPR can be one of the valid OPTS

  PERLEXPR
    -any perl expression, passed directly and unsanitized to eval()
      -the value of '\$_' at the start of the eval is the basename of the file or dir
      -the value of '\$_' at the end of the eval is the new filename
    -cannot be an existing file on the filesystem
    -cannot be one of the valid OPTS

    WARNING: like in File::Rename, eval() of this expression can have side effects
             e.g.: > `$EXEC 'system(\"rm file2\"); \$_=\"file2\"' file1`
                   will delete file2 first, then rename file1 to file2

  FILE
    -any existing file, directory or symlink (valid or broken)
    -cannot be one of the valid OPTS

  OPTS
    -n | -s | --dry-run | --simulate | --no-act
      do not rename files
      print `mv` commands, prepended with `#`, but do not run the commands

      WARNING: like `file-rename -n`, PERLEXPR is still run, which may have side effects
        e.g.: > $EXEC --simulate 'system(\"rm file2\"); \$_=\"file2\"' file1
              will still delete file2, but it will not rename file1
    --no-simulate
      actually run `mv` commands
      (this is the default)
";

sub main(@){
  my $perlExpr = undef;
  my @files;
  my $opts = {
    simulate => 0,
  };
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-n|-s|--dry-run|--simulate|--no-act)$/){
      $$opts{simulate} = 1;
    }elsif($arg =~ /^(--no-simulate)$/){
      $$opts{simulate} = 0;
    }elsif(-e $arg or -l $arg){
      push @files, $arg;
    }elsif(not defined $perlExpr){
      $perlExpr = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  die "$USAGE\nERROR: missing FILE\n" if @files == 0;
  die "$USAGE\nERROR: missing PERLEXPR\n" if not defined $perlExpr;

  my @renameCommandInfos;
  for my $file(@files){
    push @renameCommandInfos, calculateRenameCommandInfo($opts, $perlExpr, $file);
  }

  #skip identical, unchanged files
  #  skip commands like 'mv file file'
  @renameCommandInfos = grep {$$_{src} ne $$_{dest}} @renameCommandInfos;

  for my $cmdInfo(@renameCommandInfos){
    my @cmd = ("mv");
    push @cmd, "--no-clobber";
    push @cmd, $$cmdInfo{src};
    push @cmd, $$cmdInfo{dest};

    my $cmdFmt = formatCmd(@cmd);
    $cmdFmt = "#$cmdFmt" if $$opts{simulate};
    print "$cmdFmt\n";

    if(not $$opts{simulate}){
      system @cmd;
    }
  }
}

sub calculateRenameCommandInfo($$$){
  my ($opts, $perlExpr, $file) = @_;
  my ($dir, $baseName);
  if($file =~ /^(.*\/)([^\/]*)$/){
    ($dir, $baseName) = ($1, $2);
  }else{
    ($dir, $baseName) = ("", $file);
  }

  $_ = $baseName;
  eval $perlExpr;
  my $result = $_;

  if($result =~ /\//){
    die "ERROR: cannot change directory for $file\n";
  }
  my $src = "$dir$baseName";
  my $dest = "$dir$result";

  return {
    src     => $src,
    dest    => $dest,
  };
}

sub formatCmd(@){
  my @cmd = @_;
  my @cmdFmt;
  for my $arg(@cmd){
    #shell meta: |&;<>()$`\'"\n \t
    #plus !
    if($arg =~ /[|&;<>\$`\\'"\n \t!]/){
      #if arg contains shell meta, wrap in single quotes with replacements
      $arg =~ s/'/'\\''/g;
      $arg = "'$arg'";
    }
    push @cmdFmt, $arg;
  }
  return join(" ", @cmdFmt);
}

&main(@ARGV);
