#!/opt/pylitterbot-venv/bin/python
import argparse
import asyncio
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from pylitterbot import Account

SECRETS_FILE = str(Path.home()) + "/.secrets"

DELAY_SECONDS = 1

async def main():
  parser = argparse.ArgumentParser()
  parser.add_argument("--username", type=str,
                      help="whisker app username (email)")
  parser.add_argument("--password", type=str,
                      help="whisker app password")
  parser.add_argument("-g", "--get", action='store_true',
                      help="fetch and print robot info once")
  parser.add_argument("-m", "--monitor", action='store_true',
                      help=f"fetch and print robot info every {DELAY_SECONDS}s")

  args = parser.parse_args()

  username = args.username
  if username == None:
    username = os.environ.get("WHISKER_USERNAME")
  if username == None:
    username = readProc(["gpg-conf-read", str(Path.home()) + "/.secrets", "--key=whisker.email"])

  password = args.password
  if password == None:
    password = os.environ.get("WHISKER_PASSWORD")
  if password == None:
    password = readProc(["gpg-conf-read", str(Path.home()) + "/.secrets", "--key=whisker.password"])

  if username == None or password == None or username == "" or password == "":
    die(parser.format_help()
      + "\nERROR: missing username and/or password"
      + "\n  (can be given with --username/--password command line args,"
      + "\n   or WHISKER_USERNAME/WHISKER_PASSWORD environment variables)"
      + "\n")

  account = Account()
  try:
    if args.get:
      await account.connect(username=username, password=password, load_robots=True)
      for robot in account.robots:
        fmt = formatRobotInfo(robot)
        print(fmt, flush=True)
    elif args.monitor:
      await account.connect(username=username, password=password, load_robots=True)
      while True:
        for robot in account.robots:
          await robot.refresh()
          fmt = formatRobotInfo(robot)
          print(fmt, flush=True)
        time.sleep(DELAY_SECONDS)
    else:
      die(parser.format_help() + "\nERROR: no command given\n")
  finally:
      # Disconnect from the API.
     await account.disconnect()

def formatRobotInfo(robot):
  nowFmt = datetime.now().isoformat(timespec='milliseconds')
  fmt = ",".join([ nowFmt
        , robot.name
        , robot.serial
        , "status=" + str(robot.status)
        , "litter=" + str(robot.litter_level)
        , "waste=" + str(robot.waste_drawer_level)
        ])
  return fmt

def readProc(cmd):
  return subprocess.run(cmd, stdout=subprocess.PIPE).stdout.decode('utf-8').rstrip()

def die(msg):
  print(msg, file=sys.stderr)
  os._exit(1)

if __name__ == "__main__":
  asyncio.run(main())
