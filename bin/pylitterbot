#!/opt/pylitterbot-venv/bin/python
import argparse
import asyncio
import os
import subprocess
import sys
import time
from datetime import datetime
from enum import Enum
from pathlib import Path
from pylitterbot import Account

SECRETS_FILE = str(Path.home()) + "/.secrets"

DELAY_SECONDS = 1

class Cmd(Enum):
  GET     = "get"
  MONITOR = "monitor"
  HISTORY = "history"
  RESET   = "reset"
  CYCLE   = "cycle"

async def main():
  parser = argparse.ArgumentParser()
  parser.add_argument("--username", type=str,
                      help="whisker app username (email)")
  parser.add_argument("--password", type=str,
                      help="whisker app password")
  parser.add_argument("-g", "--get", action='store_true',
                      help="fetch and print robot info once (this is the default)")
  parser.add_argument("-m", "--monitor", action='store_true',
                      help=f"fetch and print robot info every {DELAY_SECONDS}s")
  parser.add_argument("--history", action='store_true',
                      help="fetch and print history for each robot")
  parser.add_argument("--reset", action='store_true',
                      help="run reset on all robots")
  parser.add_argument("-c", "--cycle", "--clean", action='store_true',
                      help="start a cleaning cycle (make sure pets are out)")

  args = parser.parse_args()

  username = args.username
  if username == None:
    username = os.environ.get("WHISKER_USERNAME")
  if username == None:
    username = readProc(["gpg-conf-read", str(Path.home()) + "/.secrets", "--key=whisker.email"])

  password = args.password
  if password == None:
    password = os.environ.get("WHISKER_PASSWORD")
  if password == None:
    password = readProc(["gpg-conf-read", str(Path.home()) + "/.secrets", "--key=whisker.password"])

  if username == None or password == None or username == "" or password == "":
    die(parser.format_help()
      + "\nERROR: missing username and/or password"
      + "\n  (can be given with --username/--password command line args,"
      + "\n   or WHISKER_USERNAME/WHISKER_PASSWORD environment variables)"
      + "\n")

  cmd = Cmd.GET
  if args.get:
    cmd = Cmd.GET
  elif args.monitor:
    cmd = Cmd.MONITOR
  elif args.history:
    cmd = Cmd.HISTORY
  elif args.reset:
    cmd = Cmd.RESET
  elif args.cycle:
    cmd = Cmd.CYCLE

  account = Account()

  try:
    if cmd == Cmd.GET:
      await account.connect(username=username, password=password, load_robots=True)
      for robot in account.robots:
        fmt = formatRobotInfo(robot)
        print(fmt, flush=True)
    elif cmd == Cmd.MONITOR:
      await account.connect(username=username, password=password, load_robots=True)
      while True:
        for robot in account.robots:
          await robot.refresh()
          fmt = formatRobotInfo(robot)
          print(fmt, flush=True)
        time.sleep(DELAY_SECONDS)
    elif cmd == Cmd.HISTORY:
      await account.connect(username=username, password=password, load_robots=True)
      for robot in account.robots:
        print(robot)
        hist = await robot.get_activity_history()
        for entry in hist:
          print(hist)
    elif cmd == Cmd.RESET:
      await account.connect(username=username, password=password, load_robots=True)
      print("reset:")
      for robot in account.robots:
        print(robot)
        await robot.reset()
    elif cmd == Cmd.CYCLE:
      await account.connect(username=username, password=password, load_robots=True)
      print("cycle:")
      for robot in account.robots:
        print(robot)
        await robot.start_cleaning()
    else:
      die(parser.format_help() + "\nERROR: no command given\n")
  finally:
      # Disconnect from the API.
     await account.disconnect()

def formatRobotInfo(robot):
  nowFmt = datetime.now().isoformat(timespec='milliseconds')
  fmt = ",".join([ nowFmt
        , robot.name
        , robot.serial
        , "status=" + str(robot.status)
        , "litter=" + str(robot.litter_level)
        , "waste=" + str(robot.waste_drawer_level)
        ])
  return fmt

def readProc(cmd):
  return subprocess.run(cmd, stdout=subprocess.PIPE).stdout.decode('utf-8').rstrip()

def die(msg):
  print(msg, file=sys.stderr)
  os._exit(1)

if __name__ == "__main__":
  asyncio.run(main())
