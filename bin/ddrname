#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(sleep);

my $SONG_LIST_FILE = "$ENV{HOME}/.config/ddrname-songlist";
my $SONG_LIST_FILE_STEPMANIA = "$ENV{HOME}/.config/ddrname-songlist-stepmania";

my $scoreDir = "$ENV{HOME}/DCIM/xddr";
$scoreDir = "/home/user/pixmirror/xddr" if not -d $scoreDir;

my $EXIFTOOL_EXEC = "exiftool";
my $PIX_EXEC = "pix";

my $gnuplotDefaultPngSize = "1920,1080";

#FAIL if any course has songs with mtimes within this amount of time
my $COURSE_MIN_STAGE_GAP_SECONDS = 30;

#songs are in the same course if they have mtimes within the stage-gap of each other
#  the stage-gap is this amount of time, multiplied by the difference between stages
#  e.g.: a 1st-stage and a 3rd-stage within twice this time are in the same course
my $COURSE_MAX_STAGE_GAP_SECONDS = 5 * 60;

#courses are in the same session if they are within the course-gap of each other
#  the course-gap is the difference between the mtime of the last song of one course,
#  and the mtime of the first song of the next course
my $SESSION_MAX_COURSE_GAP_SECONDS = 6 * 60 * 60;

my @DEFAULT_BUCKET_FIELDS = qw(song game difficulty machine);
my $bucketFieldDesc = join "-", map {"<" . uc($_) . ">"} @DEFAULT_BUCKET_FIELDS;

my $defaultNotes = {
  'fc' => 1,
  'special' => 0,
  'highscore' => 0,
  'nobar' => 0,
  '3rd' => 0,
};
my $defaultNotesFormat = join ",", grep {$$defaultNotes{$_}} keys %$defaultNotes;

my @okFilters = qw(
  --song
  --hard --nothard --feet --minfeet --maxfeet
  --singles --doubles --nonstop --nonstopdoubles
  --beginner --basic --difficult --expert --challenge
  --machine --sn2 --2013 --x3 --a --sm
  --tw
  --score --minscore --maxscore --monotonic --increasing --records
  --date --mindate --maxdate --dailybest
  --recent --sixmos --sixmonths --6mos
  --bar --nobar --diffbar --samebar
);
my $yesbarFilter="bar";
my $nobarFilter="nobar";
my $diffbarFilter="diffbar";
my $samebarFilter="samebar";

my $argOptFiltersRegex = join "|", qw(
  --song
  --feet --minfeet --maxfeet
  --score --minscore --maxscore
  --date --mindate --maxdate
  --machine
  --tw
);

my @okFormatOptDates = qw(--showscores --reverse --short);
my $okFormatOptDatesRegex = join "|", @okFormatOptDates;
my $argOptFormatOptDatesRegex = join "|", qw();

my @okFormatOptCourses = qw(--minlen);
my $okFormatOptCoursesRegex = join "|", @okFormatOptCourses;
my $argOptFormatOptCoursesRegex = join "|", qw(--minlen);

my @okFormatOptSongs = qw(
  --format --group-buckets --no-group-buckets --best-by-bucket
  --notes --abbrev --combine-machines
);
my $okFormatOptSongsRegex = join "|", @okFormatOptSongs;
my $argOptFormatOptSongsRegex = join "|", qw(--format --notes);

my @okPlotOptions = qw(--file --size --smooth);
my $okPlotOptionsRegex = join "|", @okPlotOptions;
my $argOptPlotOptionsRegex = join "|", qw( --file --size );

my @okFileFormatVars = qw(
  file
  date
  index
  song
  game
  difficulty
  machine
  timingWindows
  score
  fc
  special
  bar
  stage
  game
  feet
  quality
);
my $okFileFormatVarsRegex = join "|", @okFileFormatVars;

# DDRA-style 1-20 scale
my $HARD_SONG_FEET = 14;

sub getUsage(;$);
sub readSongLists();
sub readSongListFromFile($);
sub fehterm($@);
sub orientation($@);
sub dateStats($@);
sub courseStats($@);
sub scoreStats($@);
sub formatFileInfo($$);
sub parsePlotOptions($);
sub parseFilterOptions($);
sub validateFile($);
sub validateInfo($);
sub nameReminder($$);
sub nameFile($$$$);
sub editNames($$@);
sub parseOptsAndInfoArgs(@);
sub getScoresByFile();
sub listScoreFiles();
sub parseScoreFile($);
sub getQualityPoints($);
sub sortScores($);
sub getBucketName($$@);
sub getScoreBuckets($$@);
sub formatScoreLine($$$$$);
sub getBucketBarCounts($);
sub filterScores($$);
sub getMtimesByFile($);
sub splitScoresIntoCourses($$);
sub splitCoursesIntoSessions(@);
sub formatScores($$$$$$$);
sub getBestScore($);
sub getBestScoresByBucket($);
sub gnuplot($$);
sub combine(@);
sub mtime($);
sub getImageOrientation($);
sub parseFeetDifficulties(@);
sub checkUnique(@);
sub bannerFlash($);
sub bashComplete($$);
sub warnMsg($);
sub run(@);

my @songArr = readSongLists();

my %songAbbrevs = map { $$_[0] => $$_[1] } @songArr;
my %songFeetDifficulties = map { $$_[0] => parseFeetDifficulties(@{$$_[2]}) } @songArr;

my @songArgs = sort {$a cmp $b} map { $$_[0] } @songArr;
my $okSongArgs = join '|', @songArgs;

my @gameArgs = qw(singles doubles nonstop nonstopdoubles);
my $emptyGameArg = "singles";
my $okGameArgs = join '|', @gameArgs;

my %gameAbbrevs = (
  singles => 'SGL',
  doubles => 'DBL',
  nonstop => 'NON',
  nonstopdoubles => 'NDB',
);

my @difficultyArgs = qw(beginner basic difficult expert challenge);
my $okDifficultyArgs = join '|', @difficultyArgs;

my %difficultyAbbrevs = (
  beginner => 'beg',
  basic => 'bas',
  difficult => 'dif',
  expert => 'exp',
  challenge => 'cha',
);

my @machineArgs = qw(sn2 2013 x3 a sm50pdp sm53pdp);
my $defaultMachineArg = "sm53pdp";
my $okMachineArgs = join '|', @machineArgs;

my @timingWindowsArgs = qw(twdefault);
my $emptyTimingWindowsArg = "twdefault";
my $okTimingWindowsArgs = join '|', @timingWindowsArgs;

my @stageArgs = qw(0none 1st 2nd 3rd 4extra 4nonstop 5encore);
my $okStageArgs = join '|', @stageArgs;

my @barArgs = qw(bar nobar avgbar);
my $avgbarArg = "avgbar";
my $yesbarArg = "bar";
my $nobarArg = "nobar";
my $okBarArgs = join '|', @barArgs;

my @fcArgs = qw(nofc gfc fc pfc mfc);
my $emptyFCArg = "nofc";
my $okFCArgs = join '|', @fcArgs;

my @specialArgs = qw(nospecial unlock);
my $emptySpecialArg = qw(nospecial);
my $okSpecialArgs = join '|', @specialArgs;

my @failedArgs = qw(passed failed);
my $emptyFailedArg = "passed";
my $okFailedArgs = join '|', @failedArgs;

sub getUsage(;$){
  my $msg = shift;

  my $usage = "Usage:
  $0 --fehterm
    run \"fehterm 'ddrname %f '\" (opens feh and a terminal connected to it with xdotool)

  $0 --banners SONG
    use zenius-ddrsonglist to fetch banner images for SONG
      and display them with image-flash
    more or less equivalent to:
      \$(image-flash \$(zenius-ddrsonglist --banners SONG))

  $0 --orientation [FILTER FILTER ..]
    for each song file, print \"<orientation> <filename>\",
      where orientation is one of \"landscape\", \"portrait\", or \"unknown\"
    uses \"$EXIFTOOL_EXEC\", falling back on \"$PIX_EXEC\"

  $0 --datestats [FORMAT_OPT_DATES FORMAT_OPT_DATES ..] [FILTER FILTER ..]
    format stats for each session
    a session is every course within " . int($SESSION_MAX_COURSE_GAP_SECONDS/60.0) . "min of each other
      (see --coursestats for more info on courses)
    the gap between courses is he difference between the mtime of the last song of a course,
      and the mtime of the first song of the next course

    FORMAT_OPT_DATES
      --showscores
        show all scores, one per line, instead of just a count
      --reverse
        print newest dates first, instead of oldest dates first
      --short
        dont show individual songs at all

    FILTER
      see --print FILTER

  $0 --coursestats [FORMAT_OPT_COURSES FORMAT_OPT_COURSES ..] [FILTER FILTER ..]
    show songs that appear to be part of the same course, played back-to-back
    songs must be of increasing stage number,
      and have mtimes at most ${COURSE_MAX_STAGE_GAP_SECONDS}s between successive stages.
      (stages can be missing; an extra ${COURSE_MAX_STAGE_GAP_SECONDS}s is allowed for any gaps)
    e.g.:
      A 1st 12:00
      B 2nd 12:03
      C 3rd 12:07
      D 1st 12:11
      E 3rd 12:17
      F 1st 12:38
      G 2nd 12:46
      H 3rd 12:47
      => [A-B-C], [D-E], [F], [G-H]
         A and B and C are a normal stage, less than 5 between each
         C and D are not sequential stages
         D and E are within 5min+5min, with gap for missing 2nd
         F and G are NOT within 5min
         G and G are within 5min
         F and H are within 5min+5min, but 2nd is not missing

    FORMAT_OPT_COURSES
      --minlen LENGTH
        show only courses where at least LENGTH scores are recorded
        default is: 2
        LENGTH=3
          show only courses with 3 or more songs recorded (after filtering)
        LENGTH=2 {default}
          show only courses with 2 or more songs recorded (after filtering)
        LENGTH=1 or LENGTH=0
          show all courses,, even if only one score recorded (after filtering)

    FILTER
      see --print FILTER

  $0 --print [FORMAT_OPT_SCORES FORMAT_OPT_SCORES ..] [FILTER FILTER ..]
    parse filenames of score pictures in $scoreDir
      and print the result

    scores are filtered, and then grouped into sections by bucket
      sections start with \"$bucketFieldDesc\" and are separated by an empty line
      (see --group-buckets)
    each contains the scores for the bucket, one per line
      formatted '%{date},%{score},%{notes}' e.g.: 20180523,999930,pfc
      (see --format)
    \"notes\" are a space-separated list of:
      FC      if one of [$okFCArgs] is present in the filename
      SPECIAL if one of [$okSpecialArgs] is present in the filename
      nobar   if $bucketFieldDesc is hard (FEET>=$HARD_SONG_FEET)
      3rd     if $bucketFieldDesc is hard (FEET>=$HARD_SONG_FEET)
      (see --notes)

      e.g.: \"max300-doubles-expert\"
            20140331,723150,
            20140401,990000,pfc nobar
            20140402,684120,nobar
            20140403,784120,fc


            \"paranoiarespect-expert\"
            20140331,723150,

    FORMAT_OPT_SCORES
      --format FORMAT_SPEC
        format each song line using FORMAT_SPEC (default is: %{date},%{score},%{notes})
        variables are formatted: %{VAR_NAME}

        VAR_NAME
          $okFileFormatVarsRegex
          | notes   (space-separated list of vars from NOTES_CSV)
          | bucket  ($bucketFieldDesc)
      --group-buckets
        (this is the default)
        print bucket name (SONG-GAME-DIFFICULTY-MACHINE),
          followed by one line for each score in the bucket
        separate buckets by an empty line
        implies:
          --format=\"%{date},%{score},%{notes}\"
          (this can be overriden with a later --format)
      --no-group-buckets
        print each score, one per line, with no bucket name headers or separators
        implies:
          --format=\"%{bucket},%{date},%{score},%{notes}
          (this can be overriden with a later --format)
      --best-by-bucket
        include ONLY the highest score per bucket
      --notes NOTES_CSV
        comma-separated list of notes to add.
        default is: '$defaultNotesFormat'.
        use empty string for none

        fc
          add FC if FC is set for the song
        special
          add SPECIAL if SPECIAL is set for the song
        highscore
          add 'SCORE SONG' if SCORE is the highest in the bucket
        nobar
          add 'nobar' if $bucketFieldDesc is hard (FEET>=$HARD_SONG_FEET) and BAR is '$nobarArg'
        3rd
          add '3rd' if $bucketFieldDesc is hard (FEET>=$HARD_SONG_FEET) and STAGE is '3rd'
      --abbrev
        shorten bucket names by using song abbreviations
      --combine-machines
        ignore machine field for bucket grouping (not for filtering)
          after filtering (which can still filter by machine),
          combine all scores with the same song/game/difficulty into one bucket
        this also changes the bucket header from
          SONG-GAME-DIFFICULTY-MACHINE => SONG-GAME-DIFFCULTY

    FILTER: SONG
      --song REGEX
        include only scores where the whole SONG string matches REGEX

    FILTER: FEET
      --hard
        include only scores where $bucketFieldDesc is hard (FEET>=$HARD_SONG_FEET)
        {overrides --nothard}
      --nothard
        include only scores where $bucketFieldDesc is not hard (FEET<$HARD_SONG_FEET)
        {overrides --hard}
      --feet <EXACT_FEET>
        include only scores where $bucketFieldDesc has FEET=EXACT_FEET
      --minfeet <MIN_FEET>
        include only scores where $bucketFieldDesc has FEET>=MIN_FEET
      --maxfeet <MAX_FEET>
        include only scores where $bucketFieldDesc has FEET<=MAX_FEET

      FEET are ALWAYS in the DDR-A/DDR-2013/DDR-X/etc 1-20 scale (max-300 is 15 feet)
      these values are stored in DDR-A scale in:
        $SONG_LIST_FILE
      this file is constructed using `zenius-ddrsonglist`,
        which reads the info from the 'game' pages on zenius-i-vanisher
      zenius-ddrsonglist takes the data from the following games, in order:
        DDR-A20
        DDR-A
        DDR-2013
        DDR-X
        DDR-SN2
      if DDR-SN2 (which uses the old 1-10 scale) was used, it was scaled up
        using the average ratio for that difficulty between DDRA20 and SN2

      custom songs are stored in:
        $SONG_LIST_FILE_STEPMANIA
      this file has hardcoded best-guess entries for feet, also in the DDR-A 1-20 scale

    FILTER: GAME
      --singles
        include only scores where GAME is singles OR not defined
        {overrides --doubles and --nonstop and --nonstopdoubles}
      --doubles
        include only scores where GAME is doubles
        {overrides --singles and --nonstop and --nonstopdoubles}
      --nonstop
        include only scores where GAME is nonstop
        {overrides --singles and --doubles and --nonstopdoubles}
      --nonstopdoubles
        include only scores where GAME is nonstopdoubles
        {overrides --singles and --nonstop and --doubles}

    FILTER: DIFFICULTY
      --beginner
        include only scores where DIFFICULTY is beginner OR not defined
        {overrides --basic and --difficult and --expert and --challenge}
      --basic
        include only scores where DIFFICULTY is beginner OR not defined
        {overrides --beginner and --difficult and --expert and --challenge}
      --difficult
        include only scores where DIFFICULTY is beginner OR not defined
        {overrides --beginner and --basic and --expert and --challenge}
      --expert
        include only scores where DIFFICULTY is beginner OR not defined
        {overrides --beginner and --basic and --difficult and --challenge}
      --challenge
        include only scores where DIFFICULTY is beginner OR not defined
        {overrides --beginner and --basic and --difficult and --expert}

    FILTER: MACHINE
      --machine MACHINE_CSV
        include only scores where MACHINE is one of the values
          in the comma-separated list of machines MACHINE_CSV
          (all other scores are excluded)
        e.g.: --machine sn2,x3,sm50pdp
      --sn2
        include only scores where MACHINE is sn2 (same as: --machine sn2)
      --2013
        include only scores where MACHINE is 2013 (same as: --machine 2013)
      --x3
        include only scores where MACHINE is x3 (same as: --machine x3)
      --a
        include only scores where MACHINE is a (same as: --machine a)
      --sm
        include only scores where MACHINE is sm50pdp or sm53pdp
        (same as: --machine sm50pdp,sm53pdp)

    FILTER: TIMING_WINDOWS
      --tw TIMING_WINDOWS_CSV
        include only scores where TIMING_WINDOWS is one of the values
          in the comma-separated list of timing windows TIMING_WINDOWS_CSV
          (all other scores are excluded)
        NOTE: $emptyTimingWindowsArg matches scores where no timing windows are set

    FILTER: SCORE
      --score N, --minscore N
        include only scores where SCORE >= N
      --maxscore N
        include only scores where SCORE <= N
      --monotonic, --increasing, --records
        disclude any score that is lower than any score from a previous date,
        with the same $bucketFieldDesc

    FILTER: DATE
      --date YYYYMMDD, --mindate YYYYMMDD
        include only scores where DATE >= YYYYMMDD
        {overrides --recent}
      --maxdate YYYYMMDD
        include only scores where DATE <= YYYYMMDD
      --recent, --sixmos, --sixmonths, --6mos
        same as '--mindate N', where N is the date 180 days ago
        {overrides --date}
      --dailybest
        include only the highest score for each DATE within each $bucketFieldDesc

    FILTER: BAR
      --bar
        include only scores where BAR=$yesbarArg
      --nobar
        include only scores where BAR=$nobarArg
      --diffbar
        include only scores where BAR is different than at least half of all
          scores with the same \"$bucketFieldDesc\"
          (counted against all scores, before any filtering)
      --samebar
        include only scores where BAR is the same as at least half of all
          scores with the same \"$bucketFieldDesc\"
          (counted against all scores, before any filtering)

      e.g.:
        TOTAL|BAR=yes|BAR=no|--bar |--nobar |--diffbar|--samebar
        =====|=======|======|======|========|=========|===========
        2    |1      |1     |B1 N0 |B0 N1   |B1 N1    |B1 N1
        2    |2      |0     |B2 N0 |B0 N0   |B0 N0    |B2 N0
        3    |1      |2     |B1 N0 |B0 N2   |B1 N0    |B0 N2
        4    |2      |2     |B2 N0 |B0 N2   |B2 N2    |B2 N2

        the 3rd row, in english, says if there are 3 songs recorded
          for the given $bucketFieldDesc,
          and 1 has BAR=$yesbarArg, and 2 have BAR=$nobarArg, then:
            --bar will show the one with BAR=$yesbarArg
            --nobar will show the two with BAR=$nobarArg
            --diffbar will show the one with BAR=$yesbarArg
            --samebar will show the two with BAR=$nobarArg

  $0 --gnuplot [PLOT_OPTION PLOT_OPTION ..] [FORMAT_OPT_SCORES FORMAT_OPT_SCORES ..] [FILTER FILTER ..]
    format songs as above and write to a tmp file
    write a gnuplot script and run it in gnuplot
      all PLOT_OPTIONs must precede all FILTERs

    PLOT_OPTION
      --file PNG_FILE_PATH
        output PNG file to indicated path

      --size PNG_SIZE
        output PNG pixelsize, WIDTHxHEIGHT
        'x' can be any combination of spaces, commas, and 'x's
        default is: $gnuplotDefaultPngSize

      --smooth
        use 'smooth bezier' instead of 'with linespoints'
        also turns off all notes unless --notes is given

    FORMAT_OPT_SCORES
      see --print FORMAT_OPT_SCORES

    FILTER
      see --print FILTER

  $0 --files [--format FILE_FORMAT_PATTERN] [FILTER FILTER ..]
    print the filenames, one per line without directories, of matching songs

    FILTER
      see --print FILTER

    FILE_FORMAT_PATTERN
      printing format for each score file
      variables are formatted: %{VAR_NAME}
      default is: %{file}

      VAR_NAME
        one of: @okFileFormatVars

  $0 --bestfiles [--format FILE_FORMAT_PATTERN] [FILTER FILTER ..]
    print the filename of the highest score for each set of scores with the same:
      $bucketFieldDesc

    FILTER
      see --print FILTER

    FILE_FORMAT_PATTERN
      see --files FILE_FORMAT_PATTERN

  $0 IMG_FILE REMINDER

    rename a jpg/png file, adding '_<REMINDER>' before '.EXT'

     IMG_FILE
       jpg/png file to rename
       must start with '########_###' and end with '.EXT'

     EXT
       one of [jpg|png]

     REMINDER
       text to append
         if REMINDER starts with the same prefix as IMG_FILE ('########_###'):
           remove that prefix from REMINDER text (dont duplicate it)
         if REMINDER ends with '.EXT':
           remove .EXT from REMINDER text (dont duplicate it)
       must:
         -start with 'reminder_'
         -contain only letters, numbers, underscores, and dashes
         -and end with a letter or number

  $0 IMG_FILE [OPT OPT ..] [INFO_ARG INFO_ARG ..]

    rename a jpg/png file using a consistent format
    \"########_###_SONG_GAME_DIFFICULTY_MACHINE_SCORE_FC_SPECIAL_BAR_STAGE.EXT\"
    ######## is presumably a date in YYYYMMDD and ### is the camera pic index

     IMG_FILE
       jpg/png file to rename
       must start with '########_###' and end with .EXT

     EXT
       one of [jpg|png]

     INFO_ARG
       one of [SONG|GAME|DIFFICULTY|MACHINE|TIMING_WINDOWS|SCORE|STAGE|BAR|FC|SPECIAL|FAILED]
       exactly one SONG, DIFFICULTY, SCORE, STAGE, and BAR must be given
       exactly zero or one MACHINE args can be given  {REQUIRED, but defaults to '$defaultMachineArg' if missing}
       exactly zero or one GAME args can be given  {optional, '$emptyGameArg' is the same as no GAME arg}
       exactly zero or one TIMING_WINDOWS args can be given {optional, '$emptyTimingWindowsArg' is the same as no TIMING_WINDOWS arg}
       exactly zero or one FC args can be given  {optional, '$emptyFCArg' is the same as no FC arg}
       exactly zero or one SPECIAL args can be given  {optional, '$emptySpecialArg' is the same as no SPECIAL arg}
       exactly zero or one FAILED args can be given  {optional, '$emptyFailedArg' is the same as no FAILED arg}

     SONG            {REQUIRED}
       song name from $SONG_LIST_FILE
         (or $SONG_LIST_FILE_STEPMANIA)

       each non-empty line in the song list must be formatted like this:
       \"SONG   ABBREV   FEET FEET FEET FEET FEET    FEET FEET FEET FEET\"

         SONG is the song name
           if consists only of lower-case letters, numbers, and dashes (e.g.: max-300)
         ABBREV is the abbreviation for the SONG
         FEET is the song's feet difficulty. it must be an integer or one-or-more dashes '--'
           they are listed in the song list in the following order:
           singles (beginner, basic, difficult, expert, challenge)
           doubles (basic, difficult, expert, challenge)

     GAME            {optional, '$emptyGameArg' is the same as no GAME arg}
       one of [$okGameArgs]

     DIFFICULTY      {REQUIRED}
       one of [$okDifficultyArgs]

     MACHINE         {REQUIRED, but defaults to '$defaultMachineArg' if missing}
       one of [$okMachineArgs]

     TIMING_WINDOWS  {optional, '$emptyTimingWindowsArg' is the same as no TIMING_WINDOWS arg}
       one of [$okTimingWindowsArgs]

     SCORE           {REQUIRED}
       an integer between 100,000 and 1,000,000
       must be a multiple of 10
       commas, if present, are stripped out

     FC              {optional, '$emptyFCArg' is the same as no FC arg}
       one of [$okFCArgs]

     SPECIAL         {optional, '$emptySpecialArg' is the same as no SPECIAL arg}
       one of [$okSpecialArgs]

     BAR             {REQUIRED}
       one of [$okBarArgs]
         $avgbarArg is replaced with the most common BAR arg for this bucket[@DEFAULT_BUCKET_FIELDS]
         if the counts are tied (new song, or both the same number of $yesbarArg/$nobarArg), then:
           \"$yesbarArg\" if song is HARD (feet>$HARD_SONG_FEET)
           \"$nobarArg\" otherwise

     STAGE           {REQUIRED}
       one of [$okStageArgs]

     FAILED          {optional, '$emptyFailedArg' is the same as no FAILED arg}
       one of [$okFailedArgs]
       if 'failed', name will start with \"reminder_failed\"

     OPT
       --banner-flash
         show song banners on rename (this is the default)
       --no-banner-flash
         do NOT show song banners on rename
       --check-orientation
         check EXIF orientation with $EXIFTOOL_EXEC (this is the default)
       --no-check-orientation
         do NOT check EXIF orientation with $EXIFTOOL_EXEC
       --fast
         same as --no-banner-flash --no-check-orientation

  $0 --edit-names [OPT OPT ..] [INFO_ARG INFO_ARG ..] [IMG_FILE IMG_FILE ..]
    group-edit a single attribute for multiple files
    for each IMG_FILE:
      -parse original info args attributes from IMG_FILE file name
      -replace previous values of the attribute for each INFO_ARG given
      -rename the file, as in '$0 IMG_FILE [OPT OPT ..] [INFO_ARG INFO_ARG ..]'

  $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion, one per line
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline
  ";

  $usage =~ s/\s*$//;
  chomp $usage;
  $usage .= "\n";

  if(defined $msg){
    chomp $msg;
    $usage .= "\n$msg\n";
  }

  return $usage;
}

sub main(@){
  #allow abbrevs to be the same as the full song name (e.g.: chaos)
  my @uniqSongAbbrevs = sort values %songAbbrevs;
  @uniqSongAbbrevs = grep {not defined $songAbbrevs{$_}} @uniqSongAbbrevs;
  checkUnique(
    @okFilters,
    @okFormatOptDates, @okFormatOptCourses, @okFormatOptSongs, @okPlotOptions,

    @songArgs, @gameArgs, @difficultyArgs,
    @machineArgs, @timingWindowsArgs, @stageArgs, @barArgs, @fcArgs, @specialArgs,
    @uniqSongAbbrevs,
    (sort values %gameAbbrevs),
    (sort values %difficultyAbbrevs),
  );

  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print map {"$_\n"} bashComplete($_[1], $_[2]);
    exit 0;
  }

  if(@_ == 1 and $_[0] =~ /^(--fehterm)$/){
    my $cmd = shift;
    exec "fehterm", "ddrname %f ";
  }elsif(@_ == 2 and $_[0] =~ /^(--banners)$/){
    my $cmd = shift;
    bannerFlash($_[0]);
  }elsif(@_ >= 1 and $_[0] =~ /^(--orientation)$/){
    my $cmd = shift;
    orientation($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--datestats)$/){
    my $cmd = shift;
    dateStats($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--coursestats)$/){
    my $cmd = shift;
    courseStats($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--print|--gnuplot|--files|--bestfiles)$/){
    my $cmd = shift;
    scoreStats($cmd, @_);
  }elsif(@_ >= 2 and $_[0] =~ /^(--edit-names)$/){
    my ($cmd, @args) = @_;
    my (@infoArgs, @imgFiles);
    while(@args > 0 and not -f $args[0]){
      push @infoArgs, shift @args;
    }
    @imgFiles = @args;
    my ($opts, $editInfo) = parseOptsAndInfoArgs @infoArgs;
    editNames($editInfo, $opts, @imgFiles);
  }elsif(@_ == 2 and $_[0] =~ /\.(jpg|png)$/){
    nameReminder($_[0], $_[1]);
  }elsif(@_ > 1 and $_[0] =~ /\.(jpg|png)$/){
    my ($file, @args) = @_;
    my ($opts, $info) = parseOptsAndInfoArgs @args;
    $$info{machine} = $defaultMachineArg if not defined $$info{machine};
    $$info{game} = $emptyGameArg if not defined $$info{game};
    $$info{timingWindows} = $emptyTimingWindowsArg if not defined $$info{timingWindows};
    $$info{fc} = $emptyFCArg if not defined $$info{fc};
    $$info{special} = $emptySpecialArg if not defined $$info{special};
    $$info{failed} = $emptyFailedArg if not defined $$info{failed};

    my $scoresByFile = getScoresByFile();
    my $scores = [values %$scoresByFile];
    my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);

    nameFile($file, $info, $buckets, $opts);
  }else{
    die getUsage();
  }
}

sub readSongLists(){
  my @songs;
  if(-f $SONG_LIST_FILE){
    @songs = (@songs, readSongListFromFile($SONG_LIST_FILE));
  }else{
    die getUsage("ERROR: Could not find $SONG_LIST_FILE") if not -f $SONG_LIST_FILE;
  }

  if(-f $SONG_LIST_FILE_STEPMANIA){
    @songs = (@songs, readSongListFromFile($SONG_LIST_FILE_STEPMANIA));
  }

  return @songs;
}

sub readSongListFromFile($){
  my ($file) = @_;
  open FH, "< $file" or die "Could not read $file\n$!\n";
  my @songs;
  while(my $line = <FH>){
    $line =~ s/#.*//;
    next if $line =~ /^\s*$/;
    $line =~ s/\|/ /g;
    if($line =~ /^\s*([a-zA-Z0-9\-]+)\s+([a-zA-Z0-9]+)((?:\s+(?:\d+|-+)){9})\s*$/){
      my ($song, $abbrev, $feet) = ($1, $2, $3);
      my @feetArr = $feet =~ /\s+(\d+|-+)/g;
      if(@feetArr != 9){
        die getUsage("ERROR: Malformed feet in line in $file: $line");
      }
      push @songs, [$song, $abbrev, [@feetArr]];
    }else{
      die getUsage("ERROR: Malformed line in $file: $line");
    }
  }
  return @songs;
}

sub orientation($@){
  my $cmd = shift;
  my $opts = [@_];

  my $filters = parseFilterOptions $opts;
  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  for my $file(sort keys %$scoresByFile){
    my $orientation = getImageOrientation "$scoreDir/$file";
    $orientation = "unknown" if not defined $orientation;
    print "$orientation $file\n";
  }
}

sub dateStats($@){
  my $cmd = shift;
  my $opts = [@_];

  my $showScores = 0;
  my $reverse = 0;
  my $short = 0;
  while(@$opts > 0 and $$opts[0] =~ /^($okFormatOptDatesRegex)$/){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptFormatOptDatesRegex)$/){
      die "malformed or missing argument to $opt\n" if @$opts == 0;
      $arg = shift @$opts;
    }

    if($opt =~ /^(--showscores)$/){
      $showScores = 1;
    }elsif($opt =~ /^(--reverse)$/){
      $reverse = 1;
    }elsif($opt =~ /^(--short)$/){
      $short = 1;
    }
  }

  my $filters = parseFilterOptions $opts;

  die getUsage() if @$opts != 0;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my @courses = splitScoresIntoCourses $scoresByFile, getMtimesByFile $scoresByFile;

  my @sessions = splitCoursesIntoSessions @courses;

  @sessions = reverse @sessions if $reverse;

  my @feetToPrint = (17, 16, 15);

  for my $session(@sessions){
    my @sessionAllScores = @{$$session{allScores}};
    my $totalCount = $$session{sessionScoreLen};
    my $hardSinglesCount = 0;
    my $doublesCount = 0;
    my %feetCount = map {$_ => 0} @feetToPrint;
    for my $score(@sessionAllScores){
      if($$score{game} eq "doubles"){
        $doublesCount++;
      }elsif($$score{feet} > $HARD_SONG_FEET){
        $hardSinglesCount++;
      }
      $feetCount{$$score{feet}}++;
    }

    my $buckets = getScoreBuckets \@sessionAllScores, 1, @DEFAULT_BUCKET_FIELDS;
    my @bucketSummary;
    for my $bucketName(sort keys %$buckets){
      my @scores = @{$$buckets{$bucketName}};
      my $first = $scores[0];

      my $isDoubles = $$first{game} eq "doubles" ? 1 : 0;
      my $hardSong = $$first{feet} > $HARD_SONG_FEET ? 1 : 0;

      my $count = @scores;
      push @bucketSummary, {
        name=>$bucketName,
        count=>$count,
        isDoubles=>$isDoubles ? 1 : 0,
        isHardSingles=>(not $isDoubles and $hardSong) ? 1 : 0,
        scores=>[reverse sort map {$$_{score}} @scores],
      };
    }

    my $elapsedHours = ($$session{mtimeMax} - $$session{mtimeMin}) / 60.0 / 60.0;

    my $dateFmt = $$session{sessionDateFmt};

    my $fmt = "";
    $fmt .= sprintf "%s %3.1fh  %2d-T %2d-H %2d-D",
      $dateFmt, $elapsedHours, $totalCount, $hardSinglesCount, $doublesCount;
    $fmt .= sprintf " %2d-%d", $feetCount{$_}, $_ foreach @feetToPrint;

    @bucketSummary = sort {
      $$b{count} <=> $$a{count}
        or $$b{isHardSingles} <=> $$a{isHardSingles}
        or $$b{isDoubles} <=> $$a{isDoubles}
        or $b cmp $a
    } @bucketSummary;

    if(not $short){
      for my $summary(@bucketSummary){
        if($showScores){
          $fmt .= sprintf "\n  %-9s %s", $$summary{name}, "@{$$summary{scores}}";
        }else{
          $fmt .= sprintf "  %2d %s", $$summary{count}, $$summary{name};
        }
      }
      if($showScores){
        $fmt .= "\n";
      }
    }

    print "$fmt\n";
  }
}

sub courseStats($@){
  my $cmd = shift;
  my $opts = [@_];

  my $minlen = 2;
  while(@$opts > 0 and $$opts[0] =~ /^($okFormatOptCoursesRegex)$/){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptFormatOptCoursesRegex)$/){
      die "malformed or missing argument to $opt\n" if @$opts == 0;
      $arg = shift @$opts;
    }
    if($opt =~ /^(--minlen)$/){
      $minlen = $arg;
    }
  }

  my $filters = parseFilterOptions $opts;

  die getUsage() if @$opts != 0;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my @courses = splitScoresIntoCourses($scoresByFile, getMtimesByFile $scoresByFile);

  @courses = grep {$$_{courseLen} >= $minlen} @courses;

  for my $course(@courses){
    my $fmt = "$$course{courseDateFmt}:";
    for my $score(@{$$course{scores}}){
      $fmt .= " " . getBucketName $score, 1, @DEFAULT_BUCKET_FIELDS;
    }
    $fmt .= "\n";
    for my $score(@{$$course{scores}}){
      my $abbrevBucketName = getBucketName $score, 1, @DEFAULT_BUCKET_FIELDS;
      $fmt .= "  $$score{stage} $$score{score} $abbrevBucketName\n";
    }
    print $fmt;
  }
}

sub scoreStats($@){
  my $cmd = shift;
  my $opts = [@_];

  my $plotOptions = parsePlotOptions $opts if $cmd =~ /^(--gnuplot)$/;

  my $okNotes = $defaultNotes;
  if($$plotOptions{smooth}){
    $okNotes = {map {$_ => 0} keys %$okNotes};
  }

  my $format = "%{date},%{score},%{notes}";
  my $groupBuckets = 1;
  my $bestByBucketOnly = 0;
  my $abbrevBucket = 0;
  my $combineMachines = 0;

  if($cmd =~ /^(--print|--gnuplot)$/){
    while(@$opts > 0 and $$opts[0] =~ /^($okFormatOptSongsRegex)$/){
      my $opt = shift @$opts;
      my $arg;
      if($opt =~ /^($argOptFormatOptSongsRegex)$/){
        die "malformed or missing argument to $opt\n" if @$opts == 0;
        $arg = shift @$opts;
      }
      if($opt =~ /^(--format)$/){
        $format = $arg;
      }elsif($opt =~ /^(--group-buckets)$/){
        $groupBuckets = 1;
        $format = "%{date},%{score},%{notes}";
      }elsif($opt =~ /^(--no-group-buckets)$/){
        $groupBuckets = 0;
        $format = "%{bucket},%{date},%{score},%{notes}";
      }elsif($opt =~ /^(--best-by-bucket)$/){
        $bestByBucketOnly = 1;
      }elsif($opt =~ /^(--notes)$/){
        my $notesCsv = $arg;
        $$okNotes{$_} = 0 foreach keys %$okNotes;

        my @notes = split /\s*,\s*/, $notesCsv;
        for my $note(@notes){
          die "invalid note '$note' in --notes: $note\n" if not defined $$okNotes{$note};
          $$okNotes{$note} = 1;
        }
      }elsif($opt =~ /^(--abbrev)$/){
        $abbrevBucket = 1;
      }elsif($opt =~ /^(--combine-machines)$/){
        $combineMachines = 1;
      }else{
        die "ERROR: unknown opt $opt\n";
      }
    }
  }

  my $fileFormatPattern = "%{file}";
  if($cmd =~ /^(--files|--bestfiles)$/){
    if(@$opts > 1 and $$opts[0] =~ /^--format$/){
      shift @$opts;
      $fileFormatPattern = shift @$opts;
    }
  }

  my $filters = parseFilterOptions $opts;

  if($cmd =~ /^(--print)$/){
    my $fmt = formatScores($format, $groupBuckets, $bestByBucketOnly, $okNotes, $abbrevBucket, $combineMachines, $filters);
    print $fmt;
  }elsif($cmd =~ /^(--gnuplot)$/){
    my $fmt = formatScores($format, $groupBuckets, $bestByBucketOnly, $okNotes, $abbrevBucket, $combineMachines, $filters);
    gnuplot $plotOptions, $fmt;
  }elsif($cmd =~ /^(--files)$/){
    my $scoresByFile = getScoresByFile();
    $scoresByFile = filterScores $scoresByFile, $filters;
    my @files = sort keys %$scoresByFile;
    for my $file(@files){
      my $fileInfo = $$scoresByFile{$file};
      my $fileFmt = formatFileInfo($fileInfo, $fileFormatPattern);
      print "$fileFmt\n";
    }
  }elsif($cmd =~ /^(--bestfiles)$/){
    my $bestScores = getBestScoresByBucket($filters);
    for my $bucketName(sort keys %$bestScores){
      my $fileInfo = $$bestScores{$bucketName};
      my $fileFmt = formatFileInfo($fileInfo, $fileFormatPattern);
      print "$fileFmt\n";
    }
  }
}

sub formatFileInfo($$){
  my ($fileInfo, $fileFormatPattern) = @_;

  my @okVars = sort keys %$fileInfo;

  my $fileFmt = $fileFormatPattern;
  for my $varName(@okFileFormatVars){
    $fileFmt =~ s/\%\{$varName\}/$$fileInfo{$varName}/g;
  }

  return $fileFmt;
}

sub parsePlotOptions($){
  my $opts = shift;
  my $plotOptions = {};
  while(@$opts > 0 and $$opts[0] =~ /^($okPlotOptionsRegex)$/){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptPlotOptionsRegex)$/){
      die getUsage("missing arg to $opt") if @$opts == 0;
      $arg = shift @$opts;
    }

    if($opt =~ /^(--file)$/){
      $$plotOptions{file} = $arg;
    }elsif($opt =~ /^(--size)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d+)[ ,x]+(\d+)$/;
      $$plotOptions{size} = "$1,$2";
    }elsif($opt =~ /^(--smooth)$/){
      $$plotOptions{smooth} = 1;
    }
  }
  return ($opts, $plotOptions);
}

sub parseFilterOptions($){
  my $opts = shift;
  my $filters = {};
  while(@$opts > 0){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptFiltersRegex)$/){
      die getUsage("missing arg to $opt") if @$opts == 0;
      $arg = shift @$opts;
    }

    if($opt =~ /^(--song)$/){
      die getUsage("missing arg to $opt") if not defined $arg;
      my $regex = "^$arg\$";
      $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
    }elsif($opt =~ /^(--hard)$/){
      $$filters{minfeet} = $HARD_SONG_FEET;
    }elsif($opt =~ /^(--nothard)$/){
      $$filters{maxfeet} = $HARD_SONG_FEET-1;
    }elsif($opt =~ /^(--feet)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d+)$/;
      $$filters{minfeet} = $1;
      $$filters{maxfeet} = $1;
    }elsif($opt =~ /^(--minfeet)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d+)$/;
      $$filters{minfeet} = $1;
    }elsif($opt =~ /^(--maxfeet)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d+)$/;
      $$filters{maxfeet} = $1;
    }elsif($opt =~ /^(--singles)$/){
      $$filters{game} = {singles => 1, doubles => 0, nonstop => 0, nonstopdoubles => 0};
    }elsif($opt =~ /^(--doubles)$/){
      $$filters{game} = {singles => 0, doubles => 1, nonstop => 0, nonstopdoubles => 0};
    }elsif($opt =~ /^(--nonstop)$/){
      $$filters{game} = {singles => 0, doubles => 0, nonstop => 1, nonstopdoubles => 0};
    }elsif($opt =~ /^(--nonstopdoubles)$/){
      $$filters{game} = {singles => 0, doubles => 0, nonstop => 0, nonstopdoubles => 1};
    }elsif($opt =~ /^--(beginner|basic|difficult|expert|challenge)$/){
      my $difficulty = $1;
      $$filters{difficulty} = {map {$_ => 0} @difficultyArgs};
      $$filters{difficulty}{$difficulty} = 1;
    }elsif($opt =~ /^(--sn2)$/){
      $$filters{machine} = {map {$_ => 0} @machineArgs};
      $$filters{machine}{sn2} = 1;
    }elsif($opt =~ /^(--2013)$/){
      $$filters{machine} = {map {$_ => 0} @machineArgs};
      $$filters{machine}{2013} = 1;
    }elsif($opt =~ /^(--x3)$/){
      $$filters{machine} = {map {$_ => 0} @machineArgs};
      $$filters{machine}{x3} = 1;
    }elsif($opt =~ /^(--a)$/){
      $$filters{machine} = {map {$_ => 0} @machineArgs};
      $$filters{machine}{a} = 1;
    }elsif($opt =~ /^(--sm)$/){
      $$filters{machine} = {map {$_ => 0} @machineArgs};
      $$filters{machine}{sm50pdp} = 1;
      $$filters{machine}{sm53pdp} = 1;
    }elsif($opt =~ /^(--machine)$/){
      $$filters{machine} = {map {$_ => 0} @machineArgs};
      my @okMachines = split /\s*,\s*/, $arg;
      for my $mach(@okMachines){
        if(not defined $$filters{machine}{$mach}){
          die getUsage("invalid $opt: $arg");
        }
        $$filters{machine}{$mach} = 1;
      }
    }elsif($opt =~ /^(--tw)$/){
      $$filters{timingWindows} = {map {$_ => 0} @timingWindowsArgs};
      my @okTWs = split /\s*,\s*/, $arg;
      for my $tw(@okTWs){
        if(not defined $$filters{timingWindows}{$tw}){
          die getUsage("invalid $opt: $arg");
        }
        $$filters{timingWindows}{$tw} = 1;
      }
    }elsif($opt =~ /^(--score|--minscore)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d+)$/;
      $$filters{minscore} = $1;
    }elsif($opt =~ /^(--maxscore)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d+)$/;
      $$filters{maxscore} = $1;
    }elsif($opt =~ /^(--mindate|--date)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d{8})$/;
      $$filters{mindate} = $1;
    }elsif($opt =~ /^(--monotonic|--increasing|--records)$/){
      $$filters{monotonic} = 1;
    }elsif($opt =~ /^(--recent|--sixmonths|--sixmos|--6mos)$/){
      eval {
        require DateTime;
        DateTime->import();
        1;
      } or die "--recent requires missing module DateTime\n";
      my $sixmos = DateTime->now->subtract(days=>180)->strftime('%Y%m%d');
      $$filters{mindate} = $sixmos;
    }elsif($opt =~ /^(--maxdate)$/){
      die getUsage("invalid $opt: $arg") if $arg !~ /^(\d{8})$/;
      $$filters{maxdate} = $1;
    }elsif($opt =~ /^(--dailybest)$/){
      $$filters{dailybest} = 1;
    }elsif($opt =~ /^(--bar)$/){
      $$filters{bar} = $yesbarFilter;
    }elsif($opt =~ /^(--nobar)$/){
      $$filters{bar} = $nobarFilter;
    }elsif($opt =~ /^(--diffbar)$/){
      $$filters{bar} = $diffbarFilter;
    }elsif($opt =~ /^(--samebar)$/){
      $$filters{bar} = $samebarFilter;
    }else{
      die getUsage("unknown filter: $opt");
    }
  }
  return $filters;
}

sub validateFile($){
  my ($file) = @_;

  die getUsage() if not defined $file;
  die "\n\n!!!\nmisnamed jpg/png file: $file\n" if $file !~ /^(.\/)?(IMG_)?(\d{8}_\d{3,}).*\.(jpg|png)$/;
  die "\n\n!!!\nfile not found: $file\n" if not -f $file;
}

sub validateInfo($){
  my ($info) = @_;

  die getUsage() if not defined $info;
  die "missing SONG\n" if not defined $$info{song};
  die "missing GAME\n" if not defined $$info{game};
  die "missing DIFFICULTY\n" if not defined $$info{difficulty};
  die "missing MACHINE\n" if not defined $$info{machine};
  die "missing TIMING_WINDOWS\n" if not defined $$info{timingWindows};
  die "missing SCORE\n" if not defined $$info{score};
  die "missing BAR\n" if not defined $$info{bar};
  die "missing STAGE\n" if not defined $$info{stage};
}

sub nameReminder($$){
  my ($file, $reminder) = @_;

  $file =~ s/^\.\///;

  if($file !~ /^(?:IMG_)?(\d{8}_\d{3,}).*\.(jpg|png)$/){
    die "\n\n!!!\nmisnamed jpg/png file: $file\n";
  }
  my ($prefix, $ext) = ($1, $2);
  $reminder =~ s/^$prefix//;
  $reminder =~ s/\.$ext$//;

  if($reminder !~ /^(reminder)_[a-zA-Z0-9_\-]*[a-zA-Z0-9]$/){
    die "invalid reminder: $reminder\n";
  }

  my $newFileName = "${prefix}_${reminder}.$ext";

  my @cmd = ("mv", $file, $newFileName);
  run @cmd;
}

sub nameFile($$$$){
  my ($file, $info, $buckets, $opts) = @_;

  validateFile($file);
  validateInfo($info);

  my $feet = $songFeetDifficulties{$$info{song}}{$$info{game}}{$$info{difficulty}};
  if(not defined $feet or $feet !~ /^\d+$/){
    if($$info{game} =~ /^(nonstop|nonstopdoubles)$/){
      $feet = 0;
    }else{
      warnMsg "NO FEET DIFFICULTY FOUND FOR: $file\n";
    }
  }
  $$info{feet} = $feet;

  bannerFlash $$info{song} if $$opts{bannerFlash};

  my $bucketName = getBucketName $info, 0, @DEFAULT_BUCKET_FIELDS;
  print "BUCKET: $bucketName\n";
  print "FEET: $$info{feet}\n";

  my $orient = undef;
  $orient = getImageOrientation $file if $$opts{checkOrientation};

  my $game = $$info{game};
  if(not defined $orient){
    warnMsg("unknown orientation") if $$opts{checkOrientation};
  }elsif($orient eq "landscape" and $game =~ /^(singles|nonstop)$/){
    warnMsg("image orientation is $orient, which is unusual for game=$game");
  }elsif($orient eq "portrait" and $game =~ /^(doubles|nonstopdoubles)$/){
    warnMsg("image orientation is $orient, which is unusual for game=$game");
  }

  my $isHardSong = $$info{feet} >= $HARD_SONG_FEET;

  if(not defined $$buckets{$bucketName}){
    warnMsg("no existing scores found for $bucketName");
    if($$info{bar} eq $avgbarArg){
      $$info{bar} = $isHardSong ? $yesbarArg : $nobarArg;
    }

    if($$info{bar} eq $nobarArg and $$info{feet} >= $HARD_SONG_FEET){
      warnMsg("$bucketName is new, has feet=$$info{feet} and '$nobarArg'");
    }elsif($$info{bar} eq $yesbarArg and $$info{feet} < $HARD_SONG_FEET){
      warnMsg("$bucketName is new, has feet=$$info{feet} and '$yesbarArg'");
    }
  }else{
    my $minScore = 0;
    my $maxScore = 0;
    for my $score(@{$$buckets{$bucketName}}){
      $minScore = $$score{score} if $$score{score} < $minScore;
      $maxScore = $$score{score} if $$score{score} > $maxScore;
    }
    if($$info{score} < $minScore){
      warnMsg("new LOW score $minScore => $$info{score}");
    }elsif($$info{score} > $maxScore){
      warnMsg("new HIGH score $maxScore => $$info{score}");
    }

    my $bucketBarCounts = getBucketBarCounts $buckets;
    my $yesbarCount = $$bucketBarCounts{$bucketName}{$yesbarArg};
    my $nobarCount = $$bucketBarCounts{$bucketName}{$nobarArg};
    if($$info{bar} eq $avgbarArg){
      if($yesbarCount > $nobarCount){
        $$info{bar} = $yesbarArg;
      }elsif($nobarCount > $yesbarCount){
        $$info{bar} = $nobarArg;
      }else{
        $$info{bar} = $isHardSong ? $yesbarArg : $nobarArg;
      }
    }

    if($$info{bar} eq $yesbarArg and $yesbarCount < $nobarCount){
      warnMsg("$bucketName is usually '$nobarArg'");
    }elsif($$info{bar} eq $nobarArg and $nobarCount < $yesbarCount){
      warnMsg("$bucketName is usually '$yesbarArg'");
    }
  }

  $file =~ s/^\.\///;

  if($file !~ /^(?:IMG_)?(\d{8}_\d{3,}).*\.(jpg|png)$/){
    die "\n\n!!!\nmisnamed jpg/png file: $file\n";
  }
  my ($prefix, $ext) = ($1, $2);

  delete $$info{game} if defined $$info{game} and $$info{game} eq $emptyGameArg;
  delete $$info{timingWindows} if defined $$info{timingWindows} and $$info{timingWindows} eq $emptyTimingWindowsArg;
  delete $$info{fc} if defined $$info{fc} and $$info{fc} eq $emptyFCArg;
  delete $$info{special} if defined $$info{special} and $$info{special} eq $emptySpecialArg;
  delete $$info{failed} if defined $$info{failed} and $$info{failed} eq $emptyFailedArg;

  my $newFileName = '';
  $newFileName .= "$prefix";
  $newFileName .= "_reminder_failed" if defined $$info{failed};
  $newFileName .= "_$$info{song}";
  $newFileName .= "_$$info{game}" if defined $$info{game};
  $newFileName .= "_$$info{difficulty}";
  $newFileName .= "_$$info{machine}";
  $newFileName .= "_$$info{timingWindows}" if defined $$info{timingWindows};
  $newFileName .= "_$$info{score}";
  $newFileName .= "_$$info{fc}" if defined $$info{fc};
  $newFileName .= "_$$info{special}" if defined $$info{special};
  $newFileName .= "_$$info{bar}";
  $newFileName .= "_$$info{stage}";
  $newFileName .= ".$ext";

  my @cmd = ("mv", $file, $newFileName);
  if($file eq $newFileName){
    print "SKIPPING: $file is unchanged\n";
  }else{
    run @cmd;
  }
}

sub editNames($$@){
  my ($editInfo, $opts, @imgFiles) = @_;

  my $infoByFile = {};
  for my $imgFile(@imgFiles){
    my $origInfo = parseScoreFile($imgFile);
    my $info = {%$origInfo, %$editInfo};
    $$infoByFile{$imgFile} = $info;
    validateFile $imgFile;
    validateInfo $info;
  }

  my $scoresByFile = getScoresByFile();
  my $scores = [values %$scoresByFile];
  my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);

  for my $imgFile(@imgFiles){
    nameFile $imgFile, $$infoByFile{$imgFile}, $buckets, $opts;
  }
}

sub parseOptsAndInfoArgs(@){
  my $opts = {
    bannerFlash => 1,
    checkOrientation => 1,
  };
  my $info = {};

  for my $arg(@_){
    if($arg =~ /^(--banner-flash)$/){
      $$opts{bannerFlash} = 1;
      next;
    }elsif($arg =~ /^(--no-banner-flash)$/){
      $$opts{bannerFlash} = 0;
      next;
    }elsif($arg =~ /^(--check-orientation)$/){
      $$opts{checkOrientation} = 1;
      next;
    }elsif($arg =~ /^(--no-check-orientation)$/){
      $$opts{checkOrientation} = 0;
      next;
    }elsif($arg =~ /^(--fast)$/){
      $$opts{bannerFlash} = 0;
      $$opts{checkOrientation} = 0;
      next;
    }

    my $infoAtt;
    my $value = $arg;
    if($arg =~ /^($okSongArgs)$/){
      $infoAtt = "song";
    }elsif($arg =~ /^($okGameArgs)$/){
      $infoAtt = "game";
    }elsif($arg =~ /^($okDifficultyArgs)$/){
      $infoAtt = "difficulty";
    }elsif($arg =~ /^($okMachineArgs)$/){
      $infoAtt = "machine";
    }elsif($arg =~ /^($okTimingWindowsArgs)$/){
      $infoAtt = "timingWindows";
    }elsif($arg =~ /^(\d,?){5,6}(\d)$/){
      warnMsg("score non-multiple-of-ten: $arg") if $2 != 0;
      my $score = $arg;
      $score =~ s/,//g;
      $score = int($score);
      $value = $score;
      if($value > 1000000){
        $infoAtt = undef;
      }else{
        $infoAtt = "score";
      }
    }elsif($arg =~ /^($okFCArgs)$/){
      $infoAtt = "fc";
    }elsif($arg =~ /^($okSpecialArgs)$/){
      $infoAtt = "special";
    }elsif($arg =~ /^($okBarArgs)$/){
      $infoAtt = "bar";
    }elsif($arg =~ /^($okStageArgs)$/){
      $infoAtt = "stage";
    }elsif($arg =~ /^($okFailedArgs)$/){
      $infoAtt = "failed";
    }else{
      $infoAtt = undef;
    }

    my $invalidArg = not defined $infoAtt;
    my $prevValue = defined $infoAtt ? $$info{$infoAtt} : undef;

    if($invalidArg){
      return undef;
    }elsif(defined $prevValue and $value ne $prevValue){
      warnMsg("att '$infoAtt' given twice differently: $value != $prevValue\n");
      return undef;
    }else{
      $$info{$infoAtt} = $value;
    }
  }

  return ($opts, $info);
}

sub getScoresByFile(){
  my @files = listScoreFiles();
  my $scoresByFile = { map {$_ => parseScoreFile $_} @files };
  return $scoresByFile;
}

sub listScoreFiles(){
  my @files = `cd $scoreDir && ls *.jpg *.png`;
  chomp foreach @files;
  @files = sort @files;
  @files = grep {$_ =~ /^\d+_.*\.(jpg|png)$/} @files;
  @files = grep {$_ !~ /_reminder_/} @files;
  return @files;
}

sub parseScoreFile($){
  my $file = shift;
  if($file !~ /^
    (?:\.\/)?
    (?<date>\d{8})
    _(?<index>\d+)
    (?:_(?<failed>reminder_failed))?
    _(?<song>$okSongArgs)
    (?:_(?<game>$okGameArgs))?
    _(?<difficulty>$okDifficultyArgs)
    _(?<machine>$okMachineArgs)
    (?:_(?<timingWindows>$okTimingWindowsArgs))?
    _(?<score>\d+)
    (?:_(?<fc>$okFCArgs))?
    (?:_(?<special>$okSpecialArgs))?
    _(?<bar>$okBarArgs)
    _(?<stage>$okStageArgs)
    \.(?:jpg|png)$/x){
    die "malformed file name: $file\n";
  }
  my $info = {
    file          => $file,
    date          => $+{date},
    index         => $+{index},
    failed        => $+{failed},
    song          => $+{song},
    game          => $+{game},
    difficulty    => $+{difficulty},
    machine       => $+{machine},
    timingWindows => $+{timingWindows},
    score         => $+{score},
    fc            => $+{fc},
    special       => $+{special},
    bar           => $+{bar},
    stage         => $+{stage},
  };

  $$info{game} = $emptyGameArg if not defined $$info{game} or $$info{game} eq "";
  $$info{timingWindows} = $emptyGameArg if not defined $$info{timingWindows} or $$info{timingWindows} eq "";
  $$info{fc} = $emptyFCArg if not defined $$info{fc} or $$info{fc} eq "";
  $$info{special} = $emptySpecialArg if not defined $$info{special} or $$info{special} eq "";
  $$info{failed} = $emptyFailedArg if not defined $$info{failed} or $$info{failed} eq "";

  my $feet = $songFeetDifficulties{$$info{song}}{$$info{game}}{$$info{difficulty}};
  if(not defined $feet or $feet !~ /^\d+$/){
    if($$info{game} =~ /^(nonstop|nonstopdoubles)$/){
      $feet = 0;
    }else{
      die "NO FEET DIFFICULTY FOUND FOR: $file\n";
    }
  }
  $$info{feet} = $feet;

  $$info{quality} = getQualityPoints($info);

  return $info;
}

sub getQualityPoints($){
  my $info = shift;

  my $scoreGrade;
  $scoreGrade = 1.00 if $$info{score} >= 995000 and not defined $scoreGrade;
  $scoreGrade = 0.95 if $$info{score} >= 990000 and not defined $scoreGrade;
  $scoreGrade = 0.80 if $$info{score} >= 950000 and not defined $scoreGrade;
  $scoreGrade = 0.60 if $$info{score} >= 900000 and not defined $scoreGrade;
  $scoreGrade = 0.30 if $$info{score} >= 800000 and not defined $scoreGrade;
  $scoreGrade = 0.10 if $$info{score} >= 700000 and not defined $scoreGrade;
  $scoreGrade = 0.05 if not defined $scoreGrade;

  my $feetGrade;
  $feetGrade = 1.50 if $$info{feet} >= 19 and not defined $feetGrade;
  $feetGrade = 1.07 if $$info{feet} >= 18 and not defined $feetGrade;
  $feetGrade = 0.90 if $$info{feet} >= 17 and not defined $feetGrade;
  $feetGrade = 0.70 if $$info{feet} >= 16 and not defined $feetGrade;
  $feetGrade = 0.40 if $$info{feet} >= 15 and not defined $feetGrade;
  $feetGrade = 0.30 if $$info{feet} >= 14 and not defined $feetGrade;
  $feetGrade = 0.20 if $$info{feet} >= 13 and not defined $feetGrade;
  $feetGrade = 0.15 if $$info{feet} >= 12 and not defined $feetGrade;
  $feetGrade = 0.05 if not defined $feetGrade;

  my $quality = 470*$scoreGrade + 530*$feetGrade;

  my $fc = $$info{fc};
  $fc = "" if not defined $fc;
  if($fc eq "mfc"){
    $quality += 500;
  }elsif($fc eq "pfc"){
    $quality += 150;
  }elsif($fc eq "fc"){
    $quality += 80;
  }elsif($fc eq "gfc"){
    $quality += 50;
  }

  if($$info{bar} eq $nobarArg){
    $quality += 100 * $feetGrade;
  }

  if($$info{stage} =~ /4extra/){
    $quality += 100 * $feetGrade;
  }

  return int($quality);
}

sub sortScores($){
  my $scores = shift;
  return [sort {
    $$a{date} <=> $$b{date}
    ||
    $$a{game} cmp $$b{game}
    ||
    $$a{song} cmp $$b{song}
    ||
    $$a{difficulty} cmp $$b{difficulty}
    ||
    $$a{file} cmp $$b{file}
  } @$scores];
}

sub getBucketName($$@){
  my ($score, $abbrevBucket, @bucketFields) = @_;
  my @bucketFieldVals;
  for my $bucketField(@bucketFields){
    my $val = $$score{$bucketField};
    if($abbrevBucket){
      if($bucketField eq "song"){
        $val = $songAbbrevs{$val};
      }elsif($bucketField eq "difficulty"){
        $val = $difficultyAbbrevs{$val};
      }elsif($bucketField eq "game"){
        if($val eq $emptyGameArg){
          $val = undef;
        }else{
          $val = $gameAbbrevs{$val};
        }
      }elsif($bucketField eq "machine"){
        if($val eq $defaultMachineArg){
          $val = undef;
        }
      }
    }
    push @bucketFieldVals, $val;
  }
  return join "-", grep {defined $_} @bucketFieldVals;
}

sub getScoreBuckets($$@){
  my ($scores, $abbrevBucket, @bucketFields) = @_;
  $scores = sortScores $scores;

  my $buckets = {};
  for my $score(@$scores){
    my $bucketName = getBucketName $score, $abbrevBucket, @bucketFields;
    $$buckets{$bucketName} = [] if not defined $$buckets{$bucketName};
    push @{$$buckets{$bucketName}}, $score;
  }
  return $buckets;
}

sub formatScoreLine($$$$$){
  my ($score, $isHighScore, $format, $okNotes, $bucketName) = @_;

  my @notes;
  if($$okNotes{'fc'} and defined $$score{fc} and $$score{fc} ne $emptyFCArg){
    push @notes, $$score{fc};
  }
  if($$okNotes{'special'} and defined $$score{special} and $$score{special} ne $emptySpecialArg){
    push @notes, $$score{special};
  }
  if($$okNotes{'highscore'} and $isHighScore){
    my $abbrev = $songAbbrevs{$$score{song}};
    push @notes, "$$score{score} $abbrev";
  }
  if($$okNotes{'nobar'} and $$score{bar} eq $nobarArg and $$score{feet} > $HARD_SONG_FEET){
    push @notes, $$score{bar};
  }
  if($$okNotes{'3rd'} and $$score{stage} eq "3rd" and $$score{feet} > $HARD_SONG_FEET){
    push @notes, $$score{stage};
  }

  my $note = join " ", @notes;

  my %replacements = map {$_ => $$score{$_}} sort keys %$score;
  $replacements{notes} = $note;
  $replacements{bucket} = $bucketName;

  my $scoreFmt = $format;
  for my $varName(sort keys %replacements){
    my $val = $replacements{$varName};
    $scoreFmt =~ s/\%\{$varName\}/$val/g;
  }
  $scoreFmt .= "\n";

  return $scoreFmt;
}

sub getBucketBarCounts($){
  my $buckets = shift;
  my $bucketBarCounts = {};
  for my $bucketName(keys %$buckets){
    my $bucketScores = $$buckets{$bucketName};
    my $barCount = 0;
    my $nobarCount = 0;
    for my $score(@$bucketScores){
      $barCount++ if $$score{bar} eq $yesbarArg;
      $nobarCount++ if $$score{bar} eq $nobarArg;
    }
    $$bucketBarCounts{$bucketName}{$yesbarArg} = $barCount;
    $$bucketBarCounts{$bucketName}{$nobarArg} = $nobarCount;
  }
  return $bucketBarCounts;
}

sub filterScores($$){
  my ($scoresByFile, $filters) = @_;
  $scoresByFile = {%$scoresByFile};

  my $origScoresByFile = {%$scoresByFile};

  for my $file(sort keys %$scoresByFile){
    my $s = $$scoresByFile{$file};
    my $ok = 1;
    if(defined $$filters{songs}){
      my $f = $$filters{songs};
      my $song = $$s{song};
      if(defined $$f{$song} and not $$f{$song}){
        $ok = 0;
      }
    }
    if(defined $$filters{minfeet}){
      my $f = $$filters{minfeet};
      my $feet = $$s{feet};
      if($feet < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxfeet}){
      my $f = $$filters{maxfeet};
      my $feet = $$s{feet};
      if($feet > $f){
        $ok = 0;
      }
    }
    if(defined $$filters{game}){
      my $f = $$filters{game};
      my $game = $$s{game};
      if(defined $$f{$game} and not $$f{$game}){
        $ok = 0;
      }
    }
    if(defined $$filters{difficulty}){
      my $f = $$filters{difficulty};
      my $difficulty = $$s{difficulty};
      if(defined $$f{$difficulty} and not $$f{$difficulty}){
        $ok = 0;
      }
    }
    if(defined $$filters{machine}){
      my $f = $$filters{machine};
      my $machine = $$s{machine};
      if(defined $$f{$machine} and not $$f{$machine}){
        $ok = 0;
      }
    }
    if(defined $$filters{timingWindows}){
      my $f = $$filters{timingWindows};
      my $tw = $$s{timingWindows};
      $tw = $emptyTimingWindowsArg if not defined $tw;
      if(defined $$f{$tw} and not $$f{$tw}){
        $ok = 0;
      }
    }
    if(defined $$filters{minscore}){
      my $f = $$filters{minscore};
      my $score = $$s{score};
      if($score < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxscore}){
      my $f = $$filters{maxscore};
      my $score = $$s{score};
      if($score > $f){
        $ok = 0;
      }
    }
    if(defined $$filters{mindate}){
      my $f = $$filters{mindate};
      my $date = $$s{date};
      if($date < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxdate}){
      my $f = $$filters{maxdate};
      my $date = $$s{date};
      if($date > $f){
        $ok = 0;
      }
    }
    delete $$scoresByFile{$file} if not $ok;
  }

  if($$filters{bar}){
    my $scores = [values %$origScoresByFile];
    my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);
    my $bucketBarCounts = getBucketBarCounts $buckets;
    for my $bucketName(sort keys %$buckets){
      my $bucketScores = $$buckets{$bucketName};
      my $barCount = $$bucketBarCounts{$bucketName}{$yesbarArg};
      my $nobarCount = $$bucketBarCounts{$bucketName}{$nobarArg};
      for my $score(@$bucketScores){
        my $bar = $$score{bar};
        my $sameCount = $bar eq $yesbarArg ? $barCount : $nobarCount;
        my $diffCount = $bar eq $yesbarArg ? $nobarCount : $barCount;
        if($$filters{bar} eq $yesbarFilter and $bar ne $yesbarArg){
          delete $$scoresByFile{$$score{file}};
        }elsif($$filters{bar} eq $nobarFilter and $bar ne $nobarArg){
          delete $$scoresByFile{$$score{file}};
        }elsif($$filters{bar} eq $samebarFilter and $sameCount < $diffCount){
          delete $$scoresByFile{$$score{file}};
        }elsif($$filters{bar} eq $diffbarFilter and $diffCount < $sameCount){
          delete $$scoresByFile{$$score{file}};
        }
      }
    }
  }

  if($$filters{monotonic}){
    my $scores = [values %$scoresByFile];
    my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);
    for my $bucketName(sort keys %$buckets){
      my $bucketScores = $$buckets{$bucketName};
      sortScores $bucketScores;
      my $curMaxScore = undef;
      for my $score(@$bucketScores){
        if(not defined $curMaxScore or $$score{score} > $curMaxScore){
          $curMaxScore = $$score{score};
        }else{
          delete $$scoresByFile{$$score{file}};
        }
      }
    }
  }

  if($$filters{dailybest}){
    my $scores = [values %$scoresByFile];
    my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);
    for my $bucketName(sort keys %$buckets){
      my $bucketScores = $$buckets{$bucketName};
      sortScores $bucketScores;
      my $scoresByDate = {};
      for my $score(@$bucketScores){
        my $date = $$score{date};
        $$scoresByDate{$date} = [] if not defined $$scoresByDate{$date};
        push @{$$scoresByDate{$date}}, $score;
      }
      for my $date(sort keys %$scoresByDate){
        my @scores = @{$$scoresByDate{$date}};
        @scores = sort {$$a{score} <=> $$b{score}} @scores;
        pop @scores;
        for my $score(@scores){
          delete $$scoresByFile{$$score{file}};
        }
      }
    }
  }

  return $scoresByFile;
}

sub getMtimesByFile($){
  my ($scoresByFile) = @_;
  my $mtimes = {};
  for my $file(keys %$scoresByFile){
    $$mtimes{$file} = mtime "$scoreDir/$file";
  }
  return $mtimes;
}

sub splitScoresIntoCourses($$){
  my ($scoresByFile, $mtimes) = @_;

  my @sortedScores = sort {
    $$mtimes{$a} <=> $$mtimes{$b}
    || $a cmp $b
  } keys %$scoresByFile;

  my $stageNums = {
    "1st" => 1,
    "2nd" => 2,
    "3rd" => 3,
    "4extra" => 4,
    "4nonstop" => 4,
  };

  my @courses;
  my $curCourse = undef;
  my $lastStageNum = undef;
  my $lastMtime = undef;
  for my $file(@sortedScores){
    my $score = $$scoresByFile{$file};
    my $mtime = $$mtimes{$file};
    my $stage = $$score{stage};
    my $stageNum = $$stageNums{$stage};
    die "invalid stage '$stage'\n" if not defined $stageNum;

    my $isNewCourse = 0;
    if(defined $lastStageNum && defined $lastMtime){
      die "mtimes out of order at $file\n" if $lastMtime > $mtime;
      my $stageNumDiff = $stageNum - $lastStageNum;
      my $mtimeDiff = $mtime - $lastMtime;

      if($mtimeDiff < $COURSE_MIN_STAGE_GAP_SECONDS){
        die "stage gap too small: $file\n";
      }

      my $maxMtimeDiff = $COURSE_MAX_STAGE_GAP_SECONDS*$stageNumDiff;

      if($stageNumDiff <= 0){
        $isNewCourse = 1;
      }elsif($mtimeDiff > $maxMtimeDiff){
        $isNewCourse = 1;
      }
    }

    if(not defined $curCourse or $isNewCourse){
      $curCourse = {
        scores => [],
        mtimeMin => undef,
        mtimeMax => undef,
        courseLen => 0,
        courseDateFmt => undef,
      };
      push @courses, $curCourse;
    }

    push @{$$curCourse{scores}}, $score;
    $$curCourse{courseLen} = $$curCourse{courseLen} + 1;
    if(not defined $$curCourse{courseDateFmt}){
      my $date = `date --date \@$mtime +%Y%m%d`;
      chomp $date;
      $$curCourse{courseDateFmt} = $date;
    }
    if(not defined $$curCourse{mtimeMin} or $mtime < $$curCourse{mtimeMin}){
      $$curCourse{mtimeMin} = $mtime;
    }
    if(not defined $$curCourse{mtimeMax} or $mtime > $$curCourse{mtimeMax}){
      $$curCourse{mtimeMax} = $mtime;
    }

    $lastStageNum = $stageNum;
    $lastMtime = $mtime;
  }

  return @courses;
}

sub splitCoursesIntoSessions(@){
  my (@courses) = @_;

  my @sessions;
  my $curSession = undef;
  for my $course(@courses){
    my $isNewSession = 0;
    if(not defined $curSession){
      $isNewSession = 1;
    }else{
      my $lastCourse = ${$$curSession{courses}}[-1];
      my $courseGap = $$course{mtimeMin} - $$lastCourse{mtimeMax};

      if($courseGap > $SESSION_MAX_COURSE_GAP_SECONDS){
        $isNewSession = 1;
      }else{
        $isNewSession = 0;
      }
    }

    if($isNewSession){
      $curSession = {
        allScores => [],
        courses => [],
        mtimeMin => undef,
        mtimeMax => undef,
        sessionScoreLen => 0,
        sessionCourseLen => 0,
        sessionDateFmt => undef,
      };
      push @sessions, $curSession;
    }

    my $courseMtimeMin = $$course{mtimeMin};
    my $courseMtimeMax = $$course{mtimeMax};

    push @{$$curSession{courses}}, $course;
    push @{$$curSession{allScores}}, $_ foreach @{$$course{scores}};
    $$curSession{sessionCourseLen} = $$curSession{sessionCourseLen} + 1;
    $$curSession{sessionScoreLen} = $$curSession{sessionScoreLen} + $$course{courseLen};
    if(not defined $$curSession{sessionDateFmt}){
      $$curSession{sessionDateFmt} = $$course{courseDateFmt};
    }
    if(not defined $$curSession{mtimeMin} or $courseMtimeMin < $$curSession{mtimeMin}){
      $$curSession{mtimeMin} = $courseMtimeMin;
    }
    if(not defined $$curSession{mtimeMax} or $courseMtimeMax > $$curSession{mtimeMax}){
      $$curSession{mtimeMax} = $courseMtimeMax;
    }
  }

  return @sessions;
}

sub formatScores($$$$$$$){
  my ($format, $groupBuckets, $bestByBucketOnly,
      $okNotes, $abbrevBucket, $combineMachines, $filters) = @_;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my @bucketFields = @DEFAULT_BUCKET_FIELDS;

  if($combineMachines){
    @bucketFields = grep {$_ !~ /machine/} @bucketFields;
  }

  my $scores = [values %$scoresByFile];
  my $buckets = getScoreBuckets($scores, $abbrevBucket, @bucketFields);

  my $fmt = "";
  my $isFirstBucket = 1;
  for my $bucketName(sort keys %$buckets){
    my $bucketScores = $$buckets{$bucketName};
    $bucketScores = sortScores $bucketScores;
    my $bestScore = getBestScore($bucketScores);
    if($bestByBucketOnly){
      $bucketScores = [$bestScore];
    }
    if($groupBuckets){
      $fmt .= "\n\n" unless $isFirstBucket;
      $fmt .= "\"$bucketName\"\n";
    }
    for my $score(@$bucketScores){
      my $isHighScore = $$score{score} >= $$bestScore{score} ? 1 : 0;
      $fmt .= formatScoreLine($score, $isHighScore, $format, $okNotes, $bucketName);
    }
    $isFirstBucket = 0;
  }
  return $fmt;
}

sub getBestScore($){
  my ($scores) = @_;
  my $maxScore;
  for my $score(@$scores){
    if(not defined $maxScore or $$score{score} > $$maxScore{score}){
      $maxScore = $score;
    }
  }
  return $maxScore;
}

sub getBestScoresByBucket($){
  my ($filters) = @_;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my $scores = [values %$scoresByFile];
  my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);

  my $bestScores = {};
  for my $bucketName(sort keys %$buckets){
    my $bucketScores = $$buckets{$bucketName};
    $$bestScores{$bucketName} = getBestScore($bucketScores);
  }

  return $bestScores;
}

sub gnuplot($$){
  my ($plotOptions, $data) = @_;
  my $dataFile = "/tmp/ddrname-gnuplot-data";
  my $scriptFile = "/tmp/ddrname-gnuplot-script";

  my $outputFile = "/tmp/ddrname-gnuplot-output.png";
  $outputFile = $$plotOptions{file} if defined $$plotOptions{file};

  my $pngSize = $gnuplotDefaultPngSize;
  $pngSize = $$plotOptions{size} if defined $$plotOptions{size};

  my @segments = split /\n\n/, $data;
  my $segmentCount = @segments;
  my $lastBucket = $segmentCount - 1;

  my $script = "";
  $script .= "set xdata time\n";
  $script .= "set timefmt \"\%Y\%m\%d\"\n";
  $script .= "set datafile separator \",\"\n";
  $script .= "set key autotitle columnheader horizontal\n";
  $script .= "set grid noytics mxtics linewidth 4 , linewidth 2\n";

  $script .= "set term pngcairo size $pngSize\n";
  $script .= "set output \"$outputFile\"\n";

  my $linePlot = ""
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2"
    . " with linespoints"
    ;
  my $smoothPlot = ""
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2"
    . " smooth bezier"
    ;
  my $notesPlot = ""
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2:3"
    . " with labels offset 0,-1"
    . " notitle"
    ;

  my @plots = $$plotOptions{smooth} ? ($smoothPlot, $notesPlot) : ($linePlot, $notesPlot);

  if(@segments > 0){
    $script .= "plot " . join(", ", @plots) . "\n";
  }else{
    my $now = time;
    my $nowFmt = `date --date \@$now +%Y%m%d`;
    chomp $nowFmt;

    my $yday = $now - 24*60*60;
    my $ydayFmt = `date --date \@$yday +%Y%m%d`;
    chomp $ydayFmt;

    my $emptyPlot = ""
      . "set yrange [900000:999000]\n"
      . "set xrange [\"$ydayFmt\":\"$nowFmt\"]\n"
      . "set xlabel \"no scores found\"\n"
      . "set ylabel \"no scores found\"\n"
      . "plot 1/0\n";
    $script .= $emptyPlot;
  }

  open FH, "> $dataFile" or die "Could not write $dataFile\n";
  print FH $data;
  close FH;
  open FH, "> $scriptFile" or die "Could not write $scriptFile\n";
  print FH $script;
  close FH;

  run "gnuplot", "-p", $scriptFile;
  die "error runnning gnuplot script:\n===\n$script===\n" if $? != 0;
}

sub combine(@){
  return ([]) if @_ == 0;
  my $e = shift;
  my @c;
  my @rest = combine @_;
  for my $list(@rest){
    push @c, [$e, @$list];
    push @c, [@$list];
  }
  return @c;
}

sub mtime($){
  my $path = shift;
  die "not a file or directory: $path\n" if not -e $path;
  my @stat = stat $path;
  return $stat[9];
}

sub getImageOrientation($){
  my $file = shift;
  die "not a file: $file\n" if not -f $file;
  my ($width, $height, $orient);

  open FH, "-|", $EXIFTOOL_EXEC, "-ImageWidth", "-ImageHeight", "-Orientation", $file;
  while(my $line = <FH>){
    $width = $1 if $line =~ /^Image Width\s*:\s*(\d+)$/;
    $height = $1 if $line =~ /^Image Height\s*:\s*(\d+)$/;
    $orient = $1 if $line =~ /^Orientation\s*:\s*(.*)$/;
  }
  close FH;

  if(not defined $height or not defined $width){
    my $pix = `$PIX_EXEC $file 2>/dev/null`;
    if($pix =~ /^(\d+)x(\d+)$/){
      ($height, $width) = ($1, $2);
    }
  }

  if(defined $orient and $orient =~ /Rotate.*90|Rotate.*270/){
    ($width, $height) = ($height, $width);
  }

  if(not defined $height or not defined $width){
    return undef;
  }elsif($height > $width){
    return "portrait";
  }else{
    return "landscape";
  }
}

sub parseFeetDifficulties(@){
  my @feetArr = @_;
  if(@feetArr != 9){
    die "ERROR: invalid feet list (should be 9 entries): @feetArr\n";
  }

  my @parsedFeetArr;
  for my $feet(@feetArr){
    if($feet =~ /^-+$/){
      push @parsedFeetArr, "-";
    }elsif($feet =~ /^\d+$/){
      push @parsedFeetArr, 0+$feet;
    }else{
      die "ERROR: could not parse feet \"$feet\"\n";
    }
  }

  my $i=0;

  return {
    singles => {
      beginner  => $parsedFeetArr[$i++],
      basic     => $parsedFeetArr[$i++],
      difficult => $parsedFeetArr[$i++],
      expert    => $parsedFeetArr[$i++],
      challenge => $parsedFeetArr[$i++],
    },
    doubles => {
      basic     => $parsedFeetArr[$i++],
      difficult => $parsedFeetArr[$i++],
      expert    => $parsedFeetArr[$i++],
      challenge => $parsedFeetArr[$i++],
    },
  };
}

sub checkUnique(@){
  my %uniqCI;
  my %uniqCS;
  for my $s(@_){
    if(defined $uniqCI{lc $s}){
      if(not defined $uniqCS{$s}){
        die "FATAL: case-insensitive duplicate allowed arg: $s\n";
      }else{
        die "FATAL: duplicate allowed arg: $s\n";
      }
    }
    $uniqCI{lc $s} = 1;
    $uniqCS{$s} = 1;
  }
}

sub bannerFlash($){
  my ($song) = @_;
  my @banners = `zenius-ddrsonglist --banners '$song' 2>/dev/null`;
  chomp foreach @banners;
  if(@banners == 0){
    print "no banners found for $song\n";
  }else{
    run "image-flash @banners >/dev/null 2>/dev/null &";
  }
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  if(@words == 0){
    my @imgFiles = `ls *.jpg *.png 2>/dev/null`;
    chomp foreach @imgFiles;
    @imgFiles = sort @imgFiles;
    return ("--fehterm", "--banners", "--orientation", "--datestats", "--coursestats",
      "--print", "--gnuplot", "--files", "--bestfiles", "--edit-names",
      @imgFiles);
  }

  if($words[0] =~ /^(--banners)$/ and @words == 1){
    return @songArgs;
  }

  if($words[0] =~ /^(--print|--gnuplot|--files|--bestfiles|--datestats|--coursestats|--orientation)$/){
    my $cmd = shift @words;
    my @complete;
    my $lastWord = $words[-1] if @words > 0;
    $lastWord = "" if not defined $lastWord;

    if($cmd =~ /^(--print|--gnuplot|--files|--bestfiles|--datestats|--coursestats|--orientation)$/){
      if($lastWord =~ /^(--song)$/){
        return @songArgs;
      }elsif($lastWord =~ /^($argOptFiltersRegex)$/){
        return ();
      }
    }

    if($cmd =~ /^(--print|--gnuplot)$/){
      if($lastWord =~ /^(--notes)$/){
        my @combinations = combine sort keys %$defaultNotes;
        my @csv = sort map {join ",", @$_} @combinations;
        return sort @csv;
      }elsif($lastWord =~ /^($argOptFormatOptSongsRegex)$/){
        return ();
      }
    }

    if($cmd =~ /^(--gnuplot)$/){
      while(@words > 0 and $words[0] =~ /^($okPlotOptionsRegex)$/){
        my $opt = shift @words;
        if(@words == 0 and $opt =~ /^($argOptPlotOptionsRegex)$/){
          return ();
        }
        shift @words if $opt =~ /^($argOptPlotOptionsRegex)$/;
      }
      if(@words == 0){
        @complete = (@okPlotOptions, @complete);
      }
    }
    if($cmd =~ /^(--print|--gnuplot)/){
      @complete = (@okFormatOptSongs, @complete) if @words == 0;
    }
    if($cmd =~ /^(--files|--bestfiles)$/){
      @complete = ("--format", @complete) if @words == 0;
    }
    if($cmd =~ /^(--datestats)/){
      my @args = @words;
      while(@args > 0 and $args[0] =~ /^($okFormatOptDatesRegex)$/){
        my $opt = shift @args;
        if(@args == 0 and $opt =~ /^($argOptFormatOptDatesRegex)$/){
          return ();
        }
        shift @args if $opt =~ /^($argOptFormatOptDatesRegex)$/;
      }
      @complete = (@okFormatOptDates, @complete) if @args == 0;
    }
    if($cmd =~ /^(--coursestats)/){
      my @args = @words;
      while(@args > 0 and $args[0] =~ /^($okFormatOptCoursesRegex)$/){
        my $opt = shift @args;
        if(@args == 0 and $opt =~ /^($argOptFormatOptCoursesRegex)$/){
          if(defined $opt and $opt =~ /^(--minlen)$/){
            return ("1", "2", "3");
          }else{
            return ();
          }
        }
        shift @args if $opt =~ /^($argOptFormatOptCoursesRegex)$/;
      }
      @complete = ("--minlen", @complete) if @args == 0;
    }
    @complete = (@okFilters, @complete);
    return @complete;
  }

  my $editNames = 0;
  if($words[0] =~ /^(--edit-names)$/){
    $editNames = 1;
  }

  shift @words;

  my ($opts, $info) = parseOptsAndInfoArgs @words;
  if(not defined $info){
    return ();
  }

  my @complete;
  @complete = (@songArgs, @complete) if not defined $$info{song};
  #@complete = (@gameArgs, @complete) if not defined $$info{game};
  @complete = (@difficultyArgs, @complete) if not defined $$info{difficulty};
  #@complete = (@machineArgs, @complete) if not defined $$info{machine};
  #@complete = (@timingWindowsArgs, @complete) if not defined $$info{timingWindows};
  #@complete = (@fcArgs, @complete) if not defined $$info{fc};
  #@complete = (@specialArgs, @complete) if not defined $$info{special};
  @complete = (@barArgs, @complete) if not defined $$info{bar};
  @complete = (@stageArgs, @complete) if not defined $$info{stage};
  #@complete = (@failedArgs, @complete) if not defined $$info{failed};

  if($editNames){
    my @imgFiles = `ls *.jpg *.png 2>/dev/null`;
    chomp foreach @imgFiles;
    @imgFiles = sort @imgFiles;
    @complete = (@imgFiles, @complete);
  }

  @complete = ("reminder_", "reminder_closeup_", @complete) if @words == 0 and not $editNames;

  return @complete;
}

sub warnMsg($){
  my $msg = shift;
  print STDERR "\n\nWARN: $msg\n";
}

sub run(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
