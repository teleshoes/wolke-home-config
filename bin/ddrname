#!/usr/bin/perl
use strict;
use warnings;
use DateTime;

my $scoreDir = "$ENV{HOME}/Desktop/DCIM/xddr";

my @hardSongs = qw(
  arrabbiata
  chaos
  healingdvision
  legendofmax
  max300
  max300smmm
  max300xspecial
  maxxunlimited
  paranoiarespect
  paranoiasurvivor270
  xepher
);
my $okHardSongs = join '|', @hardSongs;

my @otherSongs = qw(
  321stars
  astupidbarber
  blindjustice
  doll
  dropout
  dynamiteraveairspecial
  exoticethnic
  flowers
  healingvisionangelic
  mugen
  mysummerlove
  no13
  orioneuro
  paranoiaeternalstm200
  paranoiaevolution200
  sanamollete
);
my $okOtherSongs = join '|', @otherSongs;

my @songArgs = sort {$a cmp $b} (@hardSongs, @otherSongs);
my $okSongArgs = join '|', @songArgs;

my @gameArgs = qw(doubles);
my $okGameArgs = join '|', @gameArgs;

my @difficultyArgs = qw(beginner basic difficult expert challenge);
my $okDifficultyArgs = join '|', @difficultyArgs;

my @roundArgs = qw(1st 2nd 3rd);
my $okRoundArgs = join '|', @roundArgs;

my @barArgs = qw(bar nobar);
my $okBarArgs = join '|', @barArgs;

my @extraArgs = qw(fc pfc);
my $okExtraArgs = join '|', @extraArgs;

my $usage = "Usage:
  $0 --print [FILTER FILTER ..]
    parse filenames of score pictures in $scoreDir
      and print the result

    each successive FILTER can only remove scores
    specifying the same FILTER twice is legal, but useless
    some FILTERs override others as indicated, so specifying both is useless

    FILTER: SONG
      --song=REGEX
        include only scores where the whole SONG string matches REGEX
        {overrides --hard and --nothard}
      --hard
        include only scores where SONG is a HARD_SONG
        {overrides --nothard and --song}
      --nothard
        include only scores where SONG is not a HARD_SONG
        {overrides --song and --hard}

    FILTER: GAME
      --singles
        include only scores where GAME is NOT doubles
        {overrides --doubles}
      --doubles
        include only scores where GAME is doubles
        {overrides --singles}

    FILTER: SCORE
      --score=N, --minscore=N
        include only scores where SCORE >= N
      --maxscore=N
        include only scores where SCORE <= N

    FILTER: DATE
      --date=YYYYMMDD, --mindate=YYYYMMDD
        include only scores where DATE >= YYYYMMDD
        {overrides --recent}
      --maxdate=YYYYMMDD
        include only scores where DATE <= YYYYMMDD
      --recent, --sixmos, --sixmonths, --6mos
        same as --mindate=N, where N is the date 180 days ago
        {overrides --date}

    scores are grouped into sections by '\"<SONG>-<GAME>-<DIFFICULTY>\"'
    '<GAME>-' is omitted if GAME is not set
    each section starts with the name, and then contains the scores,
      one per line, formatted '<date>,<score>,<notes>'
    sections are separated by two newlines
    <notes> are space-separated list of:
      EXTRA   if one of [$okExtraArgs] is present in the filename
      nobar   if SONG is a HARD_SONG
      3rd     if SONG is a HARD_SONG

      e.g.: \"max300-doubles-expert\"
            20140331,723150,
            20140401,990000,pfc nobar
            20140402,684120,nobar
            20140403,784120,fc


            \"paranoiarespect-expert\"
            20140331,723150,

  $0 --gnuplot [FILTER FILTER ..]
    format songs as above and write to a tmp file
    write a gnuplot script and run it in gnuplot

  $0 JPG_FILE [ARG ARG ..]

  rename a jpeg file using a consistent format
  \"########_###_SONG_GAME_DIFFICULTY_SCORE_EXTRA_BAR_ROUND.jpg\"
  ######## is presumably a date in YYYYMMDD and ### is the camera pic index

     JPG_FILE
       jpeg file to rename
       must start with '########_###' and end with '.jpg'

     ARG
       one of [SONG|GAME|DIFFICULTY|SCORE|ROUND|BAR|EXTRA]
       exactly one SONG, DIFFICULTY, SCORE, ROUND, and BAR must be given
       exactly zero or one GAME args can be given
       exactly zero or one EXTRA args can be given

     SONG
       one of <HARD_SONG> or <OTHER_SONG>

     HARD_SONG
       one of [$okHardSongs]

     OTHER_SONG
       one of [$okOtherSongs]

     GAME
       one of [$okGameArgs]

     DIFFICULTY
       one of [$okDifficultyArgs]

     SCORE
       an integer between 100,000 and 1,000,000
       must be a multiple of 10
       commas, if present, are stripped out

     EXTRA
       one of [$okExtraArgs]

     BAR
       one of [$okBarArgs]

     ROUND
       one of [$okRoundArgs]

  $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline
";

sub parseArgs(@);
sub getScoreFiles();
sub parseScoreFiles(@);
sub getScoreBuckets($@);
sub formatBucketCsv($);
sub formatScores($);
sub gnuplot($);
sub bashComplete($$);

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print join ' ', bashComplete($_[1], $_[2]);
    exit 0;
  }

  if(@_ >= 1 and $_[0] =~ /^(--print|--gnuplot)$/){
    my $cmd = shift;
    my $filters = {};
    while(@_ > 0){
      my $arg = shift;
      if($arg =~ /^--song=(.*)$/){
        my $regex = "^$1\$";
        $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
      }elsif($arg =~ /^(--hard)$/){
        my $regex = "($okHardSongs)";
        $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
      }elsif($arg =~ /^(--nothard)$/){
        my $regex = "($okOtherSongs)";
        $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
      }elsif($arg =~ /^(--singles)$/){
        $$filters{game} = {doubles => 0, "" => 1};
      }elsif($arg =~ /^(--doubles)$/){
        $$filters{game} = {doubles => 1, "" => 0};
      }elsif($arg =~ /^(?:--score|--minscore)=(\d+)$/){
        $$filters{minscore} = $1;
      }elsif($arg =~ /^(?:--score|--maxscore)=(\d+)$/){
        $$filters{maxscore} = $1;
      }elsif($arg =~ /^(?:--mindate|--date)=(\d{8})$/){
        $$filters{mindate} = $1;
      }elsif($arg =~ /^(?:--recent|--sixmonths|--sixmos|--6mos)$/){
        my $sixmos = DateTime->now->subtract(days=>180)->strftime('%Y%m%d');
        $$filters{mindate} = $sixmos;
      }elsif($arg =~ /^--maxdate=(\d{8})$/){
        $$filters{maxdate} = $1;
      }else{
        die "$usage\nunknown filter: $arg\n";
      }
    }
    my $fmt = formatScores($filters);
    if($cmd =~ /^(--print)$/){
      print $fmt;
    }elsif($cmd =~ /^(--gnuplot)$/){
      gnuplot $fmt;
    }
    exit 0;
  }

  my $file = shift;
  my $info = parseArgs @_;
  die $usage if not defined $file or not -f $file or not defined $info;
  die "missing SONG\n" if not defined $$info{song};
  die "missing DIFFICULTY\n" if not defined $$info{difficulty};
  die "missing SCORE\n" if not defined $$info{score};
  die "missing BAR\n" if not defined $$info{bar};
  die "missing ROUND\n" if not defined $$info{round};

  $file =~ s/^\.\///;

  if($file !~ /^(\d{8}_\d{3}).*\.jpg$/){
    die "misnamed jpg file: $file\n";
  }
  my $prefix = $1;

  my $newFileName = '';
  $newFileName .= "$prefix";
  $newFileName .= "_$$info{song}";
  $newFileName .= "_$$info{game}" if defined $$info{game};
  $newFileName .= "_$$info{difficulty}";
  $newFileName .= "_$$info{score}";
  $newFileName .= "_$$info{extra}" if defined $$info{extra};
  $newFileName .= "_$$info{bar}";
  $newFileName .= "_$$info{round}";
  $newFileName .= ".jpg";

  my @cmd = ("mv", $file, $newFileName);
  print "@cmd\n";
  system @cmd;
}

sub parseArgs(@){
  my $info = {};
  for my $arg(@_){
    if($arg =~ /^($okSongArgs)$/){
      return undef if defined $$info{song};
      $$info{song} = $arg;
    }elsif($arg =~ /^($okGameArgs)$/){
      return undef if defined $$info{game};
      $$info{game} = $arg;
    }elsif($arg =~ /^($okDifficultyArgs)$/){
      return undef if defined $$info{difficulty};
      $$info{difficulty} = $arg;
    }elsif($arg =~ /^(\d,?){5,6}0$/){
      my $score = $arg;
      $score =~ s/,//g;
      $score = int($score);
      return undef if defined $$info{score} or $score > 1000000;
      $$info{score} = $score;
    }elsif($arg =~ /^($okExtraArgs)$/){
      return undef if defined $$info{extra};
      $$info{extra} = $arg;
    }elsif($arg =~ /^($okBarArgs)$/){
      return undef if defined $$info{bar};
      $$info{bar} = $arg;
    }elsif($arg =~ /^($okRoundArgs)$/){
      return undef if defined $$info{round};
      $$info{round} = $arg;
    }else{
      return undef;
    }
  }
  return $info;
}

sub getScoreFiles(){
  my @files = `cd $scoreDir && ls *.jpg`;
  chomp foreach @files;
  @files = grep {$_ =~ /^\d+_.*\.jpg$/ and $_ !~ /_reminder_/} @files;
  return @files;
}

sub parseScoreFiles(@){
  my @files = @_;
  my $scores = {};
  for my $file(@files){
    if($file !~ /^
      (\d{8})
      _(\d+)
      _($okSongArgs)
      (?:_($okGameArgs))?
      _($okDifficultyArgs)
      _(\d+)
      (?:_($okExtraArgs))?
      _($okBarArgs)
      _($okRoundArgs)
      \.jpg$/x){
      die "malformed file name: $file\n";
    }
    $$scores{$file} = {
      file       => $file,
      date       => $1,
      index      => $2,
      song       => $3,
      game       => $4,
      difficulty => $5,
      score      => $6,
      extra      => $7,
      bar        => $8,
      round      => $9,
    };
  }
  return $scores;
}

sub getScoreBuckets($@){
  my ($scores, @bucketFields) = @_;
  my $buckets = {};
  for my $file(keys %$scores){
    my $s = $$scores{$file};
    my @bucketFieldVals = map {$$s{$_}} @bucketFields;

    my $bucketName = join "-", grep {defined $_} @bucketFieldVals;
    $$buckets{$bucketName} = [] if not defined $$buckets{$bucketName};
    push @{$$buckets{$bucketName}}, $s;
  }
  return $buckets;
}

sub formatBucketCsv($){
  my ($bucket) = @_;

  my %isHardSong = map {$_ => 1} @hardSongs;

  my $fmt = "";
  for my $s(sort @$bucket){
    my @notes;
    push @notes, $$s{extra} if defined $$s{extra};
    push @notes, $$s{bar} if $$s{bar} eq "nobar" and $isHardSong{$$s{song}};
    push @notes, $$s{round} if $$s{round} eq "3rd" and $isHardSong{$$s{song}};
    my $note = join " ", @notes;
    $fmt .= "$$s{date},$$s{score},$note\n";
  }

  return $fmt;
}

sub formatScores($){
  my $filters = shift;

  my @scoreFiles = getScoreFiles();
  my $scores = parseScoreFiles(@scoreFiles);

  for my $file(sort keys %$scores){
    my $s = $$scores{$file};
    my $ok = 1;
    if(defined $$filters{songs}){
      my $f = $$filters{songs};
      my $song = $$s{song};
      if(defined $$f{$song} and not $$f{$song}){
        $ok = 0;
      }
    }
    if(defined $$filters{game}){
      my $f = $$filters{game};
      my $game = $$s{game};
      $game = "" if not defined $game;
      if(defined $$f{$game} and not $$f{$game}){
        $ok = 0;
      }
    }
    if(defined $$filters{minscore}){
      my $f = $$filters{minscore};
      my $score = $$s{score};
      if($score < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxscore}){
      my $f = $$filters{maxscore};
      my $score = $$s{score};
      if($score > $f){
        $ok = 0;
      }
    }
    if(defined $$filters{mindate}){
      my $f = $$filters{mindate};
      my $date = $$s{date};
      if($date < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxdate}){
      my $f = $$filters{maxdate};
      my $date = $$s{date};
      if($date > $f){
        $ok = 0;
      }
    }
    delete $$scores{$file} if not $ok;
  }

  my $buckets = getScoreBuckets($scores, qw(song game difficulty));

  my $fmt = "";
  for my $bucketName(sort keys %$buckets){
    my $bucket = $$buckets{$bucketName};
    $fmt .= "\n\n" unless $fmt eq "";
    $fmt .= "\"$bucketName\"\n";
    $fmt .= formatBucketCsv $bucket;
  }
  return $fmt;
}

sub gnuplot($){
  my $data = shift;
  my $dataFile = "/tmp/ddrname-gnuplot-data";
  my $scriptFile = "/tmp/ddrname-gnuplot-script";
  my $outputFile = "/tmp/ddrname-gnuplot-output.png";

  my $segmentCount = split /\n\n/, $data;
  my $lastBucket = $segmentCount - 1;

  my $script = "";
  $script .= "set xdata time\n";
  $script .= "set timefmt \"\%Y\%m\%d\"\n";
  $script .= "set datafile separator \",\"\n";

  $script .= "set term pngcairo size 1920,1080\n";
  $script .= "set output \"$outputFile\"\n";
  $script .= "plot"
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2"
    . " with linespoints"
    . " title columnheader(1)"
    . "\n"
    ;

  open FH, "> $dataFile" or die "Could not write $dataFile\n";
  print FH $data;
  close FH;
  open FH, "> $scriptFile" or die "Could not write $scriptFile\n";
  print FH $script;
  close FH;

  system "gnuplot", "-p", $scriptFile;
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  if(@words == 0){
    my @jpgFiles = `ls *.jpg 2>/dev/null`;
    chomp foreach @jpgFiles;
    return ("--print", @jpgFiles);
  }
  shift @words;

  my $info = parseArgs @words;
  if(not defined $info){
    return ();
  }

  my @complete;
  @complete = (@songArgs, @complete) if not defined $$info{song};
  #@complete = (@gameArgs, @complete) if not defined $$info{game};
  @complete = (@difficultyArgs, @complete) if not defined $$info{difficulty};
  #@complete = (@extraArgs, @complete) if not defined $$info{extra};
  @complete = (@barArgs, @complete) if not defined $$info{bar};
  @complete = (@roundArgs, @complete) if not defined $$info{round};

  return @complete;
}

&main(@ARGV);
