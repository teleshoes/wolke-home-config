#!/usr/bin/python3
import aiohttp
import argparse
import asyncio
import logging
import os
import re
import subprocess
import sys
from pathlib import Path

### suppress slimxpp warning:
###   Using slower stringprep, consider compiling the faster cython/libidn one.
from contextlib import redirect_stderr, suppress
with redirect_stderr(None), suppress(ModuleNotFoundError):
  import slixmpp
###

from gehomesdk import (
    EVENT_APPLIANCE_INITIAL_UPDATE,
    ErdAcOperationMode,
    ErdAcFanSetting,
    ErdCode,
    ErdOnOff,
    GeAppliance,
    GeWebsocketClient,
)

TOKEN_CACHE_DIR = str(Path.home()) + "/.cache/gehomesdk-tokens/"
SECRETS_FILE = str(Path.home()) + "/.secrets"
CONFIG_FILE = str(Path.home()) + "/.config/gehomesdk.config"

COMMAND_GET = 'get'
COMMAND_SET_POWER = 'set-power'
COMMAND_SET_MODE = 'set-mode'
COMMAND_SET_TEMP = 'set-temp'
COMMAND_SET_FAN = 'set-fan'

POWER_ON = "on"
POWER_OFF = "off"
POWER_TOGGLE = "toggle"


async def main():
  parser = argparse.ArgumentParser()

  parser.add_argument("--username", type=str,
                      help=("SmartHQ account username\n"
                              + "(smarthq.username in secrets, or SMARTHQ_USERNAME env var)"))
  parser.add_argument("--password", type=str,
                      help=("SmartHQ account password\n"
                              + "(smarthq.password in secrets, or SMARTHQ_PASSWORD env var)"))
  parser.add_argument("--region", type=str,
                      help=("SmartHQ region (US or EU, defaults to US)\n"
                              + "(smarthq.region in secrets, or SMARTHQ_REGION env var)"))

  args = parser.parse_args()

  username = args.username
  if username == None:
    username = os.environ.get("SMARTHQ_USERNAME")
  if username == None:
    username = readProc(["gpg-conf-read", SECRETS_FILE, "--key=smarthq.username"])

  password = args.password
  if password == None:
    password = os.environ.get("SMARTHQ_PASSWORD")
  if password == None:
    password = readProc(["gpg-conf-read", SECRETS_FILE, "--key=smarthq.password"])

  region = args.region
  if region == None:
    region = os.environ.get("SMARTHQ_REGION")
  if region == None:
    region = readProc(["gpg-conf-read", SECRETS_FILE, "--key=smarthq.region"])
  if region == None:
    region = "US"

  if username == None or password == None or username == "" or password == "":
    die(parser.format_help() + "\nERROR: missing username and/or password\n")

  targetDeviceName = "bed1"

  commands = [
    {"name": COMMAND_GET, "val": None},
    {"name": COMMAND_SET_TEMP, "val": 72},
    {"name": COMMAND_SET_MODE, "val": ErdAcOperationMode.COOL},
    {"name": COMMAND_SET_FAN, "val": ErdAcFanSetting.LOW},
  ]

  acHandler = ACHandler(readConfig(CONFIG_FILE), targetDeviceName, commands)

  client = GeWebsocketClient(username, password, region, asyncio.get_running_loop())
  client.add_event_handler(EVENT_APPLIANCE_INITIAL_UPDATE, acHandler.handle)

  session = aiohttp.ClientSession()
  credentials = readToken(username)
  if credentials != None:
    try:
      client._session = session
      client.credentials = credentials
      await client._async_run_client()
    except:
      await client.async_get_credentials_and_run(session)
  else:
    await client.async_get_credentials_and_run(session)


class ACHandler():
  def __init__(self, config, targetDeviceName, commands):
    self.config = config
    self.targetDeviceName = targetDeviceName
    self.commands = commands

    self.targetMac = None
    for entry in self.config:
      if entry['name'] == targetDeviceName:
        self.targetMac = entry['mac']

  async def handle(self, appliance):
    if self.targetMac == None:
      return

    if getMacSuffix(appliance.mac_addr) == getMacSuffix(self.targetMac):
      await self.applyCommands(appliance)

  async def applyCommands(self, appliance):
    isChanged = False
    for cmd in self.commands:
      cmdName = cmd['name']
      cmdVal = cmd['val']
      if cmdName == COMMAND_GET:
        print(appliance.get_erd_value(ErdCode.AC_POWER_STATUS))
        print(appliance.get_erd_value(ErdCode.AC_OPERATION_MODE))
        print(appliance.get_erd_value(ErdCode.AC_FAN_SETTING))
        print(
          "-> " + str(appliance.get_erd_value(ErdCode.AC_TARGET_TEMPERATURE))
          + "F (cur " + str(appliance.get_erd_value(ErdCode.AC_AMBIENT_TEMPERATURE))
          + "F)"
        )
      elif cmdName == COMMAND_SET_POWER:
        curPwr = appliance.get_erd_value(ErdCode.AC_POWER_STATUS)
        if cmdVal == POWER_ON or (cmdVal == POWER_TOGGLE and curPwr == ErdOnOff.OFF):
          targetPwr = ErdOnOff.ON
        else:
          targetPwr = ErdOnOff.OFF

        if curPwr != targetPwr:
          await appliance.async_set_erd_value(ErdCode.AC_POWER_STATUS, targetPwr)
          isChanged = True
      elif cmdName == COMMAND_SET_MODE:
        curMode = appliance.get_erd_value(ErdCode.AC_OPERATION_MODE)
        targetMode = cmdVal
        if curMode != targetMode:
          await appliance.async_set_erd_value(ErdCode.AC_OPERATION_MODE, targetMode)
          isChanged = True
      elif cmdName == COMMAND_SET_TEMP:
        curTemp = appliance.get_erd_value(ErdCode.AC_TARGET_TEMPERATURE)
        targetTemp = cmdVal
        if curTemp != targetTemp:
          await appliance.async_set_erd_value(ErdCode.AC_TARGET_TEMPERATURE, targetTemp)
          isChanged = True
      elif cmdName == COMMAND_SET_FAN:
        curFan = appliance.get_erd_value(ErdCode.AC_FAN_SETTING)
        targetFan = cmdVal
        if curFan != targetFan:
          await appliance.async_set_erd_value(ErdCode.AC_FAN_SETTING, targetFan)
      else:
        die("ERROR: unknown command " + cmd)

    if isChanged:
      print("AC updated\n")
      await asyncio.sleep(0.1)
    else:
      print("(no change)\n")

    writeToken(appliance.client.account_username, appliance.client._credentials)
    os._exit(0)

def readConfig(configFile):
  with open(CONFIG_FILE, "r") as fh:
    lines = fh.readlines()

  devices = []

  hh = "[0-9a-fA-F][0-9a-fA-F]"
  c = ":?"
  macRe = hh + c + hh + c + hh + c + hh + c + hh + c + hh
  for line in lines:
    m = re.match('^\s*(\w+)\s*=\s*(' + macRe + ')\s*$', line)
    if m:
      devices.append({"name": m.group(1), "mac": m.group(2)})

  return devices

def readToken(email):
  try:
    lines = []
    with open(TOKEN_CACHE_DIR + "/" + email, "r") as fh:
      lines = fh.readlines()
    endpoint = None
    userId = None
    kind = None
    for line in lines:
      m = re.match('^\s*(endpoint|userId|kind)\s*=\s*(\S.*)$', line)
      if m and m.group(1) == "endpoint":
        endpoint = m.group(2)
      elif m and m.group(1) == "userId":
        userId = m.group(2)
      elif m and m.group(1) == "kind":
        kind = m.group(2)
    if endpoint == None:
      return None
    else:
      return {"endpoint": endpoint, "userId": userId, "kind": kind}
  except:
    return None

def writeToken(email, credentials):
  if not os.path.isdir(TOKEN_CACHE_DIR):
    os.mkdir(TOKEN_CACHE_DIR)

  with open(TOKEN_CACHE_DIR + "/" + email, "w") as fh:
    fh.write(f"endpoint={credentials['endpoint']}\n")
    fh.write(f"userId={credentials['userId']}\n")
    fh.write(f"kind={credentials['kind']}\n")

def readProc(cmd):
  return subprocess.run(cmd, stdout=subprocess.PIPE).stdout.decode('utf-8').rstrip()

def getMacSuffix(mac):
  mac = str.lower(mac.replace(":", ""))
  return mac[6:]

def die(msg):
  print(msg, file=sys.stderr)
  os._exit(1)

if __name__ == "__main__":
  asyncio.get_event_loop().run_until_complete(main())
