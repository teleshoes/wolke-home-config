#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

my $MAX_NAME_LEN = 89; #prefix is 11 chars, so filepath is 100 chars

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    print this message

  $EXEC DIR NAME
    rename <DIR> to <YYYY-MM-DD>_<NAME>
    where <YYYY-MM-DD> is the mtime of the oldest file in the dir

    if <NAME> starts with \"<YYYY-MM-DD>_\", the prefix is removed
      (prevents double-prefixing)

    set the newly renamed dir's mtime to the oldest file in the dir

  $EXEC --rename-only DIR NAME
    do not set mtimes, only rename as above

  $EXEC --touch-only DIR [DIR DIR ..]
    do not rename the indicated <DIR>s, only set mtimes as above
";

sub renameDir($$$);
sub touchDir($$$);
sub formatDateYYYYMMDD($);
sub formatTimeHHMMSS($);
sub getOldestFile(@);
sub mtime($);
sub run(@);
sub pad2($);

sub main(@){
  my $rename = 1;
  my $touch = 1;
  my @dirs;
  my $targetName = undef;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--rename-only)$/){
      $rename = 1;
      $touch = 0;
    }elsif($arg =~ /^(--touch-only)$/){
      $rename = 0;
      $touch = 1;
    }elsif(-d $arg){
      push @dirs, $arg;
    }elsif(not defined $targetName and @dirs == 1){
      $targetName = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($rename and @dirs == 2 and not defined $targetName){
    $targetName = pop @dirs;
  }

  if(@dirs == 0){
    die "$USAGE\nERROR: at least one DIR is required\n";
  }elsif($rename and not defined $targetName){
    die "$USAGE\nERROR: NAME must be given for rename\n"
  }elsif(not $rename and defined $targetName){
    die "$USAGE\nERROR: NAME can only be given for rename\n";
  }elsif($rename and @dirs != 1){
    die "USAGE\nERROR: exactly one DIR must be given for rename\n";
  }

  for my $dir(@dirs){
    $dir =~ s/\/$//;
    $dir =~ s/^\.\///;
    die "ERROR: dir must be in the current directory\n" if $dir =~ /\//;

    my $msg = "";
    $msg .= (length $msg > 0 ? "+" : "") . "rename" if $rename;
    $msg .= (length $msg > 0 ? "+" : "") . "touch" if $touch;

    print "\n\n";
    print "#$msg: $dir\n";

    my @files = `find $dir/ -type f`;
    die "ERROR: no files found: $dir\n" if @files == 0;
    my ($minMtime, $minFile) = getOldestFile @files;

    if($touch){
      touchDir($dir, $minMtime, $minFile);
    }
    if($rename){
      renameDir($dir, $targetName, $minMtime);
    }
  }
}

sub renameDir($$$){
  my ($dir, $targetName, $targetDatetime) = @_;

  my $date = formatDateYYYYMMDD $targetDatetime;
  my $time = formatTimeHHMMSS $targetDatetime;

  my $name = $targetName;

  $name =~ s/\/$//;

  if($name =~ /^(\d\d\d\d-\d\d-\d\d)_/){
    my $oldDate = $1;
    if($oldDate eq $date){
      $name =~ s/^${date}_//;
    }else{
      print "\n\nWARNING: $dir date prefix mismatch, not removing $oldDate\n";
    }
  }

  my $len = length $name;
  if($len > $MAX_NAME_LEN){
    die "ERROR: max chars exceeded ($len > $MAX_NAME_LEN) '$name'\n";
  }

  my $newDir = "${date}_${name}";

  print "#earliest file is $date $time\n";

  if($dir ne $newDir){
    run "mv", $dir, $newDir;
  }else{
    print "#dir name unchanged\n";
  }
}

sub touchDir($$$){
  my ($dir, $targetMtime, $targetRefFile) = @_;

  my $oldMtime = mtime $dir;
  if($oldMtime != $targetMtime){
    print "#mtime $oldMtime => $targetMtime\n";
    run "touch", "--reference=$targetRefFile", $dir;
  }else{
    print "#mtime unchanged\n";
  }
}

sub formatDateYYYYMMDD($){
  my ($timeEpochSex) = @_;

  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
    localtime($timeEpochSex);
  $year += 1900;
  $mon += 1;
  $mon = pad2 $mon;
  $mday = pad2 $mday;

  $hour = pad2 $hour;
  $min = pad2 $min;
  $sec = pad2 $sec;
  my $date = "${year}-${mon}-${mday}";
}
sub formatTimeHHMMSS($){
  my ($timeEpochSex) = @_;

  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
    localtime($timeEpochSex);
  $hour = pad2 $hour;
  $min = pad2 $min;
  $sec = pad2 $sec;

  return "$hour:$min:$sec";
}

sub getOldestFile(@){
  my @files = @_;

  my $minMtime = -1;
  my $minFile;
  for my $file(sort @files){
    chomp $file;
    my $mtime = mtime $file;
    if($minMtime < 0 or $mtime < $minMtime){
      $minMtime = $mtime;
      $minFile = $file;
    }
  }
  die "couldnt find earliest file\n" if $minMtime < 0 or not -f $minFile;
  return ($minMtime, $minFile);
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  my $mtime = $stat[9];
  return $mtime;
}

sub run(@){
  print "@_\n";
  system @_;
}

sub pad2($){
  return $_[0] < 10 ? "0$_[0]" : $_[0];
}

&main(@ARGV);
