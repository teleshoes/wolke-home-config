#!/usr/bin/perl
use strict;
use warnings;

my $LOG_DIR = "$ENV{HOME}/.purple/logs";
my @DIR_EXCLUDES = qw( .system aolsystemmsg );

my $DEFAULT_LINES_PER_FILE = 5;
my $DEFAULT_RECENT_FILE_COUNT = 5;

my @IGNORE_LINE_REGEXS = (
  qr/^Conversation with .+ at .+ on .+ \(\w+\)$/,
);

sub getFileLines($$);
sub anyMatches($@);
sub mtime($);

my $usage = "Usage:
  $0 [COUNT]
    print the COUNT most recent log files in $LOG_DIR
      default COUNT is $DEFAULT_RECENT_FILE_COUNT
";

sub main(@){
  my $recentFileCount = $DEFAULT_RECENT_FILE_COUNT;
  my $linesPerFile = $DEFAULT_LINES_PER_FILE;
  if(@_ == 1 and $_[0] =~ /^\d+$/){
    $recentFileCount = $_[0];
  }elsif(@_ > 0){
    die $usage;
  }

  my @files = `find $LOG_DIR -type f`;
  for my $dir(@DIR_EXCLUDES){
    @files = grep {$_ !~ /\/\Q$dir\E\//} @files;
  }
  chomp foreach @files;

  my %latest;
  for my $file(@files){
    if($file !~ /^(.*)\/[^\/]+$/){
      die "malformed file: $file\n";
    }
    my $dir = $1;
    if(not defined $latest{$dir} or $file gt $latest{$dir}){
      $latest{$dir} = $file;
    }
  }
  @files = values %latest;

  my %mtimes;
  for my $file(@files){
    $mtimes{$file} = mtime $file;
  }
  @files = sort {$mtimes{$a} <=> $mtimes{$b}} @files;

  my @okFiles;
  my %okFileLines;
  for my $file(reverse @files){
    if(@okFiles >= $recentFileCount){
      last;
    }
    my $lines = getFileLines $file, $linesPerFile;

    if(@$lines > 0){
      push @okFiles, $file;
      $okFileLines{$file} = $lines;
    }
  }

  @okFiles = reverse @okFiles;

  my $sep = "========================\n";

  my $fmt = $sep;

  for my $file(@okFiles){
    my $lines = $okFileLines{$file};

    my ($protocol, $from, $to, $fileName);
    if($file =~ /^$LOG_DIR\/([^\/]+)\/([^\/]+)\/([^\/]+)\/([^\/]+)$/){
      ($protocol, $from, $to, $fileName) = ($1, $2, $3, $4);
    }
    $fmt .= "$to  ($fileName $protocol $from)\n";
    $fmt .= $_ foreach @$lines;
    $fmt .= $sep;
  }

  print $fmt;
}

sub getFileLines($$){
  my ($file, $linesPerFile) = @_;
  my $okLines = [];

  my @lines = `cat "$file"`;
  for my $line(reverse @lines){
    if(@$okLines >= $linesPerFile){
      last;
    }
    if(not anyMatches($line, @IGNORE_LINE_REGEXS)){
      push @$okLines, $line;
    }
  }

  $okLines = [reverse @$okLines];

  return $okLines;
}

sub anyMatches($@){
  my ($str, @regexs) = @_;
  for my $regex(@regexs){
    if($str =~ /$regex/){
      return 1;
    }
  }
  return 0;
}

sub mtime($){
  return (stat $_[0])[9];
}

&main(@ARGV);
