#!/usr/bin/perl
use strict;
use warnings;

my $ROWS_PER_MEASURE = 192;
my $ROWS_PER_BEAT = int(192/4); #48

sub getNoteCounts($);
sub getStats($$$$$);
sub parseSMFile($);
sub getBPMsByRow($);
sub gameDiffKey($$);
sub parseGameDiffKey($);
sub getExpandedNoteRows($);
sub readFile($);

my $usage = "Usage:
  $0 -h|--help
    show this message

  $0 [OPTS] SM_FILE
    analyze SM_FILE, gather statistics, and print the results

  OPTS
";

sub main(@){
  my $smFile;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif(-f $arg){
      die "$usage\nERROR: multiple SM_FILE args \"$arg\" + \"$smFile\"\n" if defined $smFile;
      $smFile = $arg;
    }else{
      die "$usage\nERROR: unknown arg $arg\n";
    }
  }
  die "$usage\nERROR: missing SM_FILE\n" if not defined $smFile;

  my $smInfo = parseSMFile($smFile);

  my $bpmsByRow = convertValuesByBeatToValuesByRow($$smInfo{bpms});
  my $stopsByRow = convertValuesByBeatToValuesByRow($$smInfo{stops});

  my $stats = {};
  for my $gameDiffKey(sort keys %{$$smInfo{notesByGameDiffKey}}){
    my $rows = getExpandedNoteRows $$smInfo{notesByGameDiffKey}{$gameDiffKey};
    my ($game, $diff) = parseGameDiffKey($gameDiffKey);
    $$stats{$gameDiffKey} = getStats($game, $diff, $rows, $bpmsByRow, $stopsByRow);
  }

  for my $gameDiffKey(sort keys %$stats){
    my $s = $$stats{$gameDiffKey};
    for my $key(sort keys %$s){
      print "$gameDiffKey.$key = $$s{$key}\n";
    }
  }
  print "\n";
  for my $gameDiffKey(sort keys %$stats){
    my $s = $$stats{$gameDiffKey};
    printf "%-22s - S%-3d - V%-3d - A%-3d - F%-3d - C%-3d\n",
      $gameDiffKey,
      int($$s{DDRA_STREAM} + 0.5),
      int($$s{DDRA_VOLTAGE} + 0.5),
      int($$s{DDRA_AIR} + 0.5),
      int($$s{DDRA_FREEZE} + 0.5),
      int($$s{DDRA_CHAOS} + 0.5),
    ;
  }
}

sub getSongRowCount($){
  my ($rows) = @_;

  my $rowCount = @$rows;
  #remove trailing 0-only-rows (empty rows after the last note)
  #  leading rows before the first note DO count for the song duration
  for(my $i=$#$rows; $i>=0; $i--){
    if($$rows[$i] !~ /^0+$/){
      last;
    }
    $rowCount--;
  }

  return $rowCount;
}

sub getSongDuration($$$){
  my ($rows, $bpmsByRow, $stopsByRow) = @_;
  my $songDurS = 0;

  my $rowCount = getSongRowCount($rows);

  my @bpmRows = sort {$a <=> $b} keys %$bpmsByRow;
  for(my $i=0; $i<@bpmRows; $i++){
    my $startRow = $bpmRows[$i];
    my $endRow;
    if($i+1 < @bpmRows){
      $endRow = $bpmRows[$i+1];
    }else{
      $endRow = $rowCount - 1; #the last row happens instantaneously, apparently
    }

    my $bpm = $$bpmsByRow{$startRow};
    my $beatsPerSecond = $bpm/60.0;

    my $elapsedRows = $endRow - $startRow;
    my $elapsedBeats = $elapsedRows / $ROWS_PER_BEAT; #rows are 1/192 notes in 4/4 measures

    $songDurS += $elapsedBeats / $beatsPerSecond;
  }

  for my $stopValS(values %$stopsByRow){
    $songDurS += $stopValS;
  }

  return $songDurS;
}

sub getNoteCounts($){
  my ($rows) = @_;

  my $noteCounts = {
    NOTE_ROWS  => 0,
    TAP_ROWS   => 0,
    HOLD_ROWS  => 0,
    JUMP_ROWS  => 0,
    MINE_ROWS  => 0,
    SHOCK_ROWS => 0,
    TAPS       => 0,
    HOLDS      => 0,
    ROLLS      => 0,
    MINES      => 0,
  };
  for my $row(@$rows){
    $$noteCounts{NOTE_ROWS}++  if $row =~ /[124]/;
    $$noteCounts{TAP_ROWS}++   if $row =~ /1/;
    $$noteCounts{HOLD_ROWS}++  if $row =~ /[2]/;
    $$noteCounts{JUMP_ROWS}++  if $row =~ /[124].*[124]/;
    $$noteCounts{MINE_ROWS}++  if $row =~ /M/;
    $$noteCounts{SHOCK_ROWS}++ if $row =~ /^M+$/; #"shocks" are mine-only rows

    $$noteCounts{TAPS}  += $row =~ /1/;
    $$noteCounts{HOLDS} += $row =~ /2/;
    $$noteCounts{ROLLS} += $row =~ /4/;
    $$noteCounts{MINES} += $row =~ /M/;
  }

  return $noteCounts;
}

sub getTotalFreezeRowCount($){
  my ($rows) = @_;
  my @curFreezes;

  my $frozenRowCount = 0;
  for my $row(@$rows){
    my @holdArrows;
    my @releaseArrows;

    my @arrows = split '', $row;
    for(my $i=0; $i<@arrows; $i++){
      if($arrows[$i] =~ /[24]/){    #hold or roll start
        push @holdArrows, $i;
      }elsif($arrows[$i] =~ /[3]/){ #hold or roll end
        push @releaseArrows, $i;
      }
    }

    #count this new row for all current freezes, regardless of holds/releases
    for my $freeze(@curFreezes){
      $frozenRowCount++;
    }

    #remove released freezes
    for my $arrow(@releaseArrows){
      for my $freeze(@curFreezes){
        $freeze = [grep {$_ ne $arrow} @$freeze];
      }
      @curFreezes = grep {@$_ > 0} @curFreezes;
    }

    #add new held freeze
    if(@holdArrows > 0){
      my $freeze = [@holdArrows];
      push @curFreezes, $freeze;
    }
  }
  return $frozenRowCount;
}

sub getMaxMeasureDensity($){
  my ($rows) = @_;

  my $startRow = 0;
  my $endRow = $ROWS_PER_MEASURE-1;

  if($endRow > $#$rows){
    $endRow = $#$rows;
  }

  my $curDensity = 0 + grep {/[124M]/} @$rows[$startRow..$endRow];

  my $maxDensity = $curDensity;
  while($endRow < @$rows - 1){
    my $removedMeasure = $$rows[$startRow];
    $startRow++;
    $endRow++;
    my $addedMeasure = $$rows[$endRow];

    $curDensity-- if $removedMeasure =~ /[124M]/;
    $curDensity++ if $addedMeasure =~ /[124M]/;
    if($curDensity > $maxDensity){
      $maxDensity = $curDensity;
    }
  }

  return $maxDensity;
}

#chaos calculation part one of two - how closely packed notes with weird timings are
#  divides the arbitrary timing-irregularity based on
#    the timing of each note within a measure (arrow color),
#    by the fractional number of measures between that note and the previous note
#
#  this value typically ranges from 0 to 20,000
#  timings have arbitrarily-defined irregularities:
#    1/4 notes (red arrows) have 0 irregularity
#    1/8 notes (blue arrows) are 0.5,
#    1/16 notes (yellow arrows) are 1
#    and everything else is 1.25
#
#  each arrow of each row adds cumulatively
sub getTotalNoteIrregularity($){
  my ($rows) = @_;
  my $totalIrregularity = 0;

  my $previousNoteIndex = undef;
  for(my $i=0; $i<@$rows; $i++){
    my $row = $$rows[$i];
    next if $row !~ /[124M]/; #ignore rows without jumps, taps or mines

    #timing of the notes within a measure
    #  this corresponds to arrow 'color' in certain noteskins,
    #  although mines/shocks work the same way and dont have color
    my $noteTypeIrregularity;
    if($i % int($ROWS_PER_MEASURE/4) == 0){
      #1/4 note row => red arrows
      $noteTypeIrregularity = 0; #1/4 notes have zero irregularity
    }elsif($i % int($ROWS_PER_MEASURE/8) == 0){
      #1/8 note row => blue arrows
      $noteTypeIrregularity = 0.5;
    }elsif($i % int($ROWS_PER_MEASURE/16) == 0){
      #1/16 note row => yellow arrows
      $noteTypeIrregularity = 1.0;
    }else{
      #anything else (1/12, 1/24, 1/32, 1/48, 1/64, 1/92) => purple/green/gray arrows
      $noteTypeIrregularity = 1.25;
    }

    my $irregularity;
    if(defined $previousNoteIndex){
      #how many rows of 1/192 notes between this note and the previous
      my $intervalRows = $i-$previousNoteIndex;

      #how much of a measure is between this note and the previous
      #larger values mean less irregularity
      #  a single 1/4 note is 0.25
      #  a single 1/16 note is 0.0625
      #  three 1/16 notes is 0.1875
      #  eight 1/4 notes is 2
      my $intervalFractionalMeasures = $intervalRows/$ROWS_PER_MEASURE;

      #each arrow has its own irregularity, so 2-arrow jumps count twice,
      #  and shocks count 4x in singles and 8x in doubles
      my $arrowCount = 0 + grep {$_ =~ /[124M]/} split //, $row;

      $irregularity = $arrowCount * ($noteTypeIrregularity/$intervalFractionalMeasures);
    }else{
      #first note has no irregularity
      $irregularity = 0;
    }

    $totalIrregularity += $irregularity;
    $previousNoteIndex = $i;
  }
  return $totalIrregularity;
}

#chaos calculation part two of two - the sum of the amount that BPMs change in a song
#  the absolute value of the difference between the old BPM and the new BPM,
#    for each change and stop
#  this does NOT count the first BPM, so a song with only one BPM and no stops
#    has a BPM_CHANGE_AMOUNT of 0
#
#  a stop is equivalent to a change from 0 BPM back to the current BPM,
#    though NOT the current BPM to 0 BPM, which is ignored
#    (a stop counts only once, not twice, and the length of the stop is ignored)
#
#  a stop and a BPM change on the same 1/192 note row counts only as a change from 0BPM
#    to the new BPM (stop+change counts only once)
#
#  e.g.:
#    BPM=100, BPM=300, BPM=100           => BPM_CHANGE_AMOUNT=400
#    BPM=100, stop, stop, stop           => BPM_CHANGE_AMOUNT=300
#    BPM=100, BPM=300, stop, BPM=100     => BPM_CHANGE_AMOUNT=700
#    BPM=50, stop&BPM=100, stop, BPM=120 => BPM_CHANGE_AMOUNT=170
#
sub getBPMChangeAmount($$){
  my ($bpmsByRow, $stopsByRow) = @_;
  my $bpmChangeAmount = 0;

  my %bpmStopRows = map {$_ => 1} (keys %$bpmsByRow, keys %$stopsByRow);

  my @allBPMOrStopRows = sort {$a <=> $b} keys %bpmStopRows;

  my $curBPM = undef;
  for my $row(@allBPMOrStopRows){
    my $newBPM;
    my $bpmDiff = 0;
    if(defined $$bpmsByRow{$row}){
      $newBPM = $$bpmsByRow{$row};

      if(defined $curBPM){
        $bpmDiff = $newBPM - $curBPM;
        $bpmDiff = 0-$bpmDiff if $bpmDiff < 0;
      }
    }

    if(defined $$stopsByRow{$row}){
      $bpmDiff = defined $newBPM ? $newBPM : $curBPM;
    }

    $bpmChangeAmount += $bpmDiff;
    $curBPM = $newBPM if defined $newBPM;
  }

  return $bpmChangeAmount;
}

sub getStats($$$$$){
  my ($game, $diff, $rows, $bpmsByRow, $stopsByRow) = @_;
  my $stats = {};

  $$stats{SONG_DUR}                     = getSongDuration($rows, $bpmsByRow, $stopsByRow);
  $$stats{SONG_ROW_COUNT}               = getSongRowCount($rows);
  $$stats{NOTE_COUNTS}                  = getNoteCounts($rows);
  $$stats{MAX_MEASURE_DENSITY}          = getMaxMeasureDensity $rows;
  $$stats{TOTAL_FREEZE_ROW_COUNT}       = getTotalFreezeRowCount $rows;
  $$stats{TOTAL_NOTE_IRREGULARITY}      = getTotalNoteIrregularity $rows;
  $$stats{BPM_CHANGE_AMOUNT}            = getBPMChangeAmount($bpmsByRow, $stopsByRow);

  #DDR does lots of premature rounding
  $$stats{SONG_BEAT_COUNT}              = int($$stats{SONG_ROW_COUNT}/$ROWS_PER_BEAT + 0.5);

  $$stats{TOTAL_NOTES}                  = $$stats{NOTE_COUNTS}{NOTE_ROWS} + $$stats{NOTE_COUNTS}{SHOCK_ROWS};
  $$stats{TOTAL_JUMPS_SHOCKS}           = $$stats{NOTE_COUNTS}{JUMP_ROWS} + $$stats{NOTE_COUNTS}{SHOCK_ROWS};
  $$stats{NOTES_PER_MIN}                = 60 * ($$stats{TOTAL_NOTES}) / $$stats{SONG_DUR};
  $$stats{AVG_BPM}                      = 60 * ($$stats{SONG_ROW_COUNT}/$ROWS_PER_BEAT) / $$stats{SONG_DUR};
  $$stats{MAX_DENSITY_PER_MIN}          = $$stats{AVG_BPM}*$$stats{MAX_MEASURE_DENSITY}/4;
  $$stats{JUMPS_SHOCKS_PER_MIN}         = 60 * $$stats{TOTAL_JUMPS_SHOCKS} / $$stats{SONG_DUR};
  $$stats{FREEZE_RATIO_10K}             = 10000 * ($$stats{TOTAL_FREEZE_ROW_COUNT}/$ROWS_PER_BEAT) / $$stats{SONG_BEAT_COUNT};
  $$stats{BPM_CHANGE_AMOUNT_PER_MIN}    = 60 * $$stats{BPM_CHANGE_AMOUNT} / $$stats{SONG_DUR};
  $$stats{OVERALL_IRREGULARITY}         = $$stats{TOTAL_NOTE_IRREGULARITY} * (1 + $$stats{BPM_CHANGE_AMOUNT_PER_MIN}/1500);
  $$stats{IRREGULARITY_PER_CENTISECOND} = 100 * $$stats{OVERALL_IRREGULARITY} / $$stats{SONG_DUR};

  #die $$stats{OVERALL_IRREGULARITY} if $game =~ /single/ and $diff =~ /hard/;

  #stream
  if($game =~ /single/i){
    if($$stats{NOTES_PER_MIN} >= 300){
      $$stats{SN2_STREAM} = ($$stats{NOTES_PER_MIN}-203)*100/97;
      $$stats{DDRA_STREAM} = ($$stats{NOTES_PER_MIN}-139)*100/161;
    }else{
      $$stats{SN2_STREAM} = $$stats{NOTES_PER_MIN}/3;
      $$stats{DDRA_STREAM} = $$stats{NOTES_PER_MIN}/3;
    }
  }elsif($game =~ /double/i){
    if($$stats{NOTES_PER_MIN} >= 300){
      $$stats{SN2_STREAM} = ($$stats{NOTES_PER_MIN}-205)*20/19;
      $$stats{DDRA_STREAM} = ($$stats{NOTES_PER_MIN}-183)*100/117;
    }else{
      $$stats{SN2_STREAM} = $$stats{NOTES_PER_MIN}/3;
      $$stats{DDRA_STREAM} = $$stats{NOTES_PER_MIN}/3;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  #voltage
  if($$stats{MAX_DENSITY_PER_MIN} >= 600){
    $$stats{SN2_VOLTAGE} = ($$stats{MAX_DENSITY_PER_MIN}+102)*100/702;
    $$stats{DDRA_VOLTAGE} = ($$stats{MAX_DENSITY_PER_MIN}+594)*100/1194;
  }else{
    $$stats{SN2_VOLTAGE} = $$stats{MAX_DENSITY_PER_MIN}/6;
    $$stats{DDRA_VOLTAGE} = $$stats{MAX_DENSITY_PER_MIN}/6;
  }

  #air
  if($game =~ /single/i){
    if($$stats{JUMPS_SHOCKS_PER_MIN} >= 55){
      $$stats{SN2_AIR} = ($$stats{JUMPS_SHOCKS_PER_MIN}-1)*50/27;
      $$stats{DDRA_AIR} = ($$stats{JUMPS_SHOCKS_PER_MIN}+36)*100/91;
    }else{
      $$stats{SN2_AIR} = $$stats{JUMPS_SHOCKS_PER_MIN}*20/11;
      $$stats{DDRA_AIR} = $$stats{JUMPS_SHOCKS_PER_MIN}*20/11;
    }
  }elsif($game =~ /double/i){
    if($$stats{JUMPS_SHOCKS_PER_MIN} >= 55){
      $$stats{SN2_AIR} = ($$stats{JUMPS_SHOCKS_PER_MIN}-1)*50/27;
      $$stats{DDRA_AIR} = ($$stats{JUMPS_SHOCKS_PER_MIN}+35)*10/9;
    }else{
      $$stats{SN2_AIR} = $$stats{JUMPS_SHOCKS_PER_MIN}*20/11;
      $$stats{DDRA_AIR} = $$stats{JUMPS_SHOCKS_PER_MIN}*20/11;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  #freeze
  if($game =~ /single/i){
    if($$stats{FREEZE_RATIO_10K} >= 3500){
      $$stats{SN2_FREEZE} = ($$stats{FREEZE_RATIO_10K}+2484)*100/5984;
      $$stats{DDRA_FREEZE} = ($$stats{FREEZE_RATIO_10K}+2484)*100/5984;
    }else{
      $$stats{SN2_FREEZE} = $$stats{FREEZE_RATIO_10K}/35;
      $$stats{DDRA_FREEZE} = $$stats{FREEZE_RATIO_10K}/35;
    }
  }elsif($game =~ /double/i){
    if($$stats{FREEZE_RATIO_10K} >= 3500){
      $$stats{SN2_FREEZE} = ($$stats{FREEZE_RATIO_10K}+2246)*100/5746;
      $$stats{DDRA_FREEZE} = ($$stats{FREEZE_RATIO_10K}+2246)*100/5746;
    }else{
      $$stats{SN2_FREEZE} = $$stats{FREEZE_RATIO_10K}/35;
      $$stats{DDRA_FREEZE} = $$stats{FREEZE_RATIO_10K}/35;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  #chaos
  if($game =~ /single/i){
    if($$stats{IRREGULARITY_PER_CENTISECOND} >= 2000){
      $$stats{SN2_CHAOS} = ($$stats{IRREGULARITY_PER_CENTISECOND}+21605)*100/23605;
      $$stats{DDRA_CHAOS} = ($$stats{IRREGULARITY_PER_CENTISECOND}+21605)*100/23605;
    }else{
      $$stats{SN2_CHAOS} = $$stats{IRREGULARITY_PER_CENTISECOND}/20;
      $$stats{DDRA_CHAOS} = $$stats{IRREGULARITY_PER_CENTISECOND}/20;
    }
  }elsif($game =~ /double/i){
    if($$stats{IRREGULARITY_PER_CENTISECOND} >= 2000){
      $$stats{SN2_CHAOS} = ($$stats{IRREGULARITY_PER_CENTISECOND}+16628)*100/18628;
      $$stats{DDRA_CHAOS} = ($$stats{IRREGULARITY_PER_CENTISECOND}+16628)*100/18628;
    }else{
      $$stats{SN2_CHAOS} = $$stats{IRREGULARITY_PER_CENTISECOND}/20;
      $$stats{DDRA_CHAOS} = $$stats{IRREGULARITY_PER_CENTISECOND}/20;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  return $stats;
}

sub parseSMFile($){
  my ($smFile) = @_;
  my $sm = readFile $smFile;

  my $smInfo = {
    bpms               => undef,
    stops              => undef,
    notesByGameDiffKey => {},
  };

  if($sm !~ /#BPMS:([^;]+);/i){
    die "ERROR: could not read BPMs from $smFile\n";
  }else{
    $$smInfo{bpms} = $1;
  }

  if($sm !~ /#STOPS:([^;]*);/i){
    die "ERROR: could not read STOPS from $smFile\n";
  }else{
    $$smInfo{stops} = $1;
  }

  my $reName = '(?:[a-zA-Z0-9\-_]+)';

  #SM files
  while($sm =~ /
    \#NOTES                  \s*:\s*
    (?<game>$reName)         \s*:\s*
    [^:]*?                   \s*:\s*
    (?<difficulty>$reName)   \s*:\s*
    [^:]*?                   \s*:\s*
    [^:]*?                   \s*:\s*
    (?<notes>[^;]+?)         ;
  /gsxi){
    my ($game, $difficulty, $notes) = ($+{game}, $+{difficulty}, $+{notes});

    my $gameDiffKey = gameDiffKey($game, $difficulty);
    $$smInfo{notesByGameDiffKey}{$gameDiffKey} = $notes;
  }

  #SSC files
  my @sscNoteSets = $sm =~ /\#NOTEDATA\s*:.*?#NOTES\s*:[^;]*;/gsi;
  for my $noteSet(@sscNoteSets){
    my $game = $1       if $noteSet =~ /\#STEPSTYPE    \s*:\s*   ($reName)   \s*;\s*/sxi;
    my $difficulty = $1 if $noteSet =~ /\#DIFFICULTY   \s*:\s*   ($reName)   \s*;\s*/sxi;
    my $notes = $1      if $noteSet =~ /\#NOTES        \s*:\s*   ([^;]+)     \s*;\s*/sxi;

    die "ERROR: missing STEPSTYPE from $smFile $noteSet\n" if not defined $game;
    die "ERROR: missing DIFFICULTY from $smFile\n" if not defined $difficulty;
    die "ERROR: missing NOTES from $smFile\n" if not defined $notes;

    my $gameDiffKey = gameDiffKey($game, $difficulty);
    $$smInfo{notesByGameDiffKey}{$gameDiffKey} = $notes;
  }

  my $gameDiffKeyCount = keys %{$$smInfo{notesByGameDiffKey}};
  if($gameDiffKeyCount == 0){
    die "ERROR: could not parse any note sets in $smFile\n";
  }

  return $smInfo;
}

#convert BPMS or STOPS entries like '1.125=90.000' to '54 => 90.000'
#  ROW == BEAT * 48
#  entries in SM files use BEATs, i.e.: fractional 1/4 notes
#     (the first three 1/8 notes in a song of just 1/8 notes: 0.000, 0.500, 1.000)
#  this converts everything to 1/192 note ROWs, and assigns an integral index
#     (the first three 1/8 notes in a song of just 1/8 notes: 0, 24, 48)
sub convertValuesByBeatToValuesByRow($){
  my ($csvBeatValPairs) = @_;

  my $valsByRow = {};
  my @beatValPairs = split /,/, $csvBeatValPairs;
  for my $beatValPair(@beatValPairs){
    $beatValPair =~ s/[ \t\r\n]*//g;
    next if $beatValPair eq "";
    if($beatValPair !~ /^(\d+|\d*\.\d+)=(\d+|\d*\.\d+)$/){
      die "ERROR: invalid BEAT=VALUE entry \"$beatValPair\"\n";
    }
    my ($beat, $val) = ($1, $2);
    my $fracRow = $beat * $ROWS_PER_BEAT;
    my $row = int($fracRow + 0.5);

    my $fracDiff = $fracRow - $row;
    $fracDiff = 0 - $fracDiff if $fracDiff < 0;
    if($fracDiff > 0.001){
      my $msg = "WARNING: invalid BEAT in BPM"
        . " (not close to 1/$ROWS_PER_MEASURE note; forced to the nearest anyway)"
        . " \"$fracRow\"\n"
        ;
      print $msg;
    }

    $$valsByRow{$row} = $val;
  }
  return $valsByRow;
}

sub gameDiffKey($$){
  my ($game, $diff) = @_;
  return lc "$game-$diff";
}
sub parseGameDiffKey($){
  my ($gameDiffKey) = @_;
  if($gameDiffKey =~ /^(.+)-(.+)$/){
    return ($1, $2);
  }
}

#SM files contain a list of MEASUREs for each game-difficulty pair
#  each MEASURE is a list of 192 NOTE_ROWs (which is usually condensed as below),
#    one per line, with a comma separating MEASUREs on its own line
#
#  each NOTE_ROW contains one chracter per arrow
#    e.g.:  1100   for left-down jump
#
#  each MEASURE is also divided into 4 BEATs, which are 48 NOTE_ROWs each
#    (stepmania actively assumes 4/4 time signature for some reason,
#     instead of not having a time sig)
#
#  MEASUREs are condensed to only 4/8/12/16/24/32/48/64/192 rows where possible
#    (if a measure has only 1/32 notes, it will have 32 rows instead of 192)
#
#  this method expands it back up to 192 NOTE_ROWs per MEASURE,
#    by inserting all-zero blank rows,
#    and then joins all the rows together in a simple list, ignoring MEASURE
#
#  e.g.:
#    this measure:
#      1000
#      0100
#      0010
#      0001
#      ,
#    will expand from 4 to 192 rows, inserting 47 rows of '0000' after each of the 4 rows
#    the resulting rows will be all '0000's, except for:
#      row#0, row#48, row#96, and row#144
sub getExpandedNoteRows($){
  my ($noteSetText) = @_;
  my @measures = split /,/, $noteSetText;

  my @noteRows;
  for my $measure(@measures){
    my @lines = split /[\r\n]+/, $measure;

    s/\/\/.*// foreach @lines;            #remove comments
    s/F/0/g foreach @lines;               #remove fakes
    @lines = grep {$_ !~ /^\s*$/} @lines; #remove whitespace-only/empty lines

    for my $line(@lines){
      if($line !~ /^[01234MLFAKNH]+$/){
        die "ERROR: malformed measure row $line\n";
      }
    }

    my @collapsedMeasureRows = @lines;
    my $collapsedMeasureRowCount = @collapsedMeasureRows;

    die "ERROR: empty measure $measure\n" if $collapsedMeasureRowCount == 0;

    my $firstRow = $collapsedMeasureRows[0];
    my $emptyRow = $firstRow;
    $emptyRow =~ s/[01234MLFAKNH]/0/g;
    if($emptyRow !~ /^0+$/){
      die "ERROR: malformed first measure row $firstRow\n";
    }

    my $repeatRowCount = int($ROWS_PER_MEASURE/$collapsedMeasureRowCount);

    my @expandedMeasureRows;
    for my $row(@collapsedMeasureRows){
      if($row !~ /^[01234MLFAKNH]+$/){
        die "ERROR: malformed note row: $row\n";
      }
      push @expandedMeasureRows, $row;
      for(my $i=0; $i<$repeatRowCount-1; $i++){
        push @expandedMeasureRows, $emptyRow;
      }
    }

    if(@expandedMeasureRows != $ROWS_PER_MEASURE){
      die "ERROR: malformed measure (rowCount=$collapsedMeasureRowCount):\n$measure";
    }
    @noteRows = (@noteRows, @expandedMeasureRows);
  }

  return \@noteRows;
}

sub readFile($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n";
  my $contents = join '', <FH>;
  close FH;
  return $contents;
}

&main(@ARGV);
