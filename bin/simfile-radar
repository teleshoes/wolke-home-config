#!/usr/bin/perl
use strict;
use warnings;

my $ROWS_PER_MEASURE = 192;
my $ROWS_PER_BEAT = int(192/4); #48

sub formatStats($$);
sub getNoteCounts($);
sub getStats($$$$$);
sub parseSMFile($);
sub getBPMsByRow($);
sub gameDiffKey($$);
sub parseGameDiffKey($);
sub getExpandedNoteRows($);
sub readFile($);

my $DEFAULT_FORMAT_SPEC = ""
  . "%-7s-GAME"
  . " | %-10s-DIFF"
  . " | S%-3d-DDRA_STREAM"
  . " | V%-3d-DDRA_VOLTAGE"
  . " | A%-3d-DDRA_AIR"
  . " | F%-3d-DDRA_FREEZE"
  . " | C%-3d-DDRA_CHAOS"
  . "%n"
;

my $usage = "Usage:
  $0 -h|--help
    show this message

  $0 [OPTS] SM_FILE
    analyze SM_FILE, gather statistics for each VARIABLE,
    and print the result using FORMAT_SPEC

  VARIABLE
    GAME
      game type in simfile, with replacements to match DDR:
        dance-single => singles
        dance-double => doubles
      all other values are left as-is (e.g.: dance-couple, pump-single)
    DIFF
      difficulty level in simfile, with replacments to match DDR:
        Beginner  => beginner
        Easy      => basic
        Medium    => difficult
        Hard      => expert
        Expert    => challenge
        Challenge => challenge
      all other values are left as-is (e.g.: Edit, Fingers)
    SONG_DUR
      song duration, in fractional seconds
      this is calculated using BPM_ROWS, STOP_ROWS and SONG_ROW_COUNT
      e.g.: 121.000666666667
    BPM_ROWS
      a comma-separated list of ROW=BPM pairs
      (this is converted from the BEAT=BPM pairs stored in the simfile)
        BEAT = fractional index of 1/4 note, as defined in the simfile
        BPM = beats per minute, as defined in the simfile
        ROW = BEAT*$ROWS_PER_BEAT
      e.g.: \"#BPMS:0=180,4=180,142=90,143=180,149=180,149.5=180,156=90,157=180;\"
            =>
            0=180,192=180,6816=90,6864=180,7152=180,7176=180,7488=90,7536=180
    STOP_ROWS
      a comma-separated list of ROW=STOP_DURATION pairs
      (this is converted from the BEAT=STOP_DURATION pairs stored in the simfile)
        BEAT = fractional index of 1/4 note, as defined in the simfile
        STOP_DURATION = stop duration in seconds, as defined in the simfile
        ROW = BEAT*$ROWS_PER_BEAT
      e.g.: \"#STOPS:149=0.167,149.5=0.167;\"
            =>
            7152=0.167,7176=0.167
    SONG_ROW_COUNT
      this is the total number of 1/$ROWS_PER_MEASURE rows in a song,
        and is equivalent to the number of beats in a song times $ROWS_PER_BEAT
      note that leading empty rows DO count towards the count or song duration,
        but trailing empty rows do NOT count towards the count or song duration
        (all empty rows at the end of a song are ignored)
      e.g.: 17281
    SONG_BEAT_COUNT
      SONG_ROW_COUNT divided by $ROWS_PER_BEAT, rounded to the nearest integer
      e.g.: 360
    MAX_MEASURE_DENSITY
      for every contiguous chain of $ROWS_PER_MEASURE rows in the song,
        count the number of non-empty ROWS (not arrows),
        where non-empty rows contain at least one arrow with a tap, hold, roll, or mine
      take the maximum count of non-empty rows of any contiguous chain
      if a 'song' has fewer than $ROWS_PER_MEASURE rows (song is shorter than one measure),
        count the total number of non-empty rows
    TOTAL_FREEZE_ROW_COUNT
      find every hold-row, count the number of rows until its released, and sum the counts
        a hold-row is a row with a single-arrow-hold-start or a multi-arrow-hold-start
        a hold-row is released when ALL of its arrows have a hold-release
          i.e.: the last hold-release for all the arrows in the hold-start
      note:
        holds on different arrows that start at different times can overlap,
          and each is counted independently
        multi-arrow holds only count once, and the longest-held arrow is used
    TOTAL_NOTE_IRREGULARITY
      sum( ARROW_COUNT * TIMING_IRREGULARITY / INTERVAL_MEASURES )
      an arbitrary measure of how closely packed notes with weird timings are
        (this is one of two components of CHAOS, along with BPM_CHANGE_AMOUNT)
        this value typically ranges from 0 to 6000
      for each note-row (row containing taps/holds/rolls/mines):
        find the TIMING_IRREGULARITY, based on the timing of the row within a measure
          (this is sometimes called 'arrow color', as some noteskins assign different colors)
          timings have arbitrarily-defined TIMING_IRREGULARITY values:
            1/4 notes (red arrows)     => 0
            1/8 notes (blue arrows)    => 0.5
            1/16 notes (yellow arrows) => 1
            everything else            => 1.25
          note that this is counted the same for taps, holds, rolls, and mines/shocks,
            regardless of what 'arrow color' the noteskin uses for these
        find the INTERVAL_MEASURES, in fractional measures,
          between this note-row and the previous note-row
          (count the number of rows between, and divide by $ROWS_PER_MEASURE)
        find the ARROW_COUNT, the number of taps/holds/mines in the row
          e.g.: 1 for single-arrow taps/holds/rolls
                2 for jumps
                4 for shocks on singles play
                8 for shocks on doubles play
        divide the arbitrary timing-irregularity based on
          the timing of each note within a measure (arrow color),
          by the fractional number of measures between that note and the previous note,
          and multiply by the ARROW_COUNT
    BPM_CHANGE_AMOUNT
      sum( BPM_CHANGE_DIFF )
      the sum of the amount that BPMs change in a song
        (this is one of two components of CHAOS, along with TOTAL_NOTE_IRREGULARITY)
      the absolute value of the difference between the old BPM and the new BPM,
        for each change AND stop, all added together
        this does NOT count the first BPM
          (a song with one fixed BPM and no stops has a BPM_CHANGE_AMOUNT of 0)
        a stop is equivalent to a change from 0 BPM back to the current BPM,
          though NOT the current BPM to 0 BPM, which is ignored
          (a stop counts only once, not twice, and the length of the stop is ignored)
        a stop and a BPM change on the same 1/192 note row counts only as a change from 0BPM
          to the new BPM (stop+change counts only once)
      e.g.:
        BPM=100, BPM=300, BPM=100           => BPM_CHANGE_AMOUNT=400
        BPM=100, stop, stop, stop           => BPM_CHANGE_AMOUNT=300
        BPM=100, BPM=300, stop, BPM=100     => BPM_CHANGE_AMOUNT=700
        BPM=50, stop&BPM=100, stop, BPM=120 => BPM_CHANGE_AMOUNT=170
    COUNT_NOTE_ROWS
      total number of rows in the song that contain:
        single-arrow-tap,        multi-arrow-tap,
        single-arrow-hold-start, multi-arrow-hold-start,
        single-arrow-roll-start, multi-arrow-roll-start
    COUNT_TAP_ROWS
      total number of rows in the song that contain:
        single-arrow-tap,        multi-arrow-tap
    COUNT_HOLD_ROWS
      total number of rows in the song that contain:
        single-arrow-hold-start, multi-arrow-hold-start
    COUNT_JUMP_ROWS
      total number of rows in the song that contain:
        mutli-arrow-tap,
        multi-arrow-hold-start
        multi-arrow-roll-start
    COUNT_MINE_ROWS
      total number of rows in the song that contain:
        single-mine,              multi-mine
    COUNT_SHOCK_ROWS
      total number of rows in the song that contain ONLY mines, for all arrows
    COUNT_TAPS
      total number of ARROWS in single-arrow-tap or multi-arrow-tap rows
        e.g.: a jump is 2 taps, but only 1 tap-row
    COUNT_HOLDS
      total number of ARROWS in single-arrow-hold-start or multi-arrow-hold-start rows
        e.g.: a jump-hold is 2 holds, but only 1 hold-row
    COUNT_ROLLS
      total number of ARROWS in single-arrow-roll-start or multi-arrow-roll-start rows
        e.g.: a jump-roll is 2 rolls, but only 1 roll-row
    COUNT_MINES
      total number of MINES in single-mine or multi-mine rows
        e.g.: a shock is 4 mines (in singles play), but only 1 shock-row
    DDRA_STREAM
      groove radar \"stream\" value approximately matching values in DDR A + DDR A20
    DDRA_VOLTAGE
      groove radar \"voltage\" value approximately matching values in DDR A + DDR A20
    DDRA_AIR
      groove radar \"air\" value approximately matching values in DDR A + DDR A20
    DDRA_FREEZE
      groove radar \"freeze\" value approximately matching values in DDR A + DDR A20
    DDRA_CHAOS
      groove radar \"chaos\" value approximately matching values in DDR A + DDR A20

  OPTS
    --singles | singles | --single | single | --dance-single | dance-single
      ignore (and skip calculations for) all note-sets where GAME is not 'singles'
    --doubles | doubles | --double | double | --dance-double | dance-double
      ignore (and skip calculations for) all note-sets where GAME is not 'doubles'

    --beginner | beginner
      ignore (and skip calculations for) all note-sets where DIFF is not 'beginner'
    --basic | basic
      ignore (and skip calculations for) all note-sets where DIFF is not 'basic'
    --difficult | difficult
      ignore (and skip calculations for) all note-sets where DIFF is not 'difficult'
    --expert | expert
      ignore (and skip calculations for) all note-sets where DIFF is not 'expert'
    --challenge | challenge
      ignore (and skip calculations for) all note-sets where DIFF is not 'challenge'
    --format=FORMAT_SPEC
      FORMAT_SPEC can be any string, with the following printf-like replacements:
        %%                       = a literal % character
        %n                       = a newline character (\\n)
        %<VARIABLE>              = VARIABLE value
                                   e.g.: %STREAM
        %<PRINTF_MOD><VARIABLE>  = VARIABLE value, formatted with PRINTF_MOD
                                   e.g.: %05.2fSTREAM
        %<PRINTF_MOD>-<VARIABLE> = VARIABLE value, formatted with PRINTF_MOD
                                   e.g.: %05.2f-STREAM
      default=$DEFAULT_FORMAT_SPEC
         e.g.: singles | expert     | S122 | V109 | A0   | F0   | C108

      PRINTF_MOD = FLAGS|WIDTH|PRECISION|SPECIFIER
        almost any printf string, like '+08.2f',
          except:
            'width' must be a number, not '*'
            'precision' must be a number, not '.*'
            'length' (C datatype) is not allowed
            'specifier' n is not allowed
            'specifier' % is not allowed

        FLAGS
          any (or none) of \"-\", \"+\", \" \", \"#\", \"0\"
          e.g.: - 0
        WIDTH:
          missing, or a positive integer
          e.g.: 32
        PRECISION:
          missing, or a decimal point followed by a positive integer
          e.g.: .2
        SPECIFIER:
          exactly one of: d i u o x X f F e E g G a A c s
          e.g.: f
";

sub main(@){
  my $smFile;
  my $gameFilter;
  my $diffFilter;
  my $formatSpec = $DEFAULT_FORMAT_SPEC;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(?:--)?(?:dance-)?(single|double)s$/){
      $gameFilter = "$1s";
    }elsif($arg =~ /^(?:--)?(beginner|basic|difficult|expert|challenge)$/){
      $diffFilter = $1;
    }elsif($arg =~ /^--format=(.+)$/){
      $formatSpec = $1;
    }elsif(-f $arg){
      die "$usage\nERROR: multiple SM_FILE args \"$arg\" + \"$smFile\"\n" if defined $smFile;
      $smFile = $arg;
    }else{
      die "$usage\nERROR: unknown arg $arg\n";
    }
  }
  die "$usage\nERROR: missing SM_FILE\n" if not defined $smFile;

  my $smInfo = parseSMFile($smFile);

  my $bpmsByRow = convertValuesByBeatToValuesByRow($$smInfo{bpms});
  my $stopsByRow = convertValuesByBeatToValuesByRow($$smInfo{stops});

  my $stats = {};
  for my $gameDiffKey(sort keys %{$$smInfo{notesByGameDiffKey}}){
    my $rows = getExpandedNoteRows $$smInfo{notesByGameDiffKey}{$gameDiffKey};
    my ($game, $diff) = parseGameDiffKey($gameDiffKey);
    my $ddrGame = formatDDRGame($game);
    my $ddrDiff = formatDDRDiff($diff);
    next if defined $gameFilter and $ddrGame !~ /^$gameFilter$/i;
    next if defined $diffFilter and $ddrDiff !~ /^$diffFilter$/i;
    $$stats{$gameDiffKey} = getStats($game, $diff, $rows, $bpmsByRow, $stopsByRow);
  }

  for my $gameDiffKey(sort keys %$stats){
    print formatStats($formatSpec, $$stats{$gameDiffKey});
  }
}

sub formatStats($$){
  my ($formatSpec, $stats) = @_;

  my $s = $formatSpec;
  $s =~ s/&/&amp;/g;
  $s =~ s/%%/&boing;/g;

  $s =~ s/%n/\n/g;

  my $varRegex = join "|", sort keys %$stats;
  my $printfModRegex = '[ \-+#0]*\d*(?:\.\d+)?[diuoxXfFeEgGaAcs]';
  while($s =~ s/%((?:$printfModRegex)?)-?($varRegex)/&var;/){
    my ($printfMod, $varName) = ($1, $2);
    my $val = $$stats{$varName};
    $val =~ s/&/&amp;/g;
    $val =~ s/%/&boing;/g;
    if(length $printfMod > 0){
      $val = sprintf "%$printfMod", $val;
    }
    $s =~ s/&var;/$val/g;
  }

  if($s =~ /%/){
    die "ERROR: format-spec contains unknown replacement var \"$formatSpec\"\n";
  }

  $s =~ s/&boing;/%/g;
  $s =~ s/&amp;/&/g;

  return $s;
}

sub getSongRowCount($){
  my ($rows) = @_;

  my $rowCount = @$rows;
  #remove trailing 0-only-rows (empty rows after the last note)
  #  leading rows before the first note DO count for the song duration
  for(my $i=$#$rows; $i>=0; $i--){
    if($$rows[$i] !~ /^0+$/){
      last;
    }
    $rowCount--;
  }

  return $rowCount;
}

sub getSongDuration($$$){
  my ($rows, $bpmsByRow, $stopsByRow) = @_;
  my $songDurS = 0;

  my $rowCount = getSongRowCount($rows);

  my @bpmRows = sort {$a <=> $b} keys %$bpmsByRow;
  for(my $i=0; $i<@bpmRows; $i++){
    my $startRow = $bpmRows[$i];
    my $endRow;
    if($i+1 < @bpmRows){
      $endRow = $bpmRows[$i+1];
    }else{
      $endRow = $rowCount - 1; #the last row happens instantaneously, apparently
    }

    my $bpm = $$bpmsByRow{$startRow};
    my $beatsPerSecond = $bpm/60.0;

    my $elapsedRows = $endRow - $startRow;
    my $elapsedBeats = $elapsedRows / $ROWS_PER_BEAT; #rows are 1/192 notes in 4/4 measures

    $songDurS += $elapsedBeats / $beatsPerSecond;
  }

  for my $stopValS(values %$stopsByRow){
    $songDurS += $stopValS;
  }

  return $songDurS;
}

sub getNoteCounts($){
  my ($rows) = @_;

  my $noteCounts = {
    COUNT_NOTE_ROWS  => 0,
    COUNT_TAP_ROWS   => 0,
    COUNT_HOLD_ROWS  => 0,
    COUNT_JUMP_ROWS  => 0,
    COUNT_MINE_ROWS  => 0,
    COUNT_SHOCK_ROWS => 0,
    COUNT_TAPS       => 0,
    COUNT_HOLDS      => 0,
    COUNT_ROLLS      => 0,
    COUNT_MINES      => 0,
  };
  for my $row(@$rows){
    $$noteCounts{COUNT_NOTE_ROWS}++  if $row =~ /[124]/;
    $$noteCounts{COUNT_TAP_ROWS}++   if $row =~ /1/;
    $$noteCounts{COUNT_HOLD_ROWS}++  if $row =~ /[2]/;
    $$noteCounts{COUNT_JUMP_ROWS}++  if $row =~ /[124].*[124]/;
    $$noteCounts{COUNT_MINE_ROWS}++  if $row =~ /M/;
    $$noteCounts{COUNT_SHOCK_ROWS}++ if $row =~ /^M+$/; #"shocks" are mine-only rows

    $$noteCounts{COUNT_TAPS}  += $row =~ /1/;
    $$noteCounts{COUNT_HOLDS} += $row =~ /2/;
    $$noteCounts{COUNT_ROLLS} += $row =~ /4/;
    $$noteCounts{COUNT_MINES} += $row =~ /M/;
  }

  return $noteCounts;
}

sub getTotalFreezeRowCount($){
  my ($rows) = @_;
  my @curFreezes;

  my $frozenRowCount = 0;
  for my $row(@$rows){
    my @holdArrows;
    my @releaseArrows;

    my @arrows = split '', $row;
    for(my $i=0; $i<@arrows; $i++){
      if($arrows[$i] =~ /[24]/){    #hold or roll start
        push @holdArrows, $i;
      }elsif($arrows[$i] =~ /[3]/){ #hold or roll end
        push @releaseArrows, $i;
      }
    }

    #count this new row for all current freezes, regardless of holds/releases
    for my $freeze(@curFreezes){
      $frozenRowCount++;
    }

    #remove released freezes
    for my $arrow(@releaseArrows){
      for my $freeze(@curFreezes){
        $freeze = [grep {$_ ne $arrow} @$freeze];
      }
      @curFreezes = grep {@$_ > 0} @curFreezes;
    }

    #add new held freeze
    if(@holdArrows > 0){
      my $freeze = [@holdArrows];
      push @curFreezes, $freeze;
    }
  }
  return $frozenRowCount;
}

sub getMaxMeasureDensity($){
  my ($rows) = @_;

  my $startRow = 0;
  my $endRow = $ROWS_PER_MEASURE-1;

  if($endRow > $#$rows){
    $endRow = $#$rows;
  }

  my $curDensity = 0 + grep {/[124M]/} @$rows[$startRow..$endRow];

  my $maxDensity = $curDensity;
  while($endRow < @$rows - 1){
    my $removedMeasure = $$rows[$startRow];
    $startRow++;
    $endRow++;
    my $addedMeasure = $$rows[$endRow];

    $curDensity-- if $removedMeasure =~ /[124M]/;
    $curDensity++ if $addedMeasure =~ /[124M]/;
    if($curDensity > $maxDensity){
      $maxDensity = $curDensity;
    }
  }

  return $maxDensity;
}

sub getTotalNoteIrregularity($){
  my ($rows) = @_;
  my $totalIrregularity = 0;

  my $previousNoteIndex = undef;
  for(my $i=0; $i<@$rows; $i++){
    my $row = $$rows[$i];
    next if $row !~ /[124M]/; #ignore rows without jumps, taps or mines

    #timing of the notes within a measure
    #  this corresponds to arrow 'color' in certain noteskins,
    #  although mines/shocks work the same way and dont have color
    my $noteTypeIrregularity;
    if($i % int($ROWS_PER_MEASURE/4) == 0){
      #1/4 note row => red arrows
      $noteTypeIrregularity = 0; #1/4 notes have zero irregularity
    }elsif($i % int($ROWS_PER_MEASURE/8) == 0){
      #1/8 note row => blue arrows
      $noteTypeIrregularity = 0.5;
    }elsif($i % int($ROWS_PER_MEASURE/16) == 0){
      #1/16 note row => yellow arrows
      $noteTypeIrregularity = 1.0;
    }else{
      #anything else (1/12, 1/24, 1/32, 1/48, 1/64, 1/92) => purple/green/gray arrows
      $noteTypeIrregularity = 1.25;
    }

    my $irregularity;
    if(defined $previousNoteIndex){
      #how many rows of 1/192 notes between this note and the previous
      my $intervalRows = $i-$previousNoteIndex;

      #how much of a measure is between this note and the previous
      #larger values mean less irregularity
      #  a single 1/4 note is 0.25
      #  a single 1/16 note is 0.0625
      #  three 1/16 notes is 0.1875
      #  eight 1/4 notes is 2
      my $intervalFractionalMeasures = $intervalRows/$ROWS_PER_MEASURE;

      #each arrow has its own irregularity, so 2-arrow jumps count twice,
      #  and shocks count 4x in singles and 8x in doubles
      my $arrowCount = 0 + grep {$_ =~ /[124M]/} split //, $row;

      $irregularity = $arrowCount * ($noteTypeIrregularity/$intervalFractionalMeasures);
    }else{
      #first note has no irregularity
      $irregularity = 0;
    }

    $totalIrregularity += $irregularity;
    $previousNoteIndex = $i;
  }
  return $totalIrregularity;
}

sub getBPMChangeAmount($$){
  my ($bpmsByRow, $stopsByRow) = @_;
  my $bpmChangeAmount = 0;

  my %bpmStopRows = map {$_ => 1} (keys %$bpmsByRow, keys %$stopsByRow);

  my @allBPMOrStopRows = sort {$a <=> $b} keys %bpmStopRows;

  my $curBPM = undef;
  for my $row(@allBPMOrStopRows){
    my $newBPM;
    my $bpmDiff = 0;
    if(defined $$bpmsByRow{$row}){
      $newBPM = $$bpmsByRow{$row};

      if(defined $curBPM){
        $bpmDiff = $newBPM - $curBPM;
        $bpmDiff = 0-$bpmDiff if $bpmDiff < 0;
      }
    }

    if(defined $$stopsByRow{$row}){
      $bpmDiff = defined $newBPM ? $newBPM : $curBPM;
    }

    $bpmChangeAmount += $bpmDiff;
    $curBPM = $newBPM if defined $newBPM;
  }

  return $bpmChangeAmount;
}

sub formatDDRGame($){
  my ($game) = @_;
  if($game =~ /^dance-(single|double)s?$/i){
    return lc "$1s";
  }else{
    return $game;
  }
}
sub formatDDRDiff($){
  my ($diff) = @_;
  if($diff =~ /^(Beginner)$/i){
    return "beginner";
  }elsif($diff =~ /^(Easy)$/i){
    return "basic";
  }elsif($diff =~ /^(Medium)$/i){
    return "difficult";
  }elsif($diff =~ /^(Hard)$/i){
    return "expert";
  }elsif($diff =~ /^(Expert)$/i){
    return "challenge";
  }elsif($diff =~ /^(Challenge)$/i){
    return "challenge";
  }else{
    return $diff;
  }
}

sub getStats($$$$$){
  my ($game, $diff, $rows, $bpmsByRow, $stopsByRow) = @_;

  #analysis + data-collection
  my $s = {                      %{getNoteCounts($rows)},
    GAME                      => formatDDRGame($game),
    DIFF                      => formatDDRDiff($diff),
    SONG_DUR                  => getSongDuration($rows, $bpmsByRow, $stopsByRow),
    SONG_ROW_COUNT            => getSongRowCount($rows),
    MAX_MEASURE_DENSITY       => getMaxMeasureDensity $rows,
    TOTAL_FREEZE_ROW_COUNT    => getTotalFreezeRowCount $rows,
    TOTAL_NOTE_IRREGULARITY   => getTotalNoteIrregularity $rows,
    BPM_CHANGE_AMOUNT         => getBPMChangeAmount($bpmsByRow, $stopsByRow),
  };

  #meaningful calculated values
  $$s{BPM_ROWS}                  = join ",", map {"$_=$$bpmsByRow{$_}"} sort {$a <=> $b} keys %$bpmsByRow;
  $$s{STOP_ROWS}                 = join ",", map {"$_=$$stopsByRow{$_}"} sort {$a <=> $b} keys %$stopsByRow;
  $$s{SONG_BEAT_COUNT}           = int($$s{SONG_ROW_COUNT}/$ROWS_PER_BEAT + 0.5);
  $$s{TOTAL_NOTES}               = $$s{COUNT_NOTE_ROWS} + $$s{COUNT_SHOCK_ROWS};
  $$s{TOTAL_JUMPS_SHOCKS}        = $$s{COUNT_JUMP_ROWS} + $$s{COUNT_SHOCK_ROWS};
  $$s{NOTES_PER_MIN}             = 60 * ($$s{TOTAL_NOTES}) / $$s{SONG_DUR};
  $$s{AVG_BPM}                   = 60 * ($$s{SONG_ROW_COUNT}/$ROWS_PER_BEAT) / $$s{SONG_DUR};
  $$s{MAX_DENSITY_PER_MIN}       = $$s{AVG_BPM}*$$s{MAX_MEASURE_DENSITY}/4;
  $$s{JUMPS_SHOCKS_PER_MIN}      = 60 * $$s{TOTAL_JUMPS_SHOCKS} / $$s{SONG_DUR};
  $$s{FREEZE_RATIO_10K}          = 10000 * ($$s{TOTAL_FREEZE_ROW_COUNT}/$ROWS_PER_BEAT) / $$s{SONG_BEAT_COUNT};
  $$s{BPM_CHANGE_AMOUNT_PER_MIN} = 60 * $$s{BPM_CHANGE_AMOUNT} / $$s{SONG_DUR};
  $$s{OVERALL_IRREGULARITY}      = $$s{TOTAL_NOTE_IRREGULARITY} * (1 + $$s{BPM_CHANGE_AMOUNT_PER_MIN}/1500);
  $$s{IRREG_PER_CENTISECOND}     = 100 * $$s{OVERALL_IRREGULARITY} / $$s{SONG_DUR};

  #stream
  if($game =~ /single/i){
    if($$s{NOTES_PER_MIN} >= 300){
      $$s{DDRSN2_STREAM} = ($$s{NOTES_PER_MIN}-203)*100/97;
      $$s{DDRA_STREAM} = ($$s{NOTES_PER_MIN}-139)*100/161;
    }else{
      $$s{DDRSN2_STREAM} = $$s{NOTES_PER_MIN}/3;
      $$s{DDRA_STREAM} = $$s{NOTES_PER_MIN}/3;
    }
  }elsif($game =~ /double/i){
    if($$s{NOTES_PER_MIN} >= 300){
      $$s{DDRSN2_STREAM} = ($$s{NOTES_PER_MIN}-205)*20/19;
      $$s{DDRA_STREAM} = ($$s{NOTES_PER_MIN}-183)*100/117;
    }else{
      $$s{DDRSN2_STREAM} = $$s{NOTES_PER_MIN}/3;
      $$s{DDRA_STREAM} = $$s{NOTES_PER_MIN}/3;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  #voltage
  if($$s{MAX_DENSITY_PER_MIN} >= 600){
    $$s{DDRSN2_VOLTAGE} = ($$s{MAX_DENSITY_PER_MIN}+102)*100/702;
    $$s{DDRA_VOLTAGE} = ($$s{MAX_DENSITY_PER_MIN}+594)*100/1194;
  }else{
    $$s{DDRSN2_VOLTAGE} = $$s{MAX_DENSITY_PER_MIN}/6;
    $$s{DDRA_VOLTAGE} = $$s{MAX_DENSITY_PER_MIN}/6;
  }

  #air
  if($game =~ /single/i){
    if($$s{JUMPS_SHOCKS_PER_MIN} >= 55){
      $$s{DDRSN2_AIR} = ($$s{JUMPS_SHOCKS_PER_MIN}-1)*50/27;
      $$s{DDRA_AIR} = ($$s{JUMPS_SHOCKS_PER_MIN}+36)*100/91;
    }else{
      $$s{DDRSN2_AIR} = $$s{JUMPS_SHOCKS_PER_MIN}*20/11;
      $$s{DDRA_AIR} = $$s{JUMPS_SHOCKS_PER_MIN}*20/11;
    }
  }elsif($game =~ /double/i){
    if($$s{JUMPS_SHOCKS_PER_MIN} >= 55){
      $$s{DDRSN2_AIR} = ($$s{JUMPS_SHOCKS_PER_MIN}-1)*50/27;
      $$s{DDRA_AIR} = ($$s{JUMPS_SHOCKS_PER_MIN}+35)*10/9;
    }else{
      $$s{DDRSN2_AIR} = $$s{JUMPS_SHOCKS_PER_MIN}*20/11;
      $$s{DDRA_AIR} = $$s{JUMPS_SHOCKS_PER_MIN}*20/11;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  #freeze
  if($game =~ /single/i){
    if($$s{FREEZE_RATIO_10K} >= 3500){
      $$s{DDRSN2_FREEZE} = ($$s{FREEZE_RATIO_10K}+2484)*100/5984;
      $$s{DDRA_FREEZE} = ($$s{FREEZE_RATIO_10K}+2484)*100/5984;
    }else{
      $$s{DDRSN2_FREEZE} = $$s{FREEZE_RATIO_10K}/35;
      $$s{DDRA_FREEZE} = $$s{FREEZE_RATIO_10K}/35;
    }
  }elsif($game =~ /double/i){
    if($$s{FREEZE_RATIO_10K} >= 3500){
      $$s{DDRSN2_FREEZE} = ($$s{FREEZE_RATIO_10K}+2246)*100/5746;
      $$s{DDRA_FREEZE} = ($$s{FREEZE_RATIO_10K}+2246)*100/5746;
    }else{
      $$s{DDRSN2_FREEZE} = $$s{FREEZE_RATIO_10K}/35;
      $$s{DDRA_FREEZE} = $$s{FREEZE_RATIO_10K}/35;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  #chaos
  if($game =~ /single/i){
    if($$s{IRREG_PER_CENTISECOND} >= 2000){
      $$s{DDRSN2_CHAOS} = ($$s{IRREG_PER_CENTISECOND}+21605)*100/23605;
      $$s{DDRA_CHAOS} = ($$s{IRREG_PER_CENTISECOND}+21605)*100/23605;
    }else{
      $$s{DDRSN2_CHAOS} = $$s{IRREG_PER_CENTISECOND}/20;
      $$s{DDRA_CHAOS} = $$s{IRREG_PER_CENTISECOND}/20;
    }
  }elsif($game =~ /double/i){
    if($$s{IRREG_PER_CENTISECOND} >= 2000){
      $$s{DDRSN2_CHAOS} = ($$s{IRREG_PER_CENTISECOND}+16628)*100/18628;
      $$s{DDRA_CHAOS} = ($$s{IRREG_PER_CENTISECOND}+16628)*100/18628;
    }else{
      $$s{DDRSN2_CHAOS} = $$s{IRREG_PER_CENTISECOND}/20;
      $$s{DDRA_CHAOS} = $$s{IRREG_PER_CENTISECOND}/20;
    }
  }else{
    die "ERROR: unknown game \"$game\"\n";
  }

  return $s;
}

sub parseSMFile($){
  my ($smFile) = @_;
  my $sm = readFile $smFile;

  my $smInfo = {
    bpms               => undef,
    stops              => undef,
    notesByGameDiffKey => {},
  };

  if($sm !~ /#BPMS:([^;]+);/i){
    die "ERROR: could not read BPMs from $smFile\n";
  }else{
    $$smInfo{bpms} = $1;
  }

  if($sm !~ /#STOPS:([^;]*);/i){
    die "ERROR: could not read STOPS from $smFile\n";
  }else{
    $$smInfo{stops} = $1;
  }

  my $reName = '(?:[a-zA-Z0-9\-_]+)';

  #SM files
  while($sm =~ /
    \#NOTES                  \s*:\s*
    (?<game>$reName)         \s*:\s*
    [^:]*?                   \s*:\s*
    (?<difficulty>$reName)   \s*:\s*
    [^:]*?                   \s*:\s*
    [^:]*?                   \s*:\s*
    (?<notes>[^;]+?)         ;
  /gsxi){
    my ($game, $difficulty, $notes) = ($+{game}, $+{difficulty}, $+{notes});

    my $gameDiffKey = gameDiffKey($game, $difficulty);
    $$smInfo{notesByGameDiffKey}{$gameDiffKey} = $notes;
  }

  #SSC files
  my @sscNoteSets = $sm =~ /\#NOTEDATA\s*:.*?#NOTES\s*:[^;]*;/gsi;
  for my $noteSet(@sscNoteSets){
    my $game = $1       if $noteSet =~ /\#STEPSTYPE    \s*:\s*   ($reName)   \s*;\s*/sxi;
    my $difficulty = $1 if $noteSet =~ /\#DIFFICULTY   \s*:\s*   ($reName)   \s*;\s*/sxi;
    my $notes = $1      if $noteSet =~ /\#NOTES        \s*:\s*   ([^;]+)     \s*;\s*/sxi;

    die "ERROR: missing STEPSTYPE from $smFile $noteSet\n" if not defined $game;
    die "ERROR: missing DIFFICULTY from $smFile\n" if not defined $difficulty;
    die "ERROR: missing NOTES from $smFile\n" if not defined $notes;

    my $gameDiffKey = gameDiffKey($game, $difficulty);
    $$smInfo{notesByGameDiffKey}{$gameDiffKey} = $notes;
  }

  my $gameDiffKeyCount = keys %{$$smInfo{notesByGameDiffKey}};
  if($gameDiffKeyCount == 0){
    die "ERROR: could not parse any note sets in $smFile\n";
  }

  return $smInfo;
}

#convert simfile atts like "#BPMS:" and "#STOPS:", which are by beat,
# to values like BPM_ROWS and STOP_ROWS, which are by row
sub convertValuesByBeatToValuesByRow($){
  my ($csvBeatValPairs) = @_;

  my $valsByRow = {};
  my @beatValPairs = split /,/, $csvBeatValPairs;
  for my $beatValPair(@beatValPairs){
    $beatValPair =~ s/[ \t\r\n]*//g;
    next if $beatValPair eq "";
    if($beatValPair !~ /^(\d+|\d*\.\d+)=(\d+|\d*\.\d+)$/){
      die "ERROR: invalid BEAT=VALUE entry \"$beatValPair\"\n";
    }
    my ($beat, $val) = ($1, $2);
    my $fracRow = $beat * $ROWS_PER_BEAT;
    my $row = int($fracRow + 0.5);

    my $fracDiff = $fracRow - $row;
    $fracDiff = 0 - $fracDiff if $fracDiff < 0;
    if($fracDiff > 0.001){
      my $msg = "WARNING: invalid BEAT in BPM"
        . " (not close to 1/$ROWS_PER_MEASURE note; forced to the nearest anyway)"
        . " \"$fracRow\"\n"
        ;
      print $msg;
    }

    $$valsByRow{$row} = $val;
  }
  return $valsByRow;
}

sub gameDiffKey($$){
  my ($game, $diff) = @_;
  return lc "$game-$diff";
}
sub parseGameDiffKey($){
  my ($gameDiffKey) = @_;
  if($gameDiffKey =~ /^(.+)-(.+)$/){
    return ($1, $2);
  }
}

#SM files contain a list of MEASUREs for each game-difficulty pair
#  each MEASURE is a list of 192 NOTE_ROWs (which is usually condensed as below),
#    one per line, with a comma separating MEASUREs on its own line
#
#  each NOTE_ROW contains one chracter per arrow
#    e.g.:  1100   for left-down jump
#
#  each MEASURE is also divided into 4 BEATs, which are 48 NOTE_ROWs each
#    (stepmania actively assumes 4/4 time signature for some reason,
#     instead of not having a time sig)
#
#  MEASUREs are condensed to only 4/8/12/16/24/32/48/64/192 rows where possible
#    (if a measure has only 1/32 notes, it will have 32 rows instead of 192)
#
#  this method expands it back up to 192 NOTE_ROWs per MEASURE,
#    by inserting all-zero blank rows,
#    and then joins all the rows together in a simple list, ignoring MEASURE
#
#  e.g.:
#    this measure:
#      1000
#      0100
#      0010
#      0001
#      ,
#    will expand from 4 to 192 rows, inserting 47 rows of '0000' after each of the 4 rows
#    the resulting rows will be all '0000's, except for:
#      row#0, row#48, row#96, and row#144
sub getExpandedNoteRows($){
  my ($noteSetText) = @_;
  my @measures = split /,/, $noteSetText;

  my @noteRows;
  for my $measure(@measures){
    my @lines = split /[\r\n]+/, $measure;

    s/\/\/.*// foreach @lines;            #remove comments
    s/F/0/g foreach @lines;               #remove fakes
    @lines = grep {$_ !~ /^\s*$/} @lines; #remove whitespace-only/empty lines

    for my $line(@lines){
      if($line !~ /^[01234MLFAKNH]+$/){
        die "ERROR: malformed measure row $line\n";
      }
    }

    my @collapsedMeasureRows = @lines;
    my $collapsedMeasureRowCount = @collapsedMeasureRows;

    die "ERROR: empty measure $measure\n" if $collapsedMeasureRowCount == 0;

    my $firstRow = $collapsedMeasureRows[0];
    my $emptyRow = $firstRow;
    $emptyRow =~ s/[01234MLFAKNH]/0/g;
    if($emptyRow !~ /^0+$/){
      die "ERROR: malformed first measure row $firstRow\n";
    }

    my $repeatRowCount = int($ROWS_PER_MEASURE/$collapsedMeasureRowCount);

    my @expandedMeasureRows;
    for my $row(@collapsedMeasureRows){
      if($row !~ /^[01234MLFAKNH]+$/){
        die "ERROR: malformed note row: $row\n";
      }
      push @expandedMeasureRows, $row;
      for(my $i=0; $i<$repeatRowCount-1; $i++){
        push @expandedMeasureRows, $emptyRow;
      }
    }

    if(@expandedMeasureRows != $ROWS_PER_MEASURE){
      die "ERROR: malformed measure (rowCount=$collapsedMeasureRowCount):\n$measure";
    }
    @noteRows = (@noteRows, @expandedMeasureRows);
  }

  return \@noteRows;
}

sub readFile($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n";
  my $contents = join '', <FH>;
  close FH;
  return $contents;
}

&main(@ARGV);
