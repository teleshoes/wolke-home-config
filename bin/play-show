#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

sub getShowDirs();
sub bashComplete($$);

my @MUSIC_BASE_DIRS = (
  "$ENV{HOME}/Music/sheet_music/shows/music",
  "$ENV{HOME}/Music/sheet_music/trumpet",
);
my $PLAY_DIR = "$ENV{HOME}/play";
my $SHOW_FILE = "$ENV{HOME}/show";

my @EXTS = qw(
  flac ogg opus wav mp3 m4a wma
  mkv avi m2ts mts mov mpeg mpg mp4 webm
);
my $OK_EXTS = join "|", @EXTS;

my @DEFAULT_MPV_ARGS = qw(--no-video --af=@rb:rubberband);

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

   $EXEC --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion, one per line
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline

  $EXEC [OPTS] [SHOW_NAME] SONG_NUM
  $EXEC [OPTS] [SHOW_NAME] SONG_NUM START_POS
  $EXEC [OPTS] [SHOW_NAME] SONG_NUM START_POS END_POS
    find the first song <FILE> matching <SONG_NUM> in one of:
      " . join("\n      ", map {"$_/<SHOW_NAME>"} @MUSIC_BASE_DIRS) . "
      \$PWD/
      $PLAY_DIR/
      " . join("\n      ", map {"$_/`cat $SHOW_FILE`"} @MUSIC_BASE_DIRS) . "
    play song <FILE> with mpv
      `mpv MPV_ARGS <FILE>`
        and optionally: `--start=<START_POS>`
        and optionally: `--ab-loop-a=<START_POS> --ab-loop-b=<END_POS>`

    FILE
      -must start with any number of zeros,
        followed by <SONG_NUM> (case-insensitive),
        followed by an underscore
      -must end with a dot followed by one of these exts (case insensitive):
        @EXTS

    SONG_NUM
      -any number of digits, optionally followed by a single letter
      -leading zeros are removed
      -trailing underscores are removed

    MPV_ARGS
      default options to mpv: @DEFAULT_MPV_ARGS

  POSITION_ARG
    one of:
      -a '+' sign followed by a <POSITION_ARG>
      -a '-' sign followed by a <POSITION_ARG>
      -<POSITION_HOUR_ARG>
      -<POSITION_MINUTE_ARG>
      -<POSITION_SECOND_ARG>
      -<POSITION_PERCENT_ARG>
    POSITION_HOUR_ARG
      -integer number of hours, followed by ':', followed by <POSITION_MINUTE_ARG>
    POSITION_MINUTE_ARG
      -integer number of minutes, followed by ':', followed by <POSITION_SECOND_ARG>
    POSITION_SECOND_ARG
      -fractional number of seconds
    POSITION_PERCENT_ARG
      -fractional percent, followed by a '%' sign

  OPTS
    --show=SHOW_NAME | --show SHOW_NAME
      look in sub dir SHOW_NAME of music dirs

    --song=SONG_NUM | --song SONG_NUM
    --num=SONG_NUM | --num SONG_NUM
      find files matching SONG_NUM

    --start=START_POS | --start START_POS | -ss START_POS
      -any POSITION_ARG. if given:
        -pass to mpv: `--start=<START_POS>`

    --end=END_POS | --end END_POS | -endpos END_POS
      -any POSITION_ARG. if START_POS and END_POS are both given:
        -pass to mpv: `--ab-loop-a=<START_POS>`
        -pass to mpv: `--ab-loop-b=<END_POS>`
";

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print map {"$_\n"} bashComplete($_[1], $_[2]);
    exit 0;
  }

  my $showNameRegex = '[a-zA-Z]\w*';
  my $songNumRegex = '\d+[a-z]?';
  my $fracRegex = "(?:\\d+|\\d*\\.\\d+)";
  my $timeRegex = "(\\d+:)?(\\d+:)?$fracRegex";
  my $posArgRegex = '(?:'
    . "(?:[+-]?$timeRegex)"
    . "|"
    . "(?:$fracRegex\%)"
    . ")"
  ;

  my $showNameArg = undef;
  my $songNum = undef;
  my $startPos = undef;
  my $endPos = undef;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(?:--show)=($showNameRegex)$/){
      $showNameArg = $1;
    }elsif($arg =~ /^(?:--show)$/ and @_ > 0 and $_[0] =~ /^($showNameRegex)$/){
      $showNameArg = shift @_;
    }elsif($arg =~ /^(?:--song|--num)=($songNumRegex)$/){
      $songNum = $1;
    }elsif($arg =~ /^(?:--song|--num)$/ and @_ > 0 and $_[0] =~ /^($songNumRegex)$/){
      $songNum = shift @_;
    }elsif($arg =~ /^(?:--start)=($posArgRegex)$/){
      $startPos = $1;
    }elsif($arg =~ /^(?:--start|-ss)$/ and @_ > 0 and $_[0] =~ /^($posArgRegex)$/){
      $startPos = shift @_;
    }elsif($arg =~ /^(?:--end)=($posArgRegex)$/){
      $endPos = $1;
    }elsif($arg =~ /^(?:--end|-endpos)$/ and @_ > 0 and $_[0] =~ /^($posArgRegex)$/){
      $endPos = shift @_;
    }elsif($arg =~ /^($showNameRegex)$/ and not defined $showNameArg){
      $showNameArg = $arg;
    }elsif($arg =~ /^($songNumRegex)$/ and not defined $songNum){
      $songNum = $arg;
    }elsif($arg =~ /^($posArgRegex)$/ and not defined $startPos){
      $startPos = $arg;
    }elsif($arg =~ /^($posArgRegex)$/ and not defined $endPos){
      $endPos = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if(defined $showNameArg){
    my %okShowDirs = map {$_ => 1} getShowDirs();
    if(not defined $okShowDirs{$showNameArg}){
      die "$USAGE\nERROR: unknown SHOW_NAME $showNameArg\n";
    }
  }

  if(not defined $songNum){
    die "$USAGE\nERROR: missing SONG_NUM\n";
  }
  $songNum =~ s/^0+//;
  $songNum =~ s/_+$//;

  my $showFileContents = `cat $SHOW_FILE 2>/dev/null`;
  if($showFileContents =~ /^\s*$/){
    $showFileContents = undef;
  }elsif($showFileContents =~ /^([a-zA-Z0-9_\-]+)$/){
    $showFileContents = $1;
  }else{
    die "invalid $SHOW_FILE (must be letters/numbers/dashes/underscore): $showFileContents\n";
  }


  my @dirs;

  if(defined $showNameArg){
    @dirs = (@dirs, map {"$_/$showNameArg"} @MUSIC_BASE_DIRS);
  }

  @dirs = (@dirs, ".");

  @dirs = (@dirs, $PLAY_DIR);

  if(defined $showFileContents){
    @dirs = (@dirs, map {"$_/$showFileContents"} @MUSIC_BASE_DIRS);
  }


  @dirs = grep {defined $_ and -d $_} @dirs;

  my @files;
  for my $dir(@dirs){
    @files = (@files, glob("$dir/*.*"));
  }

  my @songFiles;
  for my $file(@files){
    if($file =~ /(^|\/)0*${songNum}_.*\.(?:$OK_EXTS)$/i){
      push @songFiles, $file;
    }
  }

  my $dirFmt = join ", ", map {"\"$_\""} @dirs;
  if(@songFiles == 0){
    die "no song with SONG_NUM=\"$songNum\" found in $dirFmt\n";
  }

  my @cmd = ("mpv", @DEFAULT_MPV_ARGS, @songFiles);
  if(defined $startPos){
    @cmd = (@cmd, "--start=$startPos");
  }
  if(defined $startPos and defined $endPos){
    @cmd = (@cmd, "--ab-loop-a=$startPos");
    @cmd = (@cmd, "--ab-loop-b=$endPos");
  }

  print "@cmd\n";
  exec @cmd;
}

sub getShowDirs(){
  my @showDirs;
  for my $baseDir(@MUSIC_BASE_DIRS){
    my @dirs = `cd $baseDir/ && ls`;
    chomp foreach @dirs;
    @dirs = grep {-d "$baseDir/$_/"} @dirs;
    @showDirs = (@showDirs, @dirs);
  }
  return @showDirs;
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  while(@words > 0 and $words[0] =~ /^-/){
    shift @words;
  }

  my @showNames = getShowDirs();

  if(@words == 0){
    return (
      "-h", "--help",
      "--bash-complete",
      "--show",
      "--song", "--num",
      "--start", "-ss",
      "--end", "-endpos",
      @showNames
    );
  }

  return ();
}

&main(@ARGV);
