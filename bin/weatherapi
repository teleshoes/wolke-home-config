#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(time);
use Cpanel::JSON::XS qw();

sub readCache($);
sub buildCurrentCache($);
sub buildForecastCache($);
sub fetchWeather($$$);
sub getLatestCacheFile($$);
sub getApiKey();
sub readSecrets();
sub decrypt($);
sub readFile($);
sub writeFile($$);
sub parseJson($);
sub absdiff($$);
sub nowMillis();

my $EXEC = basename $0;

my $API_URL_BASE = "https://api.weatherapi.com/v1";

my $SECRETS_FILE = "$ENV{HOME}/.secrets";
my $SECRETS_PREFIX = "weatherapi";
my $SECRETS_KEYS_REGEX = join("|", qw(apikey));
my %SECRETS_ENC_KEYS = map {$_ => 1} qw(apikey);

my $DIR_BASE = "$ENV{HOME}/.cache/weatherapi";
my $DIR_JSON = "$DIR_BASE/json";
my $DIR_CACHE = "$DIR_BASE/cache";

my @LOCATION_ARR = (
  [islip => "11751" => ["islip", "11751", "home"]],
);

my @LOCATION_NAMES = map {$$_[0]} @LOCATION_ARR;
my %LOCATION_QUERY_BY_NAME = map {$$_[0] => $$_[1]} @LOCATION_ARR;
my %LOCATION_SYNS_BY_NAME = map {$$_[0] => $$_[2]} @LOCATION_ARR;
my %LOCATION_NAME_BY_SYN = map {
  my $name=$_; map {$_ => $name} @{$LOCATION_SYNS_BY_NAME{$name}}
} @LOCATION_NAMES;
my @LOCATION_SYNS = (map {@{$LOCATION_SYNS_BY_NAME{$_}}} @LOCATION_NAMES);

my $LOCATION_SYN_REGEX = join("|", @LOCATION_NAMES);
my $DEFAULT_LOCATION = @LOCATION_NAMES > 0 ? $LOCATION_NAMES[0] : undef;

my $USAGE = "Usage:
  $EXEC -h|--help
    show this message

  $EXEC [OPTS] -g | --get
    -read the latest cached current and latest cached forecast for today
    -check if either cache is more than one hour out of date
      -fail if out-of-date
      -otherwise, print:
        CUR_TEMP_F (MAX_TEMP_F | MIN_TEMP_F) CONDITION

  $EXEC [OPTS] -f | --fetch
    -fetch the current and forecast JSON from $API_URL_BASE
    -parse last_updated_epoch in JSON
    -format LAST_UPDATED_DTM as YYYY-MM-DD_HHMMSS
    -cache JSON in $DIR_JSON/<LAST_UPDATED_DTM>_<LOCATION_NAME>_<current|forecast>_<NOW_MILLIS>.json
    -parse JSON and cache parsed info in:
      $DIR_CACHE/<LOCATION_NAME>_current
      $DIR_CACHE/<LOCATION_NAME>_<YYYY-MM-DD>

  OPTS
    --location=<LOCATION_SYN> | --<LOCATION_SYN> | <LOCATION_SYN>
      the location to fetch
      (default is " . (defined $DEFAULT_LOCATION ? $DEFAULT_LOCATION : "undefined") . ")

      LOCATION_NAME => LOCATION_SYN\n" . join("",
        map {sprintf "      %-13s => %s\n", $_, join(" ", @{$LOCATION_SYNS_BY_NAME{$_}})}
        @LOCATION_NAMES
      ) . "
";

my $MODE_GET = "get";
my $MODE_FETCH = "fetch";

my $API_METHOD_CURRENT = "current";
my $API_METHOD_FORECAST = "forecast";

sub main(@){
  my $mode = $MODE_FETCH;
  my $locationSyn = $DEFAULT_LOCATION;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-g|--get)$/){
      $mode = $MODE_GET;
    }elsif($arg =~ /^(?:--location=|--)?($LOCATION_SYN_REGEX)$/){
      $locationSyn = lc $1;
    }else{
      die "ERROR: unknown arg $arg\n";
    }
  }

  my $locationName = undef;
  $locationName = $LOCATION_NAME_BY_SYN{$locationSyn} if defined $locationSyn;

  if($mode eq $MODE_GET){
    die "ERROR: missing location\n" if not defined $locationName;
    my $val = readCache($locationName);
    die "ERROR: cache is out of date for $locationName\n" if not defined $val;
    print "$val\n";
  }elsif($mode eq $MODE_FETCH){
    die "ERROR: missing location\n" if not defined $locationName;
    my $apiKey = getApiKey();
    fetchWeather($apiKey, $locationName, $API_METHOD_CURRENT);
    fetchWeather($apiKey, $locationName, $API_METHOD_FORECAST);

    system "rm -f $DIR_CACHE/${locationName}_*";
    buildCurrentCache($locationName);
    buildForecastCache($locationName);
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub readCache($){
  my ($locationName) = @_;
  my $nowEpoch = int(time);
  my $todayDate = `date +%Y-%m-%d --date=\@$nowEpoch`;
  chomp $todayDate;

  my $curCacheFile = "$DIR_CACHE/${locationName}_current";
  my $curTodayFile = "$DIR_CACHE/${locationName}_${todayDate}";

  if(not -f $curCacheFile or not -f $curTodayFile){
    return undef;
  }

  my $cur = readFile $curCacheFile;
  my $today = readFile $curTodayFile;

  my $nowCur = $cur =~ /now=(\d+)/ ? $1 : 0;
  my $nowToday = $today =~ /now=(\d+)/ ? $1 : 0;

  my $updatedCur = $cur =~ /updated=(\d+)/ ? $1 : 0;
  my $updatedToday = $today =~ /updated=(\d+)/ ? $1 : 0;

  if(absdiff($nowCur, $nowEpoch) > 15*60 or absdiff($nowToday, $nowEpoch) > 15*60){
    #cache is out-of-date and needs to be fetched
    return undef;
  }
  if(absdiff($updatedCur, $nowEpoch) > 60*60 or absdiff($updatedToday, $nowEpoch) > 60*60){
    #forecast is out-of-date
    return undef;
  }

  my $temp = $cur =~ /tempF=(\d+)/ ? $1 : "?";
  my $cond = $today =~ /cond=(.+)/ ? $1 : "?";
  my $tempMax = $today =~ /maxtempF=(\d+)/ ? $1 : "?";
  my $tempMin = $today =~ /mintempF=(\d+)/ ? $1 : "?";

  return sprintf "%2dÂ° [%2d | %2d] $cond", $temp, $tempMax, $tempMin;
}

sub buildCurrentCache($){
  my ($locationName) = @_;
  system "mkdir", "-p", $DIR_CACHE if not -d $DIR_CACHE;

  my $latestCurrent = parseJson(readFile(getLatestCacheFile($locationName, $API_METHOD_CURRENT)));

  my $nowEpoch = int(time);

  if(not defined $latestCurrent or not defined $$latestCurrent{current}){
    die "ERROR: could not parse current JSON for $locationName\n";
  }

  my $location = $$latestCurrent{location};
  my $current = $$latestCurrent{current};
  my $cond = $$current{condition};

  my $epoch = defined $location ? $$location{localtime_epoch} : undef;
  my $updatedEpoch = $$current{last_updated_epoch};
  my $condCode = defined $cond ? $$cond{code} : undef;
  my $condIcon = defined $cond ? $$cond{icon} : undef;
  my $condText = defined $cond ? $$cond{text} : undef;
  my $tempF = $$current{temp_f};
  my $windMPH = $$current{wind_mph};

  my $cacheFile = "$DIR_CACHE/${locationName}_current";
  writeFile $cacheFile, ""
    . "tempF=$tempF\n"
    . "condCode=$condCode\n"
    . "condIcon=$condIcon\n"
    . "condText=$condText\n"
    . "windMPH=$windMPH\n"
    . "now=$epoch\n"
    . "updated=$updatedEpoch\n"
  ;
}

sub buildForecastCache($){
  my ($locationName) = @_;
  system "mkdir", "-p", $DIR_CACHE if not -d $DIR_CACHE;

  my $latestForecast = parseJson(readFile(getLatestCacheFile($locationName, $API_METHOD_FORECAST)));

  my $nowEpoch = int(time);

  if(not defined $latestForecast or not defined $$latestForecast{forecast}){
    die "ERROR: could not parse forecast JSON for $locationName\n";
  }
  my $location = $$latestForecast{location};
  my $current = $$latestForecast{current};
  my $forecast = $$latestForecast{forecast};
  my @forecastDays = @{$$forecast{forecastday}};

  for my $forecastDay(@forecastDays){
    my $day = $$forecastDay{day};
    my $epoch = defined $location ? $$location{localtime_epoch} : undef;
    my $updatedEpoch = $$current{last_updated_epoch};

    my $date = $$forecastDay{date};
    my $cond = $$day{condition};

    my $condCode = defined $cond ? $$cond{code} : undef;
    my $condIcon = defined $cond ? $$cond{icon} : undef;
    my $condText = defined $cond ? $$cond{text} : undef;
    my $minTempF = $$day{mintemp_f};
    my $maxTempF = $$day{maxtemp_f};
    my $maxWindMPH = $$day{maxwind_mph};

    my $cacheFile = "$DIR_CACHE/${locationName}_${date}";
    writeFile $cacheFile, ""
      . "maxtempF=$maxTempF\n"
      . "mintempF=$minTempF\n"
      . "condCode=$condCode\n"
      . "condIcon=$condIcon\n"
      . "condText=$condText\n"
      . "maxWindMPH=$maxWindMPH\n"
      . "now=$epoch\n"
      . "updated=$updatedEpoch\n"
    ;
  }
}

sub fetchWeather($$$){
  my ($apiKey, $locationName, $method) = @_;
  system "mkdir", "-p", $DIR_JSON if not -d $DIR_JSON;

  my $query = $LOCATION_QUERY_BY_NAME{$locationName};
  my $url = "$API_URL_BASE/$method.json?key=$apiKey&q=$query";
  my $json = `curl --silent '$url'`;
  my $lastUpdatedEpoch = undef;
  if($json =~ /"last_updated_epoch":(\d+)/){
    $lastUpdatedEpoch = $1;
  }else{
    die "ERROR: could not parse $method weather for $query\n";
  }
  my $lastUpdatedFmt = `date --date=\@$lastUpdatedEpoch +%Y-%m-%d_%H%M%S`;
  chomp $lastUpdatedFmt;

  my $nowMillis = nowMillis();
  my $cacheFile = "$DIR_JSON/${lastUpdatedFmt}_${locationName}_${method}_${nowMillis}.json";

  writeFile($cacheFile, $json);
  print "cached $cacheFile\n";
}

sub getLatestCacheFile($$){
  my ($locationName, $method) = @_;
  my @files = sort grep {-f $_} glob "$DIR_JSON/????-??-??_??????_${locationName}_${method}_*.json";
  die "ERROR: no file found for $locationName $method\n" if @files == 0;
  return $files[-1];
}

sub getApiKey(){
  my $secrets = readSecrets();
  if(not defined $$secrets{apikey}){
    die "ERROR: could not read $SECRETS_PREFIX.apikey in secrets\n"
  }
  return $$secrets{apikey};
}

sub readSecrets(){
  my @lines = `cat $SECRETS_FILE 2>/dev/null`;
  my $secrets = {};
  for my $line(@lines){
    if($line =~ /^$SECRETS_PREFIX\.($SECRETS_KEYS_REGEX)\s*=\s*(.+)$/){
      $$secrets{$1} = $2;
    }
  }
  for my $key(sort keys %$secrets){
    $$secrets{$key} = decrypt $$secrets{$key} if defined $SECRETS_ENC_KEYS{$key};
  }
  return $secrets;
}

sub decrypt($){
  my ($s) = @_;
  open GPG, "-|", "gpg-sym", $s or die "could not run gpg-sym\n";
  my @contents = <GPG>;
  close GPG;
  die "error running gpg-sym\n$!\n" if $? != 0;
  my $value = join '', @contents;
  chomp $value;
  return $value;
}

sub readFile($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $contents = join '', <$fh>;
  close $fh;
  return $contents;
}

sub writeFile($$){
  my ($file, $contents) = @_;
  open my $fh, "> $file" or die "ERROR: could not write $file\n$!\n";
  print $fh $contents;
  close $fh;
}
sub parseJson($){
  my ($jsonStr) = @_;
  return Cpanel::JSON::XS->new->utf8->decode($jsonStr);
}

sub absdiff($$){
  my ($val1, $val2) = @_;
  my $diff = $val2 - $val1;
  $diff = 0 - $diff if $diff < 0;
  return $diff;
}

sub nowMillis(){
  return int(time*1000.0 + 0.5)
}

&main(@ARGV);
