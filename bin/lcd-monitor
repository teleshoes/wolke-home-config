#!/usr/bin/perl
use strict;
use warnings;

sub anim($$$$$);
sub pyeconet($$$$$);
sub pylitterbot($$$$$);
sub house($$$$$);

sub readPyeconet();
sub readPylitterbot();

sub calculateFramebuf($$$$);
sub parseDevInfo($);
sub mtime($);

my $PYECONET_LOG_DIR = "$ENV{HOME}/.cache/logs/pyeconet";
my $PYLITTERBOT_LOG_DIR = "$ENV{HOME}/.cache/logs/pylitterbot-monitor";

my $DISPLAYS = [
  {name=>"anim",        devName=>"lcd5", markupArgsSub=>\&anim,        widthPercent=>50},
  {name=>"pyeconet",    devName=>"lcd5", markupArgsSub=>\&pyeconet,    widthPercent=>50},
  {name=>"pylitterbot", devName=>"lcd1", markupArgsSub=>\&pylitterbot, widthPercent=>100},
  {name=>"house",       devName=>"lcd6", markupArgsSub=>\&house,       widthPercent=>100},
];

my @DISPLAY_NAMES = map {$$_{name}} @$DISPLAYS;
my %DISPLAYS_BY_NAME = map {$$_{name} => $_} @$DISPLAYS;

my $USAGE = "Usage:
  $0 -h | --help
    show this message

  $0 [OPTS] [DISPLAY_EVENT_NAME DISPLAY_EVENT_NAME ..]
    -run pico-lcd-msg for configured displays
    -update /tmp-lcd-monitor-count

    DISPLAY_EVENT_NAME = " . join(" | ", @DISPLAY_NAMES) . "
      if not given, all are used

  OPTS
    --dev=LCD_DEV_NAME
      override LCD device for all display events
";

sub main(@){
  my @displayEventNames;
  my $overrideDevName = undef;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^--dev=(\w+)$/){
      $overrideDevName = $1;
    }elsif(defined $DISPLAYS_BY_NAME{$arg}){
      push @displayEventNames, $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if(@displayEventNames == 0){
    @displayEventNames = @DISPLAY_NAMES;
  }

  my $runCount = `cat /tmp/lcd-monitor-count 2>/dev/null`;
  $runCount = 0 if $runCount !~ /^\d+$/;
  $runCount++;
  system "echo $runCount > /tmp/lcd-monitor-count";

  my $devices = {};
  for my $name(@displayEventNames){
    my $displayInfo = $DISPLAYS_BY_NAME{$name};
    my $devName = $$displayInfo{devName};
    $devName = $overrideDevName if defined $overrideDevName;
    if(not defined $$devices{$devName}){
      my $devInfoStr = `pico-lcd-msg --quiet --max-time 3 --dev=$devName info`;
      my $devInfo = parseDevInfo $devInfoStr;
      $$devInfo{curWidthPercent} = 0;

      $$devices{$devName} = $devInfo;
    }
  }

  my @pids;
  for my $name(@displayEventNames){
    my $displayInfo = $DISPLAYS_BY_NAME{$name};
    my $devName = $$displayInfo{devName};
    $devName = $overrideDevName if defined $overrideDevName;
    my $devInfo = $$devices{$devName};
    my %btnCounts = %{$$devInfo{btnCounts}};

    my $modeBtnCount = 0;
    $modeBtnCount = $btnCounts{B1} if defined $btnCounts{B1};
    $modeBtnCount = $btnCounts{Y} if defined $btnCounts{Y};
    my $isLandscape = $$devInfo{degrees} % 180 == 0;

    my $framebuf = calculateFramebuf(
      $$displayInfo{widthPercent}, $$devInfo{curWidthPercent}, $$devInfo{lcd}, $isLandscape);

    #move the next display over
    $$devInfo{curWidthPercent} += $$displayInfo{widthPercent};


    my ($w, $h) = ($1, $2) if $framebuf =~ /^(\d+)x(\d+)/;
    ($w, $h) = ($h, $w) if not $isLandscape;

    my @markupArgs = &{$$displayInfo{markupArgsSub}}(
      $w, $h, $isLandscape, $modeBtnCount, $runCount);

    my $pid = fork();
    push @pids, $pid;
    if(not $pid){
      system "pico-lcd-msg",
        @markupArgs,
        "--dev=$devName",
        "--framebuf=$framebuf",
        "--quiet",
        "--max-time", 3,
      ;
      exit 0;
    }
  }
  waitpid $_, 0 foreach @pids;
}

sub anim($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my @anim;
  if($modeBtnCount % 2 == 0){
    @anim = qw(1 2 3 4 5 4 3 2 3 4 5 4 3 2 3 4 5 4 3 2 1);
  }else{
    @anim = qw(6 7 8 7 8 6);
  }

  my $idx = $runCount % @anim;
  my $frame = $anim[$idx];
  my $file;
  if($isLandscape){
    $file = "$ENV{HOME}/Pictures/ascii/anim/landscape/$frame";
  }else{
    $file = "$ENV{HOME}/Pictures/ascii/anim/portrait/$frame";
  }

  return ($file, "--hspace=0", "--vspace=2");
}

sub pyeconet($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my $tick = $runCount % 2 == 0 ? 1 : 0;

  my $dateOut = `date '+%Y-%m-%d %I:%M:%S %p %a %b'`;
  if($dateOut !~ /^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d) (AM|PM) (\w+) (\w+)$/){
    die "ERROR: could not parse date $dateOut\n";
  }
  my ($y, $m, $d, $hr, $min, $sec, $ampm, $day, $mon) = ($1, $2, $3, $4, $5, $6, $7, $8, $9);

  my $info = readPyeconet();

  my $availFmt = "!size=7!";
  my $tempFmt = "!size=5!";
  if(defined $info){
    $availFmt .= $$info{avail} == 100
                   ? "!color=white!OK"
                   : "!color=red!" . sprintf("%2s%%", $$info{avail});
    $tempFmt .= "!color=white!" . sprintf("%3sF", $$info{targetTemp});

    $tempFmt .= '!size=5!!color=green! *' if $$info{running} =~ /true/i;
  }else{
    $availFmt .= "!color=red!ERR";
    $tempFmt .= "!color=red!???";
  }

  my $dateFmt = "!size=1!!n!!color=green!!size=10!$hr!n!$min!vspace=0!!n!!size=2!!color=white!$day $mon $d!n!$hr:$min:$sec";

  my $tickColor = $tick ? "blue" : "white";
  my $tickFmt = "!y=53!!x=0!!size=2!!color=$tickColor!~";

  my $markup = "$availFmt!n!$tempFmt!n!$dateFmt$tickFmt";
  return $markup;
}

sub pylitterbot($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my $tick = $runCount % 2 == 0 ? 1 : 0;

  my $info = readPylitterbot();

  my $markup;
  if(defined $info){
    my $statusFmt = $$info{status};
    $statusFmt =~ s/^LitterBoxStatus\.//;
    $statusFmt = "!color=white!!size=5!$statusFmt";

    my $barW = 320;
    my $barH = 50;

    my $wasteInt = sprintf("%d", $$info{waste});
    my ($wasteFG, $wasteBG) = $wasteInt >= 75 ? ("red", "white") : ("green", "white");
    my $wasteFmt = ""
      . "!bar=${barW},${barH},$wasteInt,$wasteFG,$wasteBG!"
      . "!shift=-${barW}x0!!shift=20x10!" #reset cursor, then indent label
      . "!color=black!!size=4!WASTE   " . sprintf("%3d%%", $wasteInt)
    ;

    my $litterInt = sprintf("%d", $$info{litter});
    my ($litterFG, $litterBG) = $litterInt <= 75 ? ("white", "red") : ("green", "white");
    my $litterFmt = ""
      . "!bar=${barW},${barH},$litterInt,$litterFG,$litterBG!"
      . "!shift=-${barW}x0!!shift=20x10!" #reset cursor, then indent label
      . "!color=black!!size=4!LITTER  " . sprintf("%3d%%", $litterInt)
    ;

    $markup = ""
            . "$statusFmt!n!"
            . "!shift=0x10!"
            . "$wasteFmt!n!"
            . "!shift=0x30!"
            . "$litterFmt!n!"
            . "!shift=0x15!"
            . "!size=3!!color=white!$$info{date} =(^.^)= !n!"
            . "$$info{time}     m m"
    ;
  }else{
    $markup = "!size=9!!color=red!ERROR";
  }

  return $markup;
}

sub house($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my $tick = $runCount % 2 == 0 ? 1 : 0;

  my $pyeconetInfo = readPyeconet();
  my $pylitterbotInfo = readPylitterbot();

  my $ecoAvailFmt = "";
  if(defined $pyeconetInfo){
    $ecoAvailFmt .= $$pyeconetInfo{avail} == 100 ? "!color=white!" : "!color=red!";
    $ecoAvailFmt .= $$pyeconetInfo{avail};
  }else{
    $ecoAvailFmt .= "!color=red!???";
  }

  my $lrWasteFmt = "";
  if(defined $pylitterbotInfo){
    $lrWasteFmt .= $$pylitterbotInfo{waste} >= 70 ? "!color=red!" : "!color=white!";
    $lrWasteFmt .= $$pylitterbotInfo{waste};
  }else{
    $lrWasteFmt .= "!color=red!???";
  }

  my $dateOut = `date '+%Y-%m-%d %I:%M:%S %p'`;
  if($dateOut !~ /^(\d\d\d\d-\d\d-\d\d) (\d\d:\d\d:\d\d) (AM|PM)$/){
    die "ERROR: could not parse date $dateOut\n";
  }
  my ($date, $time12, $ampm) = ($1, $2, $3);
  my $time = "$time12$ampm";

  my $anim;
  if($tick){
    $anim = "!size=2!!color=green!"
      . '                 /\_/\   !n!'
      . '                =>^,^<=   !n!'
      . '                  / \   / !n!'
      . '                 (___)_/ !n!'
    ;
  }else{
    $anim = "!size=2!!color=green!"
      . '                 /\_/\   !n!'
      . '                =>^,^<=  !n!'
      . '                  / \  \ !n!'
      . '                 (___)_/ !n!'
    ;
  }

  my $markup = ""
    . "!color=white!!size=5!WATER:$ecoAvailFmt%!n!"
    . "!color=white!!size=5!KITTY:$lrWasteFmt%!n!"
    . $anim
    . "!color=green!!size=3!$date!n!"
    . "!color=green!!size=5!$time!n!"
  ;

  return $markup;
}

sub readPyeconet(){
  my @logFiles = sort {$b cmp $a} grep {-f $_} glob "$PYECONET_LOG_DIR/*.log";
  my $logFile = @logFiles > 0 ? $logFiles[0] : undef;

  if(not defined $logFile){
    return undef;
  }

  my $mtime = mtime $logFile;
  my $elapsedS = time - $mtime;

  if($elapsedS < -1 or $elapsedS > 60){
    return undef;
  }

  my $info = defined $logFile ? `cat '$logFile'` : undef;
  my ($avail, $targetTemp, $running);
  if(defined $info){
    $avail = $1 if $info =~ /^tank_hot_water_availability: (\d+)$/m;
    $targetTemp = $1 if $info =~ /^set_point: (\d+)$/m;
    $running = $1 if $info =~ /^running: (\w+)$/m;
  }

  return {
    avail      => $avail,
    targetTemp => $targetTemp,
    running    => $running,
  };
}

sub readPylitterbot(){
  my @logFiles = sort {$b cmp $a} grep {-f $_} glob "$PYLITTERBOT_LOG_DIR/*.log";
  my $logFile = @logFiles > 0 ? $logFiles[0] : undef;

  if(not defined $logFile){
    return undef;
  }

  my $mtime = mtime $logFile;
  my $elapsedS = time - $mtime;

  if($elapsedS < -1 or $elapsedS > 60){
    return undef;
  }

  my $info = `tail -1 '$logFile'`;
  my ($date, $time, $name, $serial, $status, $litter, $waste);
  if($info =~ /^
     (\d\d\d\d-\d\d-\d\d)
     T
     (\d\d:\d\d:\d\d)
     \.\d\d\d
     ,([^,]+)
     ,(\w+)
     ,status=([^,]+)
     ,litter=(\d+|\d*\.\d+)
     ,waste=(\d+|\d*\.\d+)
  /x){
    ($date, $time, $name, $serial, $status, $litter, $waste) = ($1, $2, $3, $4, $5, $6, $7);
  }else{
    return undef;
  }

  return {
    date     => $date,
    time     => $time,
    name     => $name,
    serial   => $serial,
    status   => $status,
    litter   => $litter,
    waste    => $waste,
  };
}

sub calculateFramebuf($$$$){
  my ($widthPct, $curWidthPct, $lcdGeometry, $isLandscape) = @_;

  my ($w, $h) = ($1, $2) if $lcdGeometry =~ /^(\d+)x(\d+)$/;
  my $fbW = int($w * $widthPct / 100.0);
  my $fbH = $h;

  my $fbX = int($w * $curWidthPct / 100.0);
  my $fbY = 0;

  if(not $isLandscape){
    ($fbW, $fbH) = ($fbH, $fbW);
    ($fbX, $fbY) = ($fbY, $fbX);
  }

  return "${fbW}x${fbH}+${fbX}+${fbY}";
}

sub parseDevInfo($){
  my ($devInfoStr) = @_;
  my $devInfo = {};
  if($devInfoStr =~ /^buttons: (.+)$/m){
    my @btnStrs = split /,/, $1;
    $$devInfo{btnCounts} = {};
    for my $btnStr(@btnStrs){
      $$devInfo{btnCounts}{$1} = $2 if $btnStr =~ /^\s*(\w+)\s*=\s*(\d+)\s*$/;
    }
  }
  if($devInfoStr =~ /lcd: (\d+x\d+)/){
    $$devInfo{lcd} = $1;
  }
  if($devInfoStr =~ /^orientation: (\d+) degrees$/m){
    $$devInfo{degrees} = $1;
  }

  return $devInfo;
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  return $stat[9];
}

&main(@ARGV);
