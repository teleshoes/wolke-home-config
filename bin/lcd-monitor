#!/usr/bin/perl
use strict;
use warnings;

sub anim($$$$$);
sub pyeconet($$$$$);
sub pylitterbot($$$$$);
sub house($$$$$);

sub readPyeconet();
sub readPylitterbot();

sub calculateFramebuf($$$$);
sub readDevInfoCache($);
sub writeDevInfoCache($$);
sub parseDevInfo($);
sub mtime($);

my $DEV_INFO_CACHE_DIR = "$ENV{HOME}/.cache/pico-lcd-dev-info";
my $PYECONET_LOG_DIR = "$ENV{HOME}/.cache/logs/pyeconet";
my $PYLITTERBOT_LOG_DIR = "$ENV{HOME}/.cache/logs/pylitterbot-monitor";

my $DISPLAYS_ARR = [
  #NAME           DEV_NAME MARKUP_SUB     DEFAULT_LCD FRAMEBUF_CFG
  ["anim",        "bath1", \&anim,        "240x320",  [0, 50]],
  ["pyeconet",    "bath1", \&pyeconet,    "240x320",  [50, 100]],
  ["pylitterbot", "bed2",  \&pylitterbot, "320x240",  [0, 100]],
  ["house",       "bath2", \&house,       "320x240",  [0, 100]],
];
my $DISPLAYS = [map {
  {name=>$$_[0], devName=>$$_[1], markupSub=>$$_[2], defaultLCD=>$$_[3], framebufCfg=>$$_[4]}
} @$DISPLAYS_ARR];

my @DISPLAY_NAMES = map {$$_{name}} @$DISPLAYS;
my %DISPLAYS_BY_NAME = map {$$_{name} => $_} @$DISPLAYS;

my $USAGE = "Usage:
  $0 -h | --help
    show this message

  $0 [OPTS] [DISPLAY_EVENT_NAME DISPLAY_EVENT_NAME ..]
    -run pico-lcd-msg for configured displays
    -update /tmp-lcd-monitor-count

    DISPLAY_EVENT_NAME = " . join(" | ", @DISPLAY_NAMES) . "
      if not given, all are used

  OPTS
    --dev=LCD_DEV_NAME
      override LCD device for all display events
";

sub main(@){
  my @displayEventNames;
  my $overrideDevName = undef;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^--dev=(\w+)$/){
      $overrideDevName = $1;
    }elsif(defined $DISPLAYS_BY_NAME{$arg}){
      push @displayEventNames, $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if(@displayEventNames == 0){
    @displayEventNames = @DISPLAY_NAMES;
  }

  my $runCount = `cat /tmp/lcd-monitor-count 2>/dev/null`;
  $runCount = 0 if $runCount !~ /^\d+$/;
  $runCount++;
  system "echo $runCount > /tmp/lcd-monitor-count";

  my @pids;
  for my $name(@displayEventNames){
    my $displayInfo = $DISPLAYS_BY_NAME{$name};
    my $devName = $$displayInfo{devName};
    $devName = $overrideDevName if defined $overrideDevName;

    my $devInfo = readDevInfoCache($devName);

    my $modeBtnCount = 0;
    if(defined $$devInfo{btnCounts}){
      $modeBtnCount = $$devInfo{btnCounts}{B1} if defined $$devInfo{btnCounts}{B1};
      $modeBtnCount = $$devInfo{btnCounts}{Y} if defined $$devInfo{btnCounts}{Y};
      $modeBtnCount = $$devInfo{btnCounts}{TL} if defined $$devInfo{btnCounts}{TL};
    }

    #previous display LCD size+orientation, or default for display config
    my $lcd = defined $$devInfo{lcd} ? $$devInfo{lcd} : $$displayInfo{defaultLCD};
    my ($lcdW, $lcdH) = ($1, $2) if $lcd =~ /^(\d+)x(\d+)$/;
    my $isLandscape = $lcdW < $lcdH ? 0 : 1;

    my $framebufCfg = $$displayInfo{framebufCfg};
    my ($fbLeftPct, $fbRightPct) = @$framebufCfg;

    my $framebuf = calculateFramebuf($fbLeftPct, $fbRightPct, $lcd, $isLandscape);
    my ($w, $h) = ($1, $2) if $framebuf =~ /^(\d+)x(\d+)/;
    ($w, $h) = ($h, $w) if not $isLandscape;

    my @markupArgs = &{$$displayInfo{markupSub}}(
      $w, $h, $isLandscape, $modeBtnCount, $runCount);

    my $pid = fork();
    push @pids, $pid;
    if(not $pid){
      my @cmd = ("pico-lcd-msg",
        @markupArgs,
        "--dev=$devName",
        "--framebuf=$framebuf",
        "--quiet",
        "--max-time", 3,
      );
      print "@cmd\n";

      open my $cmdH, "-|", @cmd or die "ERROR: '@_\n' failed\n";
      my $out = join '', <$cmdH>;
      close $cmdH;

      writeDevInfoCache($devName, $out);
      exit 0;
    }
  }
  waitpid $_, 0 foreach @pids;
}

sub anim($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my @anim;
  if($modeBtnCount % 2 == 0){
    @anim = qw(1 2 3 4 5 4 3 2 3 4 5 4 3 2 3 4 5 4 3 2 1);
  }else{
    @anim = qw(6 7 8 7 8 6);
  }

  my $idx = $runCount % @anim;
  my $frame = $anim[$idx];
  my $file;
  if($isLandscape){
    $file = "$ENV{HOME}/Pictures/ascii/anim/landscape/$frame";
  }else{
    $file = "$ENV{HOME}/Pictures/ascii/anim/portrait/$frame";
  }

  return ($file, "--hspace=0", "--vspace=2");
}

sub pyeconet($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my $tick = $runCount % 2 == 0 ? 1 : 0;

  my $dateOut = `date '+%Y-%m-%d %I:%M:%S %p %a %b'`;
  if($dateOut !~ /^(\d\d\d\d)-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d) (AM|PM) (\w+) (\w+)$/){
    die "ERROR: could not parse date $dateOut\n";
  }
  my ($y, $m, $d, $hr, $min, $sec, $ampm, $day, $mon) = ($1, $2, $3, $4, $5, $6, $7, $8, $9);

  my $info = readPyeconet();

  my $availFmt = "!size=7!";
  my $tempFmt = "!size=5!";
  if(defined $info){
    $availFmt .= $$info{avail} == 100
                   ? "!color=white!OK"
                   : "!color=red!" . sprintf("%2s%%", $$info{avail});
    $tempFmt .= "!color=white!" . sprintf("%3sF", $$info{targetTemp});

    $tempFmt .= '!size=5!!color=green! *' if $$info{running} =~ /true/i;
  }else{
    $availFmt .= "!color=red!ERR";
    $tempFmt .= "!color=red!???";
  }

  my $dateFmt = "!size=1!!n!!color=green!!size=10!$hr!n!$min!vspace=0!!n!!size=2!!color=white!$day $mon $d!n!$hr:$min:$sec";

  my $tickColor = $tick ? "blue" : "white";
  my $tickFmt = "!y=53!!x=0!!size=2!!color=$tickColor!~";

  my $markup = "$availFmt!n!$tempFmt!n!$dateFmt$tickFmt";
  return $markup;
}

sub pylitterbot($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my $tick = $runCount % 2 == 0 ? 1 : 0;

  my $info = readPylitterbot();

  my $markup;
  if(defined $info){
    my $statusFmt = $$info{status};
    $statusFmt =~ s/^LitterBoxStatus\.//;
    $statusFmt = "!color=white!!size=5!$statusFmt";

    my $barW = 320;
    my $barH = 50;

    my $wasteInt = sprintf("%d", $$info{waste});
    my ($wasteFG, $wasteBG) = $wasteInt >= 75 ? ("red", "white") : ("green", "white");
    my $wasteFmt = ""
      . "!bar=${barW},${barH},$wasteInt,$wasteFG,$wasteBG!"
      . "!shift=-${barW}x0!!shift=20x10!" #reset cursor, then indent label
      . "!color=black!!size=4!WASTE   " . sprintf("%3d%%", $wasteInt)
    ;

    my $litterFmt = "";
    my $litterInt = sprintf("%d", $$info{litter});
    if($litterInt < 90){
      $litterFmt = ""
        . "!color=red!!rect=${barW}x${barH}!"
        . "!shift=-${barW}x0!!shift=20x10!" #reset cursor, then indent label
        . "!color=black!!size=4!HPR LOW " . sprintf("%3d%%", $litterInt)
    }else{
      $litterFmt = ""
        . "!color=white!!rect=${barW}x${barH}!"
        . "!shift=-${barW}x0!!shift=20x10!" #reset cursor, then indent label
        . "!color=black!!size=4!LTR OK  " . sprintf("%3d%%", $litterInt)
    }

    $markup = ""
            . "$statusFmt!n!"
            . "!shift=0x10!"
            . "$wasteFmt!n!"
            . "!shift=0x30!"
            . "$litterFmt!n!"
            . "!shift=0x15!"
            . "!size=3!!color=white!$$info{date} =(^.^)= !n!"
            . "$$info{time}     m m"
    ;
  }else{
    $markup = "!size=9!!color=red!ERROR";
  }

  return $markup;
}

sub house($$$$$){
  my ($w, $h, $isLandscape, $modeBtnCount, $runCount) = @_;
  my $tick = $runCount % 2 == 0 ? 1 : 0;

  my $pyeconetInfo = readPyeconet();
  my $pylitterbotInfo = readPylitterbot();

  my $ecoAvailFmt = "";
  if(defined $pyeconetInfo){
    $ecoAvailFmt .= $$pyeconetInfo{avail} == 100 ? "!color=white!" : "!color=red!";
    $ecoAvailFmt .= sprintf "%3d", $$pyeconetInfo{avail};
  }else{
    $ecoAvailFmt .= "!color=red!???";
  }

  my $lrWasteFmt = "";
  if(defined $pylitterbotInfo){
    $lrWasteFmt .= $$pylitterbotInfo{waste} >= 70 ? "!color=red!" : "!color=white!";
    $lrWasteFmt .= sprintf "%3d", $$pylitterbotInfo{waste};
  }else{
    $lrWasteFmt .= "!color=red!???";
  }

  my $dateOut = `date '+%Y-%m-%d %I:%M:%S %p'`;
  if($dateOut !~ /^(\d\d\d\d-\d\d-\d\d) (\d\d:\d\d:\d\d) (AM|PM)$/){
    die "ERROR: could not parse date $dateOut\n";
  }
  my ($date, $time12, $ampm) = ($1, $2, $3);
  my $time = "$time12$ampm";

  my $anim;
  if($tick){
    $anim = "!size=2!!color=green!"
      . '                 /\_/\   !n!'
      . '                =>^,^<=   !n!'
      . '                  / \   / !n!'
      . '                 (___)_/ !n!'
    ;
  }else{
    $anim = "!size=2!!color=green!"
      . '                 /\_/\   !n!'
      . '                =>^,^<=  !n!'
      . '                  / \  \ !n!'
      . '                 (___)_/ !n!'
    ;
  }

  my $markup = ""
    . "!color=white!!size=5!WATER:$ecoAvailFmt%!n!"
    . "!color=white!!size=5!KITTY:$lrWasteFmt%!n!"
    . $anim
    . "!color=green!!size=3!$date!n!"
    . "!color=green!!size=5!$time!n!"
  ;

  return $markup;
}

sub readPyeconet(){
  my @logFiles = sort {$b cmp $a} grep {-f $_} glob "$PYECONET_LOG_DIR/*.log";
  my $logFile = @logFiles > 0 ? $logFiles[0] : undef;

  if(not defined $logFile){
    return undef;
  }

  my $mtime = mtime $logFile;
  my $elapsedS = time - $mtime;

  if($elapsedS < -1 or $elapsedS > 60){
    return undef;
  }

  my $info = defined $logFile ? `cat '$logFile'` : undef;
  my ($avail, $targetTemp, $running);
  if(defined $info){
    $avail = $1 if $info =~ /^tank_hot_water_availability: (\d+)$/m;
    $targetTemp = $1 if $info =~ /^set_point: (\d+)$/m;
    $running = $1 if $info =~ /^running: (\w+)$/m;
  }

  return {
    avail      => $avail,
    targetTemp => $targetTemp,
    running    => $running,
  };
}

sub readPylitterbot(){
  my @logFiles = sort {$b cmp $a} grep {-f $_} glob "$PYLITTERBOT_LOG_DIR/*.log";
  my $logFile = @logFiles > 0 ? $logFiles[0] : undef;

  if(not defined $logFile){
    return undef;
  }

  my $mtime = mtime $logFile;
  my $elapsedS = time - $mtime;

  if($elapsedS < -1 or $elapsedS > 60){
    return undef;
  }

  my $info = `tail -1 '$logFile'`;
  my ($date, $time, $name, $serial, $status, $litter, $waste);
  if($info =~ /^
     (\d\d\d\d-\d\d-\d\d)
     T
     (\d\d:\d\d:\d\d)
     \.\d\d\d
     ,([^,]+)
     ,(\w+)
     ,status=([^,]+)
     ,litter=(\d+|\d*\.\d+)
     ,waste=(\d+|\d*\.\d+)
  /x){
    ($date, $time, $name, $serial, $status, $litter, $waste) = ($1, $2, $3, $4, $5, $6, $7);
  }else{
    return undef;
  }

  return {
    date     => $date,
    time     => $time,
    name     => $name,
    serial   => $serial,
    status   => $status,
    litter   => $litter,
    waste    => $waste,
  };
}

sub calculateFramebuf($$$$){
  my ($leftWidthPct, $rightWidthPct, $lcdGeometry, $isLandscape) = @_;

  my $widthPct = $rightWidthPct - $leftWidthPct;

  my ($w, $h) = ($1, $2) if $lcdGeometry =~ /^(\d+)x(\d+)$/;
  my $fbW = int($w * $widthPct / 100.0);
  my $fbH = $h;

  my $fbX = int($w * $leftWidthPct / 100.0);
  my $fbY = 0;

  if(not $isLandscape){
    ($fbW, $fbH) = ($fbH, $fbW);
    ($fbX, $fbY) = ($fbY, $fbX);
  }

  return "${fbW}x${fbH}+${fbX}+${fbY}";
}

sub readDevInfoCache($){
  my ($devName) = @_;
  my $file = "$DEV_INFO_CACHE_DIR/$devName";
  my $devInfo;
  if(-f $file){
    open my $fh, "< $file" or die "ERROR: could not read $file\n";
    my $infoStr = join('', <$fh>);
    close $fh;
    $devInfo = parseDevInfo($infoStr);
  }else{
    $devInfo = {};
  }
  return $devInfo;
}
sub writeDevInfoCache($$){
  my ($devName, $infoStr) = @_;
  my $file = "$DEV_INFO_CACHE_DIR/$devName";
  system "mkdir", "-p", $DEV_INFO_CACHE_DIR if not -d $DEV_INFO_CACHE_DIR;
  open my $fh, "> $file" or die "ERROR: could not write $file\n";
  print $fh $infoStr;
  close $fh;
}

sub parseDevInfo($){
  my ($devInfoStr) = @_;
  my $devInfo = {};
  if($devInfoStr =~ /^buttons: (.+)$/m){
    my @btnStrs = split /,/, $1;
    $$devInfo{btnCounts} = {};
    for my $btnStr(@btnStrs){
      $$devInfo{btnCounts}{$1} = $2 if $btnStr =~ /^\s*(\w+)\s*=\s*(\d+)\s*$/;
    }
  }
  if($devInfoStr =~ /lcd: (\d+x\d+)/){
    $$devInfo{lcd} = $1;
  }
  if($devInfoStr =~ /^orientation: (\d+) degrees$/m){
    $$devInfo{degrees} = $1;
  }

  return $devInfo;
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  return $stat[9];
}

&main(@ARGV);
