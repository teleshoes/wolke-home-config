#!/usr/bin/perl
use strict;
use warnings;

my $file = "$ENV{HOME}/ddwrt/buffalo";
my $macRe = ("[a-fA-F0-9]{2}:" x 5) . "[a-fA-F0-9]{2}";
my $baseFile = "/tmp/ddwrt";

my $defaultDev = 'ath0';
my @restartDevCmds = qw(wpa_supplicant upnp udhcpc);

my @sshOpts = map {("-o", $_)} (
  "KexAlgorithms=diffie-hellman-group1-sha1", #speed
  "StrictHostKeyChecking=no",
  "UserKnownHostsFile=/dev/null",
);

my %wifiAtts = map {$_ => 1} qw(
  ssid mode net_mode channel channelbw
  security_mode akm crypto wpa_psk
  regdomain
);
my %encWifiAtts = map {$_ => 1} qw( wpa_psk );

my $usage = "Usage:
  $0 [-i|--info]
    Print restore bootstrap instructions {default if no arg given}

  $0 -h|--help
    Print this message

  $0 -s [CMD ARG ARG ..]
    get IP from $file and run 'ssh SSH_OPTS root\@IP CMD ARG ARG ..'

  $0 -r|--reboot
    get IP from $file and run 'ssh SSH_OPTS root\@IP reboot &'

  $0 --restart-dev [DEV]
    runs 'ifconfig DEV down && ifconfig DEV up' on the router
    gets all processes starting with one of @restartDevCmds and containing DEV
    kills those processes on the router, and reruns them
    DEV defaults to $defaultDev

  $0 -t|--test|--speedtest
    perform a speedtest with netcat

  $0 --show
    run nvram show

  $0 -e|--encrypt KEY
    pass in a wpa key or whatever for encrypting and putting into $file

  $0 --restore
    ssh in and setup nvram
    prints nvram info (TIME is like \"date +\%s\"):
      ${baseFile}_old_TIME
      ${baseFile}_new_TIME
      ${baseFile}_change_TIME.sh

  $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline

  SSH_OPTS = @sshOpts
";
my @args = qw(
  -i --info -h --help -s -r --reboot --restart-dev
  -t --test --speedtest --show -e --encrypt --restore
);
my $okArgs = join '|', @args;

sub restartDev($$);
sub assertPresent($$;$);
sub speedtest($);
sub ddwrtShow($);
sub ddwrtRestore($);
sub getStarted($);
sub parse($);
sub getClientIds($);
sub encrypt($);
sub decrypt($);
sub getNvram($);
sub getPublicKeyNvram($);
sub getWifiNvram($);
sub getStaticLeasesNvram($);
sub getExtraNvram($);
sub getPortForwardingNvram($);
sub bashComplete($$);

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print join ' ', bashComplete($_[1], $_[2]);
    exit 0;
  }

  die $usage if @_ == 1 and $_[0] =~ /^(-h|--help)$/;
  my $arg = shift;
  $arg = '-i' if not defined $arg;

  my @sshCmd;
  if($arg =~ /^(-s)$/){
    @sshCmd = @_;
    @_ = ();
  }

  my $dev = $defaultDev;
  if(@_ == 1 and $arg =~ /^(--restart-dev)$/){
    $dev = shift;
  }

  if(@_ == 1 and $arg =~ /^(-e|--encrypt)$/){
    print encrypt $_[0];
    print "\n";
    exit 0;
  }

  die $usage if @_ > 0 or $arg !~ /^($okArgs)$/;

  my $c = parse $file;
  assertPresent $c, 'config';
  assertPresent $c, 'config', 'ip_prefix';
  assertPresent $c, 'config', 'router_ip';
  assertPresent $c, 'clients';
  if($arg =~ /^(-s)$/){
    system "ssh", @sshOpts, "root\@$$c{config}{router_ip}", @sshCmd;
  }elsif($arg =~ /^(-r|--reboot)$/){
    system "ssh @sshOpts root\@$$c{config}{router_ip} reboot &";
  }elsif($arg =~ /^(--restart-dev)$/){
    restartDev $c, $dev;
  }elsif($arg =~ /^(-i|--info)$/){
    print getStarted $c;
  }elsif($arg =~ /^(-t|--test|--speedtest)$/){
    speedtest $c;
  }elsif($arg =~ /^(--show)$/){
    ddwrtShow $c;
  }elsif($arg =~ /^(^--restore$)$/){
    ddwrtRestore $c;
  }
}

sub restartDev($$){
  my ($c, $dev) = @_;
  my $host = "root\@$$c{config}{router_ip}";
  my @ps = `ssh @sshOpts $host ps w`;
  my @cmds;
  push @cmds, "ifconfig $dev down";
  push @cmds, "ifconfig $dev up";
  for my $cmd(@restartDevCmds){
    for my $line(@ps){
      if($line =~ /(\d+)\s*root\s*(?:\d+)\s*\w+\s*($cmd.*$dev.*)/){
        my ($pid, $fullCmd) = ($1, $2);
        push @cmds, "kill $pid";
        push @cmds, "$fullCmd";
      }
    }
  }
  print "\n\n" . join("\n", @cmds) . "\n\n";

  system "ssh", @sshOpts, "$host", join('; ', @cmds);
}

sub assertPresent($$;$){
  my ($c, $section, $item) = @_;
  if(defined $item){
    die "Missing $section.$item\n" if not defined $$c{$section}{$item};
  }else{
    die "Missing section $section\n" if not defined $$c{$section};
  }
}

sub speedtest($){
  my $c = shift;
  my $ip = $$c{config}{router_ip};
  my $port = 5000 + int(rand(1000)); #5000-5999
  my @sendCmd = "nc -v -v -n $ip $port";
  my @rcvCmd = "nc -l -w 60 -p $port";
  my $timeout = 15;

  print "listening on $ip:$port..\n";
  if(fork){
    exec "ssh", @sshOpts, "root\@$ip", "@rcvCmd >/dev/null 2>/dev/null";
  }else{
    my $sshDelay = 10;
    print "waiting ${sshDelay}s for netcat to start\n";
    sleep $sshDelay;
  }

  if(fork){
    print "waiting $timeout seconds and killing nc\n";
    sleep $timeout;
    exec "ssh", @sshOpts, "root\@$ip", "killall nc";
  }


  print "writing to $ip:$port\n";
  my $start = `date +%s.%N`;
  my $out = `yes | @sendCmd 2>&1 1>/dev/null`;
  my $stop = `date +%s.%N`;
  die "Error reading bytes sent\n" if $out !~ /sent (\d+), rcvd (\d+)/;
  chomp $start;
  chomp $stop;
  my $bytes = $1;
  my $elapsed = $stop - $start;
  printf("\n\n%d KiB/s  {%d bytes in %.5f seconds}\n\n",
     int($bytes / $elapsed / 1024),
     $bytes,
     $elapsed);
}

sub ddwrtShow($){
  my $c = shift;
  my $ip = $$c{config}{router_ip};
  system "ssh @sshOpts root\@$ip nvram show";
}

sub ddwrtRestore($){
  my $c = shift;
  my $ip = $$c{config}{router_ip};

  #test ssh
  my $host = `ssh @sshOpts root\@$ip hostname`;
  chomp $host;
  die "Couldnt ssh, or wrong host\n" if $host !~ /^(DD-WRT|ddwrt)$/;

  my $now = time;
  my $oldF = "${baseFile}_old_${now}";
  my $newF = "${baseFile}_new_${now}";
  my $script = "${baseFile}_script_${now}.sh";

  open FH, "> $script";
  for my $nvram(getNvram($c)){
    print FH "nvram set '$nvram'\n";
  }
  print FH "nvram commit\n";
  close FH;
  system "scp", $script, "root\@$ip:$script";

  my $old = `ssh @sshOpts root\@$ip nvram show | sort`;
  open FH, "> $oldF";
  print FH $old;
  close FH;

  system "ssh", @sshOpts, "root\@$ip", "sh $script";

  my $new = `ssh @sshOpts root\@$ip nvram show | sort`;
  open FH, "> $newF";
  print FH $new;
  close FH;

  print "DIFF:\n";
  system "diff $oldF $newF";

  print "rerun script and reboot router [y/N]?\n";
  if(<STDIN> eq "y\n"){
    system "ssh", @sshOpts, "root\@$ip",
      "sh $script; sleep 1; sh $script; reboot";
  }
}

sub getStarted($){
  my $c = shift;
  my $wpa = $$c{config}{default_wpa};
  $wpa = "" if not defined $wpa;
  $wpa =~ s/^\s+//g;
  $wpa =~ s/\s+$//g;
  if($wpa eq ""){
    $wpa = " NONE";
  }else{
    $wpa = " WPA $wpa";
  }

  my $ipMsg;
  if($$c{config}{default_router_ip} eq $$c{config}{router_ip}){
    $ipMsg = "{skip this, default IP is the same as dest IP}";
  }else{
    $ipMsg = "{$$c{config}{default_router_ip} => $$c{config}{router_ip}}";
  }

  return "
1) hold pin, or Administration => Factory Defaults => Restore => Ok
2) connect to default network

   wconnect $$c{config}{default_ssid}$wpa

3) set router IP $ipMsg
   browser $$c{config}{default_router_ip}
     admin/password
     for buffalo-branded: [cancel], skip[x], [cancel], wait, [done]

   Setup => Router IP => $$c{config}{router_ip}

   SAVE settings (apply later)

4) enable ssh
   browser $$c{config}{default_router_ip}

   Services => Secure Shell => SSHd Enable

   SAVE settings (apply later)

5) paste in your pubkey, or use router password

   cat ~/.ssh/*.pub | xsel -b

   SAVE settings (applied after reboot)

   reboot router {more or less required, for some reason}

   wconnect $$c{config}{default_ssid}$wpa

   check ddwrt -s
     if not:
       Services => Secure Shell => SSHd Disable
       Apply Settings
       Services => Secure Shell => SSHd Enable

6) remove router from known_hosts

   ssh-keygen -f \"\$HOME/.ssh/known_hosts\" -R 192.168.11.1

7) run restore and wait for router to reboot {possibly twice...}
   loop -s ddwrt --restore
";
}

sub parse($){
  my $file = shift;
  open FH, "< $file" or die "Couldnt open $file for reading\n";
  my @lines = <FH>;
  close FH;

  my $c = {};
  my $sectionName = undef;
  for my $line(@lines){
    $line =~ s/#.*//;
    if($line =~ /^ \s* \[ \s* (.+?) \s* \] \s* $/x){
      $sectionName = $1;
    }elsif($line =~ /^ \s* ([^=\ \n\t]+) \s* = \s* (.*)$/x){
      my $section;
      if(not defined $sectionName){
        die "Malformed config file line {missing header}: $line\n";
      }elsif(not defined $$c{$sectionName}){
        $section = {};
        $$c{$sectionName} = $section;
      }else{
        $section = $$c{$sectionName};
      }
      $$section{$1} = $2;
    }elsif($line !~ /^\s*$/){
      die "Malformed config file line: $line\n";
    }
  }
  return $c;
}

sub getClientIds($){
  my $c = shift;
  my @ids = sort keys %{$$c{clients}};
  for my $id(@ids){
    die "ID '$id' needs to be two digits\n" if $id !~ /^\d\d$/;
  }
  return @ids;
}

sub encrypt($){
  my $s = shift;
  $s = `gpg-sym $s`;
  die "Error gpg encrypting $s\n" if $? != 0;
  chomp $s;
  return $s;
}

sub decrypt($){
  my $s = shift;
  $s = `gpg-sym $s`;
  die "Error gpg decrypting $s\n" if $? != 0;
  chomp $s;
  return $s;
}

sub getNvram($){
  my $c = shift;
  return (
    getPublicKeyNvram($c),
    getWifiNvram($c),
    getStaticLeasesNvram($c),
    getPortForwardingNvram($c),
    getExtraNvram($c),
  );
}

sub getPublicKeyNvram($){
  my $ssh = `cat ~/.ssh/*.pub`;
  return "sshd_authorized_keys=$ssh";
}

sub getWifiNvram($){
  my $c = shift;
  my @entries;

  for my $section(keys %$c){
    if($section =~ /^ath\d+$/){
      my $radio = $section;
      my $s = $$c{$radio};
      for my $att(sort keys %wifiAtts){
        if(defined $$s{$att}){
          my $val = $$s{$att};
          $val = decrypt $val if defined $encWifiAtts{$att};
          push @entries, "${radio}_$att=$val";
        }
      }
    }
  }
  return @entries;
}

sub getStaticLeasesNvram($){
  my $c = shift;
  my $ipPrefix = $$c{config}{ip_prefix};

  my @entries;
  for my $id(getClientIds($c)){
    my $val = $$c{clients}{$id};
    if($val !~ /^($macRe)\s*(.*)$/){
      die "Malformed client line: $val\n";
    }
    my ($mac, $hostname) = ($1, $2);
    push @entries, "$mac=$hostname=$ipPrefix.$id=";
  }

  my $leaseNum = 'static_leasenum=' . (@entries + 0);
  my $leases = 'static_leases=' . join ' ', @entries;
  return ($leaseNum, $leases);
}

sub getPortForwardingNvram($){
  my $c = shift;
  my $ip_prefix = $$c{config}{ip_prefix};

  my @entries;
  if(defined $$c{forwards}){
    for my $name(keys %{$$c{forwards}}){
      my $val = $$c{forwards}{$name};
      if($val !~ /^(\d+) \s* (\d+) \s* (\d+) \s* (udp|tcp|both)$/x){
        die "Malformed forward line {id from to udp|tcp|both}: $val\n";
      }
      my ($id, $from, $to, $type) = ($1, $2, $3, $4);
      push @entries, "$name:on:$type:$from>$ip_prefix.$id:$to";
    }
  }

  my $trans_port_prefix = $$c{config}{trans_port_prefix};
  my $ssh_port_prefix = $$c{config}{ssh_port_prefix};
  my $trans_port_prefix_alt = $$c{config}{trans_port_prefix_alt};
  my $ssh_port_prefix_alt = $$c{config}{ssh_port_prefix_alt};

  if(defined $ssh_port_prefix){
    for my $id(getClientIds($c)){
      my $name = "ssh-$id";
      my $port = "$ssh_port_prefix$id";
      push @entries, "$name:on:both:$port>$ip_prefix.$id:22";
    }
  }
  if(defined $ssh_port_prefix_alt){
    for my $id(getClientIds($c)){
      my $name = "ssh-alt-$id";
      $id += 20;
      my $port = "$ssh_port_prefix_alt$id";
      push @entries, "ssh-alt-$id:on:both:$port>$ip_prefix.$id:22";
    }
  }
  if(defined $trans_port_prefix){
    for my $id(getClientIds($c)){
      my $name = "trans-$id";
      my $port = "$trans_port_prefix$id";
      push @entries, "$name:on:both:$port>$ip_prefix.$id:$port";
    }
  }
  if(defined $trans_port_prefix_alt){
    for my $id(getClientIds($c)){
      my $name = "trans-alt-$id";
      $id += 20;
      my $port = "$trans_port_prefix_alt$id";
      push @entries, "$name:on:both:$port>$ip_prefix.$id:$port";
    }
  }

  my $fwdNum = 'forwardspec_entries=' . (@entries + 0);
  my $fwd = 'forward_spec=' . join ' ', @entries;
  return ($fwdNum, $fwd);
}

sub getExtraNvram($){
  my $c = shift;
  my @nvram;
  if(defined $$c{nvram}){
    for my $key(keys %{$$c{nvram}}){
      push @nvram, "$key=$$c{nvram}{$key}";
    }
  }
  return @nvram;
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  if(@words == 0){
    return (@args);
  }

  if(@words == 1 and $words[0] =~ /^(--restart-dev)$/){
    return ($defaultDev);
  }

  return ();
}

&main(@ARGV);
