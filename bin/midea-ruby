#!/usr/bin/perl
use strict;
use warnings;

my $MIDEA_CONFIG_DIR = "$ENV{HOME}/.midea";
my $MIDEA_CONFIG_FILE = "$ENV{HOME}/.midea/config";

my $CACHE_DIR = "$ENV{HOME}/.cache/midea-ruby";
my $CACHE_AC_IDS = "$CACHE_DIR/ac-ids.csv";
my $CACHE_SECRETS_MTIME = "$CACHE_DIR/secrets-mtime";

my $SECRETS_FILE = "$ENV{HOME}/.secrets";
my $SECRETS_PREFIX = "midea";
my $SECRETS_KEYS_REGEX = join "|", qw(app_key email password);
my %SECRETS_ENC_KEYS = map {$_ => 1} qw(password);

my $DEFAULT_AC_NUM = 1;

sub fetchACInfo($);
sub getACId($);
sub ensureACIds();
sub ensureConfig();
sub getCachedSecretsMtime();

sub readFile($);
sub readFileLines($);
sub writeFile($$);
sub mtime($);
sub readSecrets();
sub decrypt($);

my $usage = "Usage:
  $0 -h | --help
    show this message

  $0 [OPTS]
  $0 [OPTS] -r|--read
    -read cached AC info from last --fetch
    -print AC info, formatted:
      <POWER> <MODE> <FAN_SPEED>% <TARGET_TEMP>C <INDOOR_TEMP>C/<OUTDOOR_TEMP>C

      POWER:        'on' or 'off'
      MODE:         'cool', 'heat', 'dry', or 'fan'
      FAN_SPEED:    integer (low=40, med=60, high=100, auto=102)
      TARGET_TEMP:  degrees celsius of set/desired temperature
      INDOOR_TEMP:  degrees celsius from indoor thermometer
      OUTDOOR_TEMP: degrees celsius from outdoor thermometer

  OPTS
    --ac=AC_NUM
      use AC_NUM instead of $DEFAULT_AC_NUM
";

my $COMMAND_READ = "read";

sub main(@){
  my $acNum = $DEFAULT_AC_NUM;
  my $cmd = $COMMAND_READ;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(-r|--read)$/){
      $cmd = $COMMAND_READ;
    }elsif($arg =~ /^--ac=(\d+)$/){
      $acNum = $1;
    }else{
      die $usage;
    }
  }

  if($cmd eq $COMMAND_READ){
    my $acInfo = getCachedACInfo($acNum);
    print formatACInfo($acInfo);
  }else{
    die "ERROR: unknown command $cmd\n";
  }
}

sub formatACInfo($){
  my ($acInfo) = @_;

  return sprintf "%-3s %4s %3d%%  %2dC  (%2dC/%2dC)\n",
    $$acInfo{power},
    $$acInfo{mode},
    $$acInfo{fan},
    $$acInfo{temp},
    $$acInfo{indoor_temp},
    $$acInfo{outdoor_temp},
  ;
}

sub fetchACInfo($){
  my ($acNum) = @_;
  my $acID = getACId($acNum);
  ensureConfig();
  my $output = `midea-ac get $acID 2>/dev/null`;
  my $cacheFile = "$CACHE_DIR/ac-$acID";
  writeFile($cacheFile, $output);
}

sub getCachedACInfo($){
  my ($acNum) = @_;
  my $acID = getACId($acNum);
  my $cacheFile = "$CACHE_DIR/ac-$acID";

  my $info = {};
  for my $line(readFileLines($cacheFile)){
    if($line =~ /^Device is turned (on|off)\.$/){
      $$info{power} = $1;
    }elsif($line =~ /^Target temperature: (\d+) celsius$/){
      $$info{temp} = $1;
    }elsif($line =~ /^Indoor temperature: (\d+) celsius$/){
      $$info{indoor_temp} = $1;
    }elsif($line =~ /^Outdoor temperature: (\d+) celsius$/){
      $$info{outdoor_temp} = $1;
    }elsif($line =~ /^Mode: (\w+)$/){
      $$info{mode} = $1;
    }elsif($line =~ /^Fan speed: (\d+)$/){
      $$info{fan} = $1;
    }elsif($line =~ /^TimerOn is (active|not active).$/){
      $$info{timerOn} = $1;
    }elsif($line =~ /^TimerOff is (active|not active).$/){
      $$info{timerOff} = $1;
    }elsif($line =~ /^Eco mode is (on|off).$/){
      $$info{eco} = $1;
    }
  }
  if(
    not defined $$info{power}
    or not defined $$info{mode}
    or not defined $$info{temp}
    or not defined $$info{fan}
  ){
    die "ERROR: could not parse AC info\n";
  }

  return $info;
}

sub getACId($){
  my ($acNum) = @_;
  ensureACIds();
  my @csvLines = `cat $CACHE_AC_IDS`;
  for my $line(@csvLines){
    if($line =~ /^$acNum,(\d+)$/){
      return $1;
    }
  }
  die "ERROR: AC ID is not cached for AC#$acNum\n";
}

sub ensureACIds(){
  return if -e $CACHE_AC_IDS;
  ensureConfig();

  my $col = '[^|]*[^| \t]';
  my $acNum = 0;
  my %acIdsByACNum;
  for my $line(`midea-ac list 2>/dev/null`){
    if($line =~ /^\|\s*($col)\s*\|\s*($col)\s*\|\s*($col)\s*\|\s*($col)\s*\|\s*($col)\s*\|$/){
      my ($id, $name, $type, $online, $active) = ($1, $2, $3, $4, $5);
      next if $id eq "ID";

      if($id !~ /^\d+$/){
        die "ERROR: malformed `midea-ac list` line:\n$line";
      }elsif($type ne '0xAC' or $online ne '1' or $active ne '1'){
        print "WARNING: skipping device $line";
      }else{
        $acNum++;
        $acIdsByACNum{$acNum} = $id;
      }
    }
  }

  my $count = keys %acIdsByACNum;
  if($count == 0){
    die "ERROR: could not obtain any AC IDs\n";
  }

  system "mkdir", "-p", $CACHE_DIR;
  my $csv = join '', map {"$_,$acIdsByACNum{$_}\n"} sort keys %acIdsByACNum;
  writeFile($CACHE_AC_IDS, $csv);
}

sub ensureConfig(){
  my $secretsMtime = mtime $SECRETS_FILE;
  my $cachedSecretsMtime = getCachedSecretsMtime();
  if(-e $MIDEA_CONFIG_FILE and $secretsMtime == $cachedSecretsMtime){
    return;
  }else{
    system "mkdir", "-p", $MIDEA_CONFIG_DIR;
    my $cfg = readSecrets();
    my $contents = "";
    $contents .= "---\n";
    $contents .= "email: $$cfg{email}\n";
    $contents .= "password: $$cfg{password}\n";
    $contents .= "app_key: $$cfg{app_key}\n";
    writeFile($MIDEA_CONFIG_FILE, $contents);

    system "mkdir", "-p", $CACHE_DIR;
    writeFile($CACHE_SECRETS_MTIME, "$secretsMtime\n");
  }
}

sub getCachedSecretsMtime(){
  my $c = `cat $CACHE_SECRETS_MTIME 2>/dev/null`;
  if($c =~ /^(\d+)$/){
    return $1;
  }else{
    return undef;
  }
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  return $stat[9];
}

sub readFile($){
  my ($file) = @_;
  my $contents = join '', readFileLines($file);
}
sub readFileLines($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n$!\n";
  my @lines = <FH>;
  close FH;
  return @lines;
}
sub writeFile($$){
  my ($file, $contents) = @_;
  open FH, "> $file" or die "ERROR: could not write $file\n$!\n";
  print FH $contents;
  close FH;
}

sub readSecrets(){
  my @lines = `cat $SECRETS_FILE 2>/dev/null`;
  my $cfg = {};
  for my $line(@lines){
    if($line =~ /^$SECRETS_PREFIX\.($SECRETS_KEYS_REGEX)\s*=\s*(.+)$/){
      $$cfg{$1} = $2;
    }
  }
  for my $key(sort keys %$cfg){
    $$cfg{$key} = decrypt $$cfg{$key} if defined $SECRETS_ENC_KEYS{$key};
  }
  return $cfg;
}

sub decrypt($){
  my ($s) = @_;
  open GPG, "-|", "gpg-sym", $s or die "could not run gpg-sym\n";
  my @contents = <GPG>;
  close GPG;
  die "error running gpg-sym\n$!\n" if $? != 0;
  my $value = join '', @contents;
  chomp $value;
  return $value;
}

&main(@ARGV);
