#!/usr/bin/perl
use strict;
use warnings;
use JSON qw(from_json);
use Time::HiRes qw(time);

my $OK_EXTS_REGEX = join "|", qw(
  avi m2ts mts mov mkv mpeg mpg mp4
);

sub getSRTFile($);
sub ensureSRT($$);
sub removeSRT($);
sub selectSubTrackID($$);
sub getTracks($);
sub run(@);

my $USAGE = "Usage:
  $0 [OPTS] --extract VIDEO_FILE
    -if SRT_FILE exists, do nothing
    -if VIDEO_FILE is an MKV file:
      -extract SRT track using `mkvextract`, and write to SRT_FILE
    -otherwise, fail with an error

  SRT_FILE
    same as VIDEO_FILE, with '.<EXT>' suffix replaced with '.srt', case-insensitive

  TMP_SRT_FILE
    backup file for SRT_FILE: /tmp/subtitle-fix-<SRT_FILE_BOING>-<MILLIS>
      SRT_FILE_BOING
        SRT_FILE, with all chars except alphanumeric and underscore with '%'
      MILLIS
        time since epoch, in millis

  OPTS
    --replace
      when extracting subtitles, first move the existing SRT_FILE to TMP_SRT_FILE

    --eng
      choose the first english lang subtitle track
      (this is the default)
      same as: --priority=ENG1,1

    --alt
      choose the second english lang subtitle track
      same as: --priority=ENG2,ENG1,1

    --priority=SUB_CSV
      choose the first subtitle track that matches the first SUB

    SUB_CSV
      comma-separated list of <SUB>s
      e.g.:   'ENG1,ENG2,1'   'SPA2'
    SUB
      a specifier to match subtitle tracks
      <LANG><LANG_IDX>
        a language, and the index, starting with 1, of only subtitle tracks with <LANG>
      <LANG>
        same as: <LANG>1
      <IDX>
        the index, starting with 1, of all subtitle tracks
";

my $CMD_EXTRACT = "extract";

sub main(@){
  my $cmd = $CMD_EXTRACT;
  my $videoFile = undef;
  my $subArgCSV = "ENG1,1";
  my $replace = 0;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-e|--extract)$/){
      $cmd = $CMD_EXTRACT;
    }elsif($arg =~ /^(-r|--replace)$/){
      $replace = 1;
    }elsif($arg =~ /^--eng$/){
      $subArgCSV = "ENG1,1";
    }elsif($arg =~ /^--alt$/){
      $subArgCSV = "ENG2,ENG1,1";
    }elsif($arg =~ /^--priority=(.+)$/){
      $subArgCSV = $1;
    }elsif(-f $arg and $arg =~ /\.($OK_EXTS_REGEX)$/i){
      $videoFile = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($cmd eq $CMD_EXTRACT){
    if($replace){
      removeSRT($videoFile);
    }
    ensureSRT($videoFile, $subArgCSV);
  }else{
    die "ERROR: unknown command $cmd\n";
  }
}

sub getSRTFile($){
  my ($videoFile) = @_;
  my $srtFile = $videoFile;
  if($srtFile !~ s/\.($OK_EXTS_REGEX)/.srt/i){
    die "ERROR: malformed VIDEO_FILE $videoFile, <EXT> must be one of: $OK_EXTS_REGEX\n";
  }
  return $srtFile;
}

sub ensureSRT($$){
  my ($videoFile, $subArgCSV) = @_;
  my $srtFile = getSRTFile($videoFile);
  if(-e $srtFile){
    return;
  }
  my $mkvFile = $videoFile;
  if($mkvFile !~ /\.mkv/i){
    die "ERROR: malformed MKV_FILE $mkvFile, must end in .mkv\n";
  }

  my $trackID = selectSubTrackID($mkvFile, $subArgCSV);
  die "ERROR: could not find subtitle tracks in $mkvFile\n" if not defined $trackID;

  my @cmd = ("mkvextract", $mkvFile, "tracks", "$trackID:$srtFile");
  run @cmd;
}

sub removeSRT($){
  my ($videoFile) = @_;
  my $srtFile = getSRTFile($videoFile);
  if(-f $srtFile){
    my $boingSrtFile = $srtFile;
    $boingSrtFile =~ s/[^a-zA-Z0-9_]/%/g;
    my $tmpFile = "/tmp/subtitle-fix-$boingSrtFile-" . nowMillis();
    my @cmd = ("mv", $srtFile, $tmpFile);
    run @cmd;
  }
}


sub selectSubTrackID($$){
  my ($mkvFile, $subArgCSV) = @_;
  my @tracks = getTracks($mkvFile);
  for my $subArg(split(/,/, $subArgCSV)){
    my ($lang, $langIdx, $idx);
    if($subArg =~ /^\s*([a-z]+)(\d+)\s*$/i){
      ($lang, $langIdx, $idx) = ($1, $2, undef);
    }elsif($subArg =~ /^\s*([a-z]+)\s*$/i){
      ($lang, $langIdx, $idx) = ($1, 1, undef);
    }elsif($subArg =~ /^\s*(\d+)\s*$/){
      ($lang, $langIdx, $idx) = (undef, undef, $1);
    }else{
      die "ERROR: malformed SUB_CSV $subArgCSV\n";
    }

    my $curLangIdx = 0;
    my $curSubIdx = 0;
    for my $track(@tracks){
      next if $$track{type} ne "subtitles";
      next if $$track{codec} !~ /SRT/i;

      my $subLang = $$track{properties}{language};
      $subLang = "" if not defined $subLang;
      if(defined $lang and lc $lang eq lc $subLang){
        $curLangIdx++;
        if($curLangIdx == $langIdx){
          return $$track{id};
        }
      }
      $curSubIdx++;
      if(defined $idx and $curSubIdx == $idx){
        return $$track{id};
      }
    }
  }

  return undef;
}

sub getTracks($){
  my ($mkvFile) = @_;
  my @cmd = ("mkvmerge", "-J", $mkvFile);
  open CMD, "-|", @cmd or die "ERROR: could not run @cmd\n";
  my $json = join '', <CMD>;
  close CMD;

  my $obj = from_json($json);
  my @tracks = @{$$obj{tracks}};
  die "ERROR: could not fetch tracks with @cmd\n" if @tracks == 0;
  return @tracks;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

sub run(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
