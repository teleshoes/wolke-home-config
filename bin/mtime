#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

my $DATETIME_FORMAT_EPOCH = "%s";
my $DATETIME_FORMAT_EPOCH_MILLIS = "%s.%3N";
my $DATETIME_FORMAT_PRETTY = "%Y-%m-%dT%H:%M:%S";
my $DATETIME_FORMAT_PRETTY_MILLIS = "%Y-%m-%dT%H:%M:%S.%3N";
my $DATETIME_FORMAT_ISO = "%Y-%m-%dT%H:%M:%S%:z";

my $FILE_MODE_ALWAYS = 'always';
my $FILE_MODE_NEVER = 'never';
my $FILE_MODE_MULTI = 'multi';

my $FILE_DISPLAY_POS_PREFIX = 'prefix';
my $FILE_DISPLAY_POS_SUFFIX = 'suffix';

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h|--help
    print this message

  $EXEC [OPTS] [FILE FILE ..]
    print file modification time in seconds since epoch UTC, one per line
    if more than one file is specified, prefix each line with 'FILE',
      followed by whitespace (one or more ' ' chars, to align the mtime)

  OPTS
    --format=DATE_FORMAT
    +DATE_FORMAT
      format mtime in local time zone using `date +DATE_FORMAT`
        -if DATE_FORMAT contains %N or %<WIDTH>N (e.g. '%N' or '%5N'):
          -use Time::HiRes::lstat to get file mtime to millisecond precision
        -default is: --format=$DATETIME_FORMAT_EPOCH

    -f | --format
      if --millis is also given:
        same as: --format=$DATETIME_FORMAT_PRETTY_MILLIS
      otherwise:
        same as: --format=$DATETIME_FORMAT_PRETTY

    -I | --iso | --iso-8601 | -Iseconds | --iso-8601=seconds
      same as: --format=$DATETIME_FORMAT_ISO
      NOTE: --millis has no effect with -I

    -u | --utc
      pass '--utc' to `date` when using DATE_FORMAT
      (no effect without one of the --format args, epoch is always UTC)

    -m | --millis
    --fracs | --frac-s
      if no DATE_FORMAT given:
        if --format is given, use format: $DATETIME_FORMAT_PRETTY_MILLIS
        otheriwse, use format: $DATETIME_FORMAT_EPOCH_MILLIS
      e.g.: 1666124897.300  or  2022-10-18_16-28-17.300

    --file | -p | --prefix
      always include 'FILE' in output
    --no-file | -n | --no-prefix
      never include 'FILE' in output
    --file-multi
      only include 'FILE' in output if more than one file is given
      (this is the default)

    -s | --suffix
      print mtime before the 'FILE', with a single space between
      implies --file, but --file-multi can override this
";

sub main(@){
  my $usePrettyFormat = 0;
  my $useDateUTC = 0;
  my $dateFormatSpec = undef;
  my $useMillis = 0;
  my $fileMode = $FILE_MODE_MULTI;
  my $fileDisplayPos = $FILE_DISPLAY_POS_PREFIX;
  my @files;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^--format=(.+)$/){
      $dateFormatSpec = $1;
    }elsif($arg =~ /^\+(.+)$/){
      $dateFormatSpec = $1;
    }elsif($arg =~ /^(-f|--format)$/){
      $usePrettyFormat = 1;
    }elsif($arg =~ /^(-I|--iso|--iso-8601|-Iseconds|--iso-8601=seconds)$/){
      $dateFormatSpec = $DATETIME_FORMAT_ISO;
    }elsif($arg =~ /^(-u|--utc)$/){
      $useDateUTC = 1;
    }elsif($arg =~ /^(-m|--millis|--fracs|--frac-s)$/){
      $useMillis = 1;
    }elsif($arg =~ /^(--file|-p|--prefix)$/){
      $fileMode = $FILE_MODE_ALWAYS;
    }elsif($arg =~ /^(--no-file|-n|--no-prefix)$/){
      $fileMode = $FILE_MODE_NEVER;
    }elsif($arg =~ /^(--file-multi)$/){
      $fileMode = $FILE_MODE_MULTI;
    }elsif($arg =~ /^(-s|--suffix)$/){
      $fileDisplayPos = $FILE_DISPLAY_POS_SUFFIX;
      $fileMode = $FILE_MODE_ALWAYS;
    }elsif(-l $arg or -e $arg){
      push @files, $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if(not defined $dateFormatSpec){
    if($useMillis){
      if($usePrettyFormat){
        $dateFormatSpec = $DATETIME_FORMAT_PRETTY_MILLIS;
      }else{
        $dateFormatSpec = $DATETIME_FORMAT_EPOCH_MILLIS;
      }
    }else{
      if($usePrettyFormat){
        $dateFormatSpec = $DATETIME_FORMAT_PRETTY;
      }else{
        $dateFormatSpec = $DATETIME_FORMAT_EPOCH;
      }
    }
  }

  my $formatContainsNano = $dateFormatSpec =~ /%\d*N/ ? 1 : 0;

  my $maxFileLen = 0;
  for my $file(@files){
    my $len = length $file;
    $maxFileLen = $len if $len > $maxFileLen;
  }

  my $displayFile = 0;
  $displayFile = @files > 1 ? 1 : 0 if $fileMode eq $FILE_MODE_MULTI;
  $displayFile = 1 if $fileMode eq $FILE_MODE_ALWAYS;
  $displayFile = 0 if $fileMode eq $FILE_MODE_NEVER;

  for my $file(@files){
    my @stat;
    if($formatContainsNano){
      require Time::HiRes;
      @stat = Time::HiRes::lstat $file;
    }else{
      @stat = lstat $file;
    }

    my $mtime = $stat[9];

    my $mtimeFmt;
    #skip calling `date` for simple epoch formats
    if($dateFormatSpec eq "%s"){
      $mtimeFmt = int($mtime);
    }elsif($dateFormatSpec eq "%s.%3N"){
      $mtimeFmt = sprintf "%.3f", int($mtime * 1000.0) / 1000.0;
    }else{
      my @dateArgs = $useDateUTC ? ("--utc") : ();
      $mtimeFmt = `date @dateArgs --date \@$mtime +$dateFormatSpec`;
      chomp $mtimeFmt;
    }

    if($displayFile){
      if($fileDisplayPos eq $FILE_DISPLAY_POS_PREFIX){
        my $len = $maxFileLen + 2;
        printf "\%-${len}s \%s\n", $file, $mtimeFmt;
      }elsif($fileDisplayPos eq $FILE_DISPLAY_POS_SUFFIX){
        printf "%s %s\n", $mtimeFmt, $file;
      }else{
        die "ERROR: unknown file display pos $fileDisplayPos\n";
      }
    }else{
      print "$mtimeFmt\n";
    }
  }
}

&main(@ARGV);
