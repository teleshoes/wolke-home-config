#!/usr/bin/perl
use strict;
use warnings;

my @exts = qw(
  jpg jpeg png gif mpo
  avi m2ts mts mov mkv mpeg mpg mp4
);
my $okExts = "(?:" . (join "|", @exts) . ")";

my $usage = "Usage:
  $0 -h|--help
    show this message

  $0 [OPTS] FILE [FILE FILE ...]
    rename all 'FILE's using the exif 'Date and Time' for JPEGs,
      or the file's mtime for non-JPEGs
    FILE must end in '.' followed by @exts

  OPTS
    --exif-mtime   {default}
      use exif for JPEG and mtime for non-JPEG to get timestamp
      (this is the default)
    --exif
      use only exif to get timestamp
    --mtime
      use only mtime to get timestamp
    --filename
      use picname file name to get timestamp
      fails if file is not named in the expected format

    --shift-hours=HOURS
      add HOURS*60*60 to the timestamp, regardless of method chosen
      HOURS must be an integer (positive, negative, or zero)
      e.g.: --shift-hours=-4  subtracts 4*60*60 seconds
";

sub handleFile($$$);
sub exifEpoch($);
sub mtimeEpoch($);
sub filenameEpoch($);
sub run(@);

my $MODE_EXIF_MTIME = "exif-mtime";
my $MODE_EXIF = "exif";
my $MODE_MTIME = "mtime";
my $MODE_FILENAME = "filename";

sub main(@){
  my $mode = $MODE_EXIF_MTIME;
  my $shiftHours = 0;
  while(@_ > 0 and $_[0] =~ /^-/){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(--exif-mtime)$/ and @_ > 0){
      $mode = $MODE_EXIF_MTIME;
    }elsif($arg =~ /^(--exif)$/){
      $mode = $MODE_EXIF;
    }elsif($arg =~ /^(--mtime)$/){
      $mode = $MODE_MTIME;
    }elsif($arg =~ /^(--filename)$/){
      $mode = $MODE_FILENAME;
    }elsif($arg =~ /^--shift-hours=(-?\d+)$/){
      $shiftHours = $1;
    }
  }
  for my $arg(@_){
    die $usage if not -f $arg;
  }
  my @files = @_;
  die $usage if @files == 0;
  my @errors;
  for my $file(@files){
    if(-f $file){
      my $isOk = handleFile $mode, $shiftHours, $file;
      push @errors, $file if not $isOk;
    }
  }
  if(@errors > 0){
    my $errorsFmt = join "", map {" $_\n"} @errors;
    die "\n\nERROR HANDLING FILES:\n$errorsFmt";
  }
}

sub handleFile($$$){
  my ($mode, $shiftHours, $file) = @_;
  my ($dir, $fileName, $ext);
  if($file =~ /^(.*\/)?(.+)\.($okExts)$/i){
    ($dir, $fileName, $ext) = ($1, $2, $3);
  }else{
    die "$file did not end in one of: @exts\n";
  }
  $dir = "" if not defined $dir;
  my $epoch;
  if($mode eq $MODE_EXIF_MTIME){
    if($file =~ /\.(jpg|jpeg)/i){
      $epoch = exifEpoch $file;
    }else{
      $epoch = mtimeEpoch $file;
    }
  }elsif($mode eq $MODE_EXIF){
    $epoch = exifEpoch $file;
  }elsif($mode eq $MODE_MTIME){
    $epoch = mtimeEpoch $file;
  }elsif($mode eq $MODE_FILENAME){
    $epoch = filenameEpoch $file;
  }

  if(not defined $epoch){
    print "cannot process $file\n";
    return 0;
  }

  $epoch += $shiftHours * 60 * 60;

  my $dateFmt = `date --date \@$epoch +'%Y%m%d_%H%M%S'`;
  chomp $dateFmt;

  if($fileName =~ /^\d\d\d\d\d\d\d\d_\d\d\d\d\d\d(?:_\d+)?_(.+)/){
    my ($unprefixedFileName) = ($1);

    my $oldFileNameEpoch = filenameEpoch $file;
    my $diff = $epoch - $oldFileNameEpoch;
    $diff = 0-$diff if $diff < 0;
    if($diff > 60*60*24){
      print STDERR ""
        . "WARNING: old date prefix disagrees by more than a day"
        . " for $file ($oldFileNameEpoch vs $epoch)\n";
    }

    $fileName = $unprefixedFileName;
  }

  my $newFile = "${dir}${dateFmt}_${fileName}.${ext}";
  my $count = 0;
  while(-f $newFile and $file ne $newFile){
    $count++;
    $newFile = "$dir${dateFmt}_${fileName}_${count}.${ext}";
  }
  if($file eq $newFile){
    print "skipping $file\n";
    return 1;
  }else{
    run "mv", "--no-clobber", $file, $newFile;
    if($? == 0){
      return 1;
    }else{
      return 0;
    }
  }
}

sub exifEpoch($){
  my ($file) = @_;
  open EXIF, "-|", "exif", "-m", $file;
  my @lines = <EXIF>;
  close EXIF;
  die "error running exif on $file\n" if $? != 0;
  my @dates;
  for my $line(@lines){
    if($line =~ /^Date and Time[^\t]*\t(.+)$/){
      my $dt = $1;
      if($dt =~ /^(\d\d\d\d):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/){
        my ($y, $m, $d, $hr, $min, $sec) = ($1, $2, $3, $4, $5, $6);
        my $s = `date --date '$y-$m-$d $hr:$min:$sec' +%s`;
        chomp $s;
        if($s !~ /^\d+$/){
          print STDERR "ERROR: malformed date output $s\n";
          return undef;
        }
        push @dates, $s;
      }else{
        print STDERR "ERROR: malformed date line: $line\n";
        return undef;
      }
    }
  }
  if(@dates == 0){
    print STDERR "ERROR: no EXIF date time found for: $file\n";
    return undef;
  }
  my $date = $dates[0];
  for my $d(@dates){
    if($d != $date){
      print STDERR "WARNING: mismatched date tags for $file: $d != $date\n";
      if($d < $date){
        $date = $d;
      }
    }
  }
  return $date;
}

sub mtimeEpoch($){
  my ($file) = @_;
  my $mtimeEpoch = (stat $file)[9];
  return $mtimeEpoch;
}

sub filenameEpoch($){
  my ($file) = @_;
  my $filename = $file;
  $filename =~ s/.*\///;
  if($filename =~ /^(\d\d\d\d)(\d\d)(\d\d)_(\d\d)(\d\d)(\d\d)[_\.]/){
    my ($y, $m, $d, $hr, $min, $sec) = ($1, $2, $3, $4, $5, $6);
    my $dateFmt = "$y$m$d $hr:$min:$sec";
    my $epoch = `date +%s --date='$dateFmt'`;
    chomp $epoch;
    if($epoch =~ /^\d+$/){
      return $epoch;
    }else{
      print STDERR "ERROR: could not read datetime fmt '$dateFmt' using `date`\n";
    }
  }else{
    print STDERR "ERROR: filename must start with YYYYMMDD_HHMMSS, then . or _\n";
  }
  return undef;
}

sub run(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
