#!/usr/bin/perl
use strict;
use warnings;
use JSON qw(from_json);

my $JSON_CACHE_DIR = "$ENV{HOME}/.cache/robinhood/orders-json";
my $API_INSTRUMENT_URL_PREFIX = "https://api.robinhood.com/instruments";
my $API_CURRENCY_PAIRS_URL_PREFIX = "https://nummus.robinhood.com/currency_pairs";
my $INSTRUMENT_CACHE = "$ENV{HOME}/.cache/robinhood/instrument-cache";

my $USAGE = "Usage:
  $0 -h | --help
    show this message

  $0
    show all instruments total cost and total quantity
";

sub readInstrumentCache();
sub writeInstrumentCache($);
sub getInstrumentSymbol($);
sub getCryptoCode($);
sub readUrl($);

sub main(@){
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  my @orders = parseJsonOrders();
  my %inst;
  for my $order(@orders){
    my ($sym, $price, $amount) = ($$order{symbol}, $$order{price}, $$order{amount});
    $inst{$sym} = {cost => 0, amount => 0} if not defined $inst{$sym};
    if(defined $amount and defined $price){
      $inst{$sym}{cost} += $price*$amount;
      $inst{$sym}{amount} += $amount;
    }
  }
  for my $sym(sort keys %inst){
    printf "%-5s - %8.2f\$ - %8.3f\n", $sym, $inst{$sym}{cost}, $inst{$sym}{amount};
  }
}

sub parseJsonOrders(){
  my $instrumentCache = readInstrumentCache();
  my $updateInstrumentCache = 0;
  my @orders;
  my %seenOrderIds;
  my @ordersFiles = sort glob "$JSON_CACHE_DIR/*";
  for my $file(reverse @ordersFiles){
    my $json = `cat $file`;
    my $obj = from_json $json;
    my @results = @{$$obj{results}};
    for my $res(@results){
      my $orderId = $$res{id};
      next if defined $seenOrderIds{$orderId};
      $seenOrderIds{$orderId} = 1;

      my $isCrypto = defined $$res{currency_pair_id};

      my $instId = $isCrypto ? $$res{currency_pair_id} : $$res{instrument_id};
      my $price = $$res{average_price};
      my $amount = $$res{cumulative_quantity};
      my $createdAt = $$res{created_at};

      my $time = `date --date="$createdAt" +%s.%N`;
      chomp $time;

      if(defined $instId and not defined $$instrumentCache{$instId}){
        my $sym = $isCrypto ? getCryptoCode($instId) : getInstrumentSymbol($instId);
        $$instrumentCache{$instId} = $sym;
        $updateInstrumentCache = 1;
      }

      my $sym = $$instrumentCache{$instId} if defined $instId;
      my $order = {
        symbol => $sym,
        price  => $price,
        amount => $amount,
        time   => $time,
      };
      push @orders, $order;
    }
  }
  if($updateInstrumentCache){
    writeInstrumentCache $instrumentCache;
  }

  return @orders;
}

sub readInstrumentCache(){
  return {} if not -f $INSTRUMENT_CACHE;

  open FH, "< $INSTRUMENT_CACHE" or die "ERROR: could not read $INSTRUMENT_CACHE\n$!\n";
  my @lines = <FH>;
  close FH;
  my $instruments = { map {$_ =~ /^(\w+) (.+)$/; ($2, $1)} @lines };
  return $instruments;
}
sub writeInstrumentCache($){
  my ($instruments) = @_;
  open FH, "> $INSTRUMENT_CACHE" or die "ERROR: could not write $INSTRUMENT_CACHE\n$!\n";
  my @idOrder = sort {$$instruments{$a} cmp $$instruments{$b}} keys %$instruments;
  for my $id(@idOrder){
    my $sym = $$instruments{$id};
    print FH "$sym $id\n";
  }
  close FH;
}

sub getInstrumentSymbol($){
  my ($instrumentId) = @_;
  my $url = "$API_INSTRUMENT_URL_PREFIX/$instrumentId/";
  my $json = readUrl($url);
  my $obj = from_json($json);
  my $sym = $$obj{symbol};
  die "ERROR: invalid instrument symbol $sym\n" if $sym !~ /^\w+$/;
  return $sym;
}
sub getCryptoCode($){
  my ($currencyPairId) = @_;
  my $url = "$API_CURRENCY_PAIRS_URL_PREFIX/$currencyPairId/";
  my $json = readUrl($url);
  my $obj = from_json($json);
  my $code = $$obj{asset_currency}{code};
  die "ERROR: invalid crypto code $code\n" if $code !~ /^\w+$/;
  return $code;
}

sub readUrl($){
  my ($url) = @_;
  return `wget "$url" -O - -q`;
}

&main(@ARGV);
