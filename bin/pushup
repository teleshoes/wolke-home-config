#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

my $CACHE_DIR = "$ENV{HOME}/.cache/pushups";

my $DATEFILE_NEW_DAY_START_HOUR = 4; #new date starts at 4am localtime

my $EXEC = basename $0;

sub appendDateFile($$$);
sub getDate($);
sub getTime($);
sub getDateFile($$);

my $MODE_APPEND = "append";
my $MODE_PRINT = "print";

my $usage = "Usage:
  $EXEC -h|--help
    print this message

  $EXEC [OPTS] [--print|--get]
    cat all $CACHE_DIR/<DATEFILE> files

  $EXEC [OPTS] [--append] COUNT
    append \"<COUNT> | <EPOCH> | <DATE> <TIME> | <TYPE>\"
    to a file named $CACHE_DIR/<DATEFILE>

    COUNT
      a positive integer
    EPOCH
      seconds sincd 1970-01-01 00:00, as of now
    DATE
      <EPOCH> formatted as YYYY-mm-dd
    TIME
      <EPOCH> formatted as formatted HH:MM:SS
    DATEFILE
      <EPOCH>, minus $DATEFILE_NEW_DAY_START_HOUR hours, formatted as YYYY-MM-DD
      (new day starts at " . sprintf("%02d:00", $DATEFILE_NEW_DAY_START_HOUR) . ")

  OPTS
    TYPE | --type=TYPE
      must start with a letter, can be letters/numbers/underscores

    --time=EPOCH | --epoch=EPOCH
      EPOCH must be a number, to be interpreted like `date --date=@<EPOCH>`
";

sub main(@){
  my ($count, $type, $epoch);
  my $mode = $MODE_PRINT;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(?:--print|--get)$/){
      $mode = $MODE_PRINT;
    }elsif($arg =~ /^(?:--append)$/){
      $mode = $MODE_APPEND;
    }elsif($arg =~ /^((?:[a-z][A-Z])\w+)$/){
      $type = $1;
    }elsif($arg =~ /^(?:--type|--epoch)=(\d+)$/){
      $epoch = $1;
    }elsif($arg =~ /^(\d+)$/){
      $count = $1;
      $mode = $MODE_APPEND;
    }else{
      die "ERROR: unknown arg \"$arg\n";
    }
  }

  if($mode eq $MODE_PRINT){
    system "cat $CACHE_DIR/????-??-??";
  }elsif($mode eq $MODE_APPEND){
    die "ERROR: missing COUNT\n" if not defined $count;
    appendDateFile($count, $type, $epoch);
  }else{
    die $usage;
  }
}

sub appendDateFile($$$){
  my ($count, $type, $epoch) = @_;

  $epoch = time if not defined $epoch;
  $type = "-" if not defined $type;

  my $date = getDate $epoch;
  my $time = getTime $epoch;
  my $dateFile = getDateFile $CACHE_DIR, $epoch;

  my $line = sprintf "%-3d | %d | %s %s | %s",
    $count, $epoch, $date, $time, $type;

  print "WRITING: $line\n => $dateFile\n";
  open FH, ">> $dateFile" or die "could not open file\n$!\n";
  print FH "$line\n";
  close FH;
}

sub getDate($){
  my ($time) = @_;
  my $dateFmt = `date +%Y-%m-%d --date=\@$time`;
  if($dateFmt =~ /^(\d\d\d\d-\d\d-\d\d)$/){
    return $1;
  }else{
    die "ERROR: malformed date $dateFmt\n";
  }
}
sub getTime($){
  my ($time) = @_;
  my $dateFmt = `date +%H:%M:%S --date=\@$time`;
  if($dateFmt =~ /^(\d\d:\d\d:\d\d)$/){
    return $1;
  }else{
    die "ERROR: malformed time $dateFmt\n";
  }
}
sub getDateFile($$){
  my ($dir, $time) = @_;
  my $dateFmt = getDate($time - $DATEFILE_NEW_DAY_START_HOUR*60*60);
  return "$dir/$dateFmt";
}

&main(@ARGV);
