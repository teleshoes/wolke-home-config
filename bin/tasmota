#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
my $FORKMGR_LIB = eval {require Parallel::ForkManager};

my $WIFI_SSID = "FlipsAFad";
my $INITIAL_DEVICE_IP = "192.168.4.1";
my $DEFAULT_DEVICE = "outlet1";

my @DEVICES_ARR = (
  init    => "$INITIAL_DEVICE_IP",
  bulb1   => "192.168.11.93",
  bulb2   => "192.168.11.94",
  bulb3   => "192.168.11.95",
  outlet1 => "192.168.11.96",
  outlet2 => "192.168.11.97",
  outlet3 => "192.168.11.98",
);
my @DEVICE_NAMES = map {$DEVICES_ARR[$_]}
                   grep {$_ % 2 == 0} (0..$#DEVICES_ARR);
my %DEVICES = @DEVICES_ARR;

my @DEVICE_ALIASES_ARR = (
  "all"   => [qw(bulb1 bulb2 bulb3 outlet1 outlet2 outlet3)],

  "b"     => [qw(bulb1 bulb2 bulb3)],
  "bulbs" => [qw(bulb1 bulb2 bulb3)],

  "b1"    => [qw(bulb1)],
  "b2"    => [qw(bulb2)],
  "b3"    => [qw(bulb3)],
  "o1"    => [qw(outlet1)],
  "o2"    => [qw(outlet2)],
  "o3"    => [qw(outlet3)],
);
my @DEVICE_ALIAS_NAMES = map {$DEVICE_ALIASES_ARR[$_]}
                         grep {$_ % 2 == 0} (0..$#DEVICE_ALIASES_ARR);
my %DEVICE_ALIASES = @DEVICE_ALIASES_ARR;

my @COMMAND_ALIASES_ARR = (
  on        => 'POWER ON',
  off       => 'POWER OFF',
  toggle    => 'POWER TOGGLE',

  startOn   => 'PowerOnState 1',
  startOff  => 'PowerOnState 0',
  startLast => 'PowerOnState 3',

  default   => 'COLOR 99999999ff',
  warm      => 'COLOR 00000000ff',
  cold      => 'COLOR ffffffffff',
  bright    => 'COLOR ffffffffff',

  dim       => 'COLOR 0000000044',
  soft      => 'COLOR 0000000099',

  red       => 'COLOR ff00000000',
  green     => 'COLOR 00ff000000',
  blue      => 'COLOR 0000ff0000',

  cyan      => 'COLOR 00ffff0000',
  magenta   => 'COLOR ff00ff0000',
  yellow    => 'COLOR ffff000000',

  purple    => 'COLOR 8000800000',
  brown     => 'COLOR 6543210000',
);
my @COMMAND_ALIAS_NAMES = map {$COMMAND_ALIASES_ARR[$_]}
                          grep {$_ % 2 == 0} (0..$#COMMAND_ALIASES_ARR);
my %COMMAND_ALIASES = @COMMAND_ALIASES_ARR;

my %DEVICE_CONFIG_COMMANDS = (
  bulb1   => [qw(startOn default)],
  bulb2   => [qw(startOn default)],
  bulb3   => [qw(startOn default)],
  outlet1 => [qw(startLast)],
  outlet2 => [qw(startLast)],
  outlet3 => [qw(startLast)],
);

my $DEVICES_REGEX = join "|", sort keys %DEVICES;

my $DEVICE_ALIASES_REGEX = join "|", sort keys %DEVICE_ALIASES;
my $DEVICE_ALIAS_FMT = join "",
                       map {sprintf "      %-5s = %s\n", $_, "@{$DEVICE_ALIASES{$_}}"}
                       @DEVICE_ALIAS_NAMES;

my $COMMAND_ALIAS_FMT = join "",
                        map {sprintf "    %-10s = %s\n", $_, "$COMMAND_ALIASES{$_}"}
                        @COMMAND_ALIAS_NAMES;


my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC -s | --setup-wifi
    assuming connection to newly flashed/reset tasmota device,
    send command to $INITIAL_DEVICE_IP to set:
    SSID1=$WIFI_SSID
    Password1=`winfo --key $WIFI_SSID`
      to set up a new device:
        -connect to SSID (looks like: tasmota_FFFFFF-9999)
        -run `$EXEC --mac init` (and note the MAC)
        -run `$EXEC --setup-wifi`
        -add a static DHCP entry for MAC and add to device list
        -restart router
        -add configuration commands, and then run `$EXEC --config <DEVICE>`

  $EXEC --config [DEVICE DEVICE ..]
    run the device-specific config commands for each <DEVICE>

  $EXEC [DEVICE DEVICE ..] COMMAND
    use curl to send <COMMAND> to each named <DEVICE>
    <DEVICE> defaults to '$DEFAULT_DEVICE' if none are given
    available <DEVICE> arguments:
      $DEVICE_ALIASES_REGEX|$DEVICES_REGEX

  $EXEC [DEVICE DEVICE ..] COMMAND_ALIAS
    get <COMMAND> from <COMMAND_ALIAS> (case insensitive)
    same as: $EXEC DEVICE DEVICE .. COMMAND

  $EXEC --toggle-all  [DEVICE DEVICE ..]
  $EXEC -t [DEVICE DEVICE ..]
  $EXEC [DEVICE DEVICE ..]
    either turn on all devices, or turn off all devices,
      by toggling all and then turning off stragglers
    -send 'POWER TOGGLE' to all devices
    -check the current power status after toggling
    -if at least one is 'OFF' and at least one is 'ON', send 'off' to all

  $EXEC --mac [DEVICE DEVICE ..]
    send 'Status 0' command and parse the output to get the MAC address

  DEVICE = DEVICE_NAME | DEVICE_ALIAS
    name of device, or named alias for a list of devices

    DEVICE_NAME
      $DEVICES_REGEX

    DEVICE_ALIAS"
      . "\n$DEVICE_ALIAS_FMT"
      . "
  COMMAND_ALIAS"
    . "\n$COMMAND_ALIAS_FMT"
    . "
";

sub runCommandOnDevices($@);
sub cmd($$);

my $MODE_COMMAND = "command";
my $MODE_TOGGLE_ALL = "toggle-all";
my $MODE_MAC = "mac";
my $MODE_SETUP_WIFI = "setup-wifi";
my $MODE_CONFIG_DEVICE = "config-device";

sub main(@){
  my $mode = $MODE_TOGGLE_ALL;
  my (@devices, $cmd);
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-s|--setup-wifi)$/){
      $mode = $MODE_SETUP_WIFI;
    }elsif($arg =~ /^(--config)$/){
      $mode = $MODE_CONFIG_DEVICE;
    }elsif($arg =~ /^($DEVICES_REGEX)$/){
      push @devices, $arg;
    }elsif($arg =~ /^($DEVICE_ALIASES_REGEX)$/){
      @devices = (@devices, @{$DEVICE_ALIASES{$arg}});
    }elsif($arg =~ /^(--toggle-all|-t)$/){
      $mode = $MODE_TOGGLE_ALL;
      $cmd = undef;
    }elsif($arg =~ /^(--mac)$/){
      $mode = $MODE_MAC;
      $cmd = undef;
    }elsif(defined $COMMAND_ALIASES{lc $arg}){
      $mode = $MODE_COMMAND;
      $cmd = $COMMAND_ALIASES{lc $arg};
    }elsif(not defined $cmd and @_ == 0){
      $mode = $MODE_COMMAND;
      $cmd = $arg;
    }else{
      die $USAGE;
    }
  }

  push @devices, $DEFAULT_DEVICE if @devices == 0;

  if($mode eq $MODE_COMMAND){
    my $outputByDevice = runCommandOnDevices($cmd, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
  }elsif($mode eq $MODE_TOGGLE_ALL){
    print "toggling all =>\n";
    my $outputByDevice = runCommandOnDevices("POWER TOGGLE", @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    my $someOff = 0;
    my $someOn = 0;
    for my $device(@devices){
      my $output = $$outputByDevice{$device};
      $output = "" if not defined $output;
      if($output =~ /{"POWER":"OFF"}/i){
        $someOff = 1;
      }elsif($output =~ /{"POWER":"ON"}/i){
        $someOn = 1;
      }
    }
    if($someOff and $someOn){
      print "\nsome devices off, some devices on, turning all off =>\n";
      $outputByDevice = runCommandOnDevices("POWER OFF", @devices);
      print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    }
  }elsif($mode eq $MODE_MAC){
    my $outputByDevice = runCommandOnDevices("STATUS 0", @devices);
    for my $device(@devices){
      my $out = $$outputByDevice{$device};
      my $mac = $1 if $out =~ /"Mac":"([^"]+)"/;
      $mac = "?" if not defined $mac;
      print "$device - $mac\n";
    }
  }elsif($mode eq $MODE_SETUP_WIFI){
    my $key = `winfo --key $WIFI_SSID`;
    chomp $key;
    cmd $INITIAL_DEVICE_IP, "BACKLOG SSID1 $WIFI_SSID ; Password1 $key";
  }elsif($mode eq $MODE_CONFIG_DEVICE){
    for my $device(@devices){
      my $cmds = $DEVICE_CONFIG_COMMANDS{$device};
      if(not defined $cmds){
        print "$device - no config commands found\n";
        next;
      }
      for my $cmd(@$cmds){
        if(defined $COMMAND_ALIASES{$cmd}){
          $cmd = $COMMAND_ALIASES{$cmd};
        }
        my $out = cmd($DEVICES{$device}, $cmd);
        print "$device - $cmd - $out\n";
      }
    }
  }else{
    die "ERROR: unknown mode \"$mode\"\n";
  }
}

sub runCommandOnDevices($@){
  my ($cmd, @devices) = @_;
  my $outputByDevice = {};
  if($FORKMGR_LIB){
    my $tmpDir = "/tmp/$EXEC-perl-storable";
    $ENV{TMPDIR} = $tmpDir;
    system "mkdir", "-p", "/tmp/$EXEC-perl-storable";

    my $pm = Parallel::ForkManager->new(10, $tmpDir);
    $pm->set_waitpid_blocking_sleep(0);  #enable true blocking calls

    for my $device(@devices){
      if(defined $$outputByDevice{$device}){
        die "ERROR: duplicate device $device (not allowed in parallel)\n";
      }
      $$outputByDevice{$device} = "UNKNOWN";
    }

    $pm->run_on_finish(
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
        $$outputByDevice{$ident} = $$data_structure_reference;
      }
    );

    for my $device(@devices){
      my $pid = $pm->start($device);
      next if $pid;

      my $out = cmd $DEVICES{$device}, $cmd;
      $pm->finish(0, \$out);
    }
    $pm->wait_all_children();
  }else{
    for my $device(@devices){
      my $out = cmd $DEVICES{$device}, $cmd;
      $$outputByDevice{$device} = $out;
    }
  }
  return $outputByDevice;
}

sub cmd($$){
  my ($deviceIP, $cmd) = @_;
  $cmd =~ s/ /%20/g;
  $cmd =~ s/;/%3B/g;
  $cmd =~ s/'/'\\''/g;
  my $out = `curl -s 'http://$deviceIP/cm?cmnd=$cmd'`;
  return $out;
}

&main(@ARGV);
