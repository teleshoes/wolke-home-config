#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
my $FORKMGR_LIB = eval {require Parallel::ForkManager};

my $DEFAULT_DEVICE = "outlet1";
my $DEFAULT_COMMAND = "POWER TOGGLE";

my $DEVICES = {
  bulb1   => "192.168.11.93",
  bulb2   => "192.168.11.94",
  bulb3   => "192.168.11.95",
  outlet1 => "192.168.11.96",
  outlet2 => "192.168.11.97",
  outlet3 => "192.168.11.98",
};
my $DEVICE_ALIASES = {
  "b"     => [qw(bulb1 bulb2 bulb3)],
  "bulbs" => [qw(bulb1 bulb2 bulb3)],
};

my $DEVICES_REGEX = join "|", sort keys %$DEVICES;
my $DEVICE_ALIASES_REGEX = join "|", sort keys %$DEVICE_ALIASES;
my $DEVICE_ALIAS_FMT =
  join "", map {"      $_ = @{$$DEVICE_ALIASES{$_}}\n"} sort keys %$DEVICE_ALIASES;

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [DEVICE DEVICE ..] COMMAND
    use curl to send <COMMAND> to each named <DEVICE>
    <DEVICE> defaults to '$DEFAULT_DEVICE' if none are given
    available <DEVICE> arguments:
      $DEVICE_ALIASES_REGEX|$DEVICES_REGEX

  $EXEC [DEVICE DEVICE ..]
    same as: $EXEC [DEVICE DEVICE ..] '$DEFAULT_COMMAND'

  DEVICE = DEVICE_NAME | DEVICE_ALIAS
    name of device, or named alias for a list of devices

    DEVICE_NAME
      $DEVICES_REGEX

    DEVICE_ALIAS" . "\n$DEVICE_ALIAS_FMT\n" . "
";

sub runCommandOnDevices($@);
sub cmd($$);

sub main(@){
  my (@devices, $cmd);
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^($DEVICES_REGEX)$/){
      push @devices, $arg;
    }elsif($arg =~ /^($DEVICE_ALIASES_REGEX)$/){
      @devices = (@devices, @{$$DEVICE_ALIASES{$arg}});
    }elsif(not defined $cmd and @_ == 0){
      $cmd = $arg;
    }else{
      die $USAGE;
    }
  }

  push @devices, $DEFAULT_DEVICE if @devices == 0;
  $cmd = $DEFAULT_COMMAND if not defined $cmd;
  runCommandOnDevices($cmd, @devices);
}

sub runCommandOnDevices($@){
  my ($cmd, @devices) = @_;
  my $outputByDevice = {};
  if($FORKMGR_LIB){
    my $tmpDir = "/tmp/$EXEC-perl-storable";
    $ENV{TMPDIR} = $tmpDir;
    system "mkdir", "-p", "/tmp/$EXEC-perl-storable";

    my $pm = Parallel::ForkManager->new(10, $tmpDir);
    $pm->set_waitpid_blocking_sleep(0);  #enable true blocking calls

    for my $device(@devices){
      if(defined $$outputByDevice{$device}){
        die "ERROR: duplicate device $device (not allowed in parallel)\n";
      }
      $$outputByDevice{$device} = "UNKNOWN";
    }

    $pm->run_on_finish(
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
        $$outputByDevice{$ident} = $$data_structure_reference;
      }
    );

    for my $device(@devices){
      my $pid = $pm->start($device);
      next if $pid;

      my $out = cmd $device, $cmd;
      $pm->finish(0, \$out);
    }
    $pm->wait_all_children();

    for my $device(@devices){
      print "$device - $$outputByDevice{$device}\n";
    }
  }else{
    for my $device(@devices){
      my $out = cmd $device, $cmd;
      $$outputByDevice{$device} = $out;
      print "$device - $out\n";
    }
  }
  return $outputByDevice;
}

sub cmd($$){
  my ($device, $cmd) = @_;
  $cmd =~ s/ /%20/g;
  my $out = `curl -s http://$$DEVICES{$device}/cm?cmnd=$cmd`;
  return $out;
}

&main(@ARGV);
