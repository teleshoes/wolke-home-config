#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use List::Util qw(first);
my $FORKMGR_LIB = eval {require Parallel::ForkManager};

sub readMinDimmer(@);
sub runCommandOnDevices($@);
sub cmd($$);
sub parseVersion($);
sub cmpVersion($$);

my $MAX_TIMEOUT_MILLIS = 1200;
my $MAX_COMMAND_ATTEMPTS = 2;

my $WIFI_SSID = "FlipsAFad";
my $INITIAL_DEVICE_IP = "192.168.4.1";
my $DEFAULT_DEVICE = "outlet1";
my $INIT_DEVICE = "init";

my @DEVICES_ARR = (
  $INIT_DEVICE => [$INITIAL_DEVICE_IP, undef, [], []],

  bulb1   => ["192.168.11.93", "athom_7w",     [qw(b1 all b bulbs   liv)], [qw(starton dimnopow default)]],
  bulb2   => ["192.168.11.94", "athom_7w",     [qw(b2 all b bulbs   liv)], [qw(starton dimnopow default)]],
  bulb3   => ["192.168.11.95", "athom_7w",     [qw(b3 all b bulbs   liv)], [qw(starton dimnopow default)]],
  bulb4   => ["192.168.11.30", "athom_7w",     [qw(b4 all b bulbs   bed)], [qw(starton dimnopow default)]],
  bulb5   => ["192.168.11.31", "kauf_10w",     [qw(b5 all b bulbs   bed)], [qw(starton dimnopow default)]],
  bulb6   => ["192.168.11.32", "kauf_10w",     [qw(b6 all b bulbs   bed)], [qw(starton dimnopow default)]],
  bulb7   => ["192.168.11.33", "kauf_10w",     [qw(b7 all b bulbs   bed)], [qw(starton dimnopow default)]],
  outlet1 => ["192.168.11.96", "athom_outlet", [qw(o1 all              )], [qw(startlast               )]],
  outlet2 => ["192.168.11.97", "athom_outlet", [qw(o2 all              )], [qw(startlast               )]],
  outlet3 => ["192.168.11.98", "athom_outlet", [qw(o3 all              )], [qw(startlast               )]],
  outlet4 => ["192.168.11.99", "athom_outlet", [qw(o4 all              )], [qw(startlast               )]],
  outlet5 => ["192.168.11.10", "athom_outlet", [qw(o5 all              )], [qw(startlast               )]],
);
my %DEVICES = @DEVICES_ARR;
my @DEVICE_NAMES = map {$DEVICES_ARR[$_]} grep {$_ % 2 == 0} (0..$#DEVICES_ARR);

my %DEVICE_IPS             = map {$_ => ${$DEVICES{$_}}[0]} @DEVICE_NAMES;
my %DEVICE_TYPES           = map {$_ => ${$DEVICES{$_}}[1]} @DEVICE_NAMES;
my %DEVICE_ALIASES         = map {$_ => ${$DEVICES{$_}}[2]} @DEVICE_NAMES;
my %DEVICE_CONFIG_COMMANDS = map {$_ => ${$DEVICES{$_}}[3]} @DEVICE_NAMES;

my %OK_ALL_DEVICE_ALIASES = map {$_ => 1} map {@{$DEVICE_ALIASES{$_}}} @DEVICE_NAMES;

my %DEVICES_BY_ALIAS = map {$_ => []} sort keys %OK_ALL_DEVICE_ALIASES;
for my $device(@DEVICE_NAMES){
  my %okAliases = map {$_ => 1} @{$DEVICE_ALIASES{$device}};
  for my $alias(sort keys %OK_ALL_DEVICE_ALIASES){
    push @{$DEVICES_BY_ALIAS{$alias}}, $device if defined $okAliases{$alias};
  }
}

my @DEVICE_ALIAS_NAMES = sort {
  my @aDevs = @{$DEVICES_BY_ALIAS{$a}};
  my @bDevs = @{$DEVICES_BY_ALIAS{$b}};
  my $aSize = 0 + @aDevs;
  my $bSize = 0 + @bDevs;
  my $aIsSingle = $aSize == 1 ? 1 : 0;
  my $bIsSingle = $bSize == 1 ? 1 : 0;
  my $aFirstDevIndex = first {$aDevs[0] eq $DEVICE_NAMES[$_]} 0..$#DEVICE_NAMES;
  my $bFirstDevIndex = first {$bDevs[0] eq $DEVICE_NAMES[$_]} 0..$#DEVICE_NAMES;

  return $aIsSingle <=> $bIsSingle          #single-device aliases last
    || $aFirstDevIndex <=> $bFirstDevIndex  #sort groups by first device
    || $bSize <=> $aSize                    #show larger groups first, within same first dev
    || $a cmp $b                            #sort by alias name last as tie-breaker
  ;
} keys %OK_ALL_DEVICE_ALIASES;


my %DEV_TEMPLATES_GPIO_CMND_CFG = (
  athom_7w     => '"GPIO":[0,0,0,0,37,40,0,0,38,41,39,0,0]',
  athom_15w    => '"GPIO":[0,0,0,0,416,419,0,0,417,452,418,0,0,0]',
  kauf_10w     => '"GPIO":[0,0,0,0,416,419,0,0,417,420,418,0,0,0]'
                    . ',"CMND":"SO105 1|RGBWWTable 204,204,122,153,153"',
  athom_outlet => '"GPIO":[0,0,0,32,2720,2656,0,0,2624,320,224,0,0,1]',
);

my %DEV_TEMPLATES = map { $_ => ''
  . '{ "NAME":"' . $_ . '",'
  . $DEV_TEMPLATES_GPIO_CMND_CFG{$_}
  . ',"FLAG":0'
  . ',"BASE":18}'
} sort keys %DEV_TEMPLATES_GPIO_CMND_CFG;

my @COMMAND_ALIASES_ARR = (
  on        => 'POWER ON',
  off       => 'POWER OFF',
  toggle    => 'POWER TOGGLE',

  starton   => 'PowerOnState 1',
  startoff  => 'PowerOnState 0',
  startlast => 'PowerOnState 3',
  dimnopow  => 'SetOption20 1',

  default   => 'COLOR 99999999ff',
  warm      => 'COLOR 00000000ff',
  cold      => 'COLOR ffffffffff',
  bright    => 'COLOR ffffffffff',

  dim       => 'COLOR 0000000044',
  soft      => 'COLOR 0000000099',

  red       => 'COLOR ff00000000',
  green     => 'COLOR 00ff000000',
  blue      => 'COLOR 0000ff0000',

  cyan      => 'COLOR 00ffff0000',
  magenta   => 'COLOR ff00ff0000',
  yellow    => 'COLOR ffff000000',

  purple    => 'COLOR 8000800000',
  brown     => 'COLOR 6543210000',

  d10       => 'DIMMER 10',
  d20       => 'DIMMER 20',
  d30       => 'DIMMER 30',
  d40       => 'DIMMER 40',
  d50       => 'DIMMER 50',
  d60       => 'DIMMER 60',
  d70       => 'DIMMER 70',
  d80       => 'DIMMER 80',
  d90       => 'DIMMER 90',
  d100      => 'DIMMER 100',
);
my @COMMAND_ALIAS_NAMES = map {$COMMAND_ALIASES_ARR[$_]}
                          grep {$_ % 2 == 0} (0..$#COMMAND_ALIASES_ARR);
my %COMMAND_ALIASES = @COMMAND_ALIASES_ARR;

my $DEVICES_REGEX = join "|", @DEVICE_NAMES;

my $DEVICE_ALIASES_REGEX = join "|", @DEVICE_ALIAS_NAMES;
my $DEVICE_ALIAS_FMT = join "",
                       map {sprintf "      %-5s = %s\n", $_, "@{$DEVICES_BY_ALIAS{$_}}"}
                       @DEVICE_ALIAS_NAMES;

my $COMMAND_ALIAS_FMT = join "",
                        map {sprintf "    %-10s = %s\n", $_, "$COMMAND_ALIASES{$_}"}
                        @COMMAND_ALIAS_NAMES;


my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS] -s | --setup-wifi [--ssid=WIFI_SSID] [DEVICE DEVICE ..]
    if no device is specified, defaults to $DEVICE_IPS{init}
      (this is the IP for newly flashed/reset tasmota devices)
    WIFI_SSID defaults to $WIFI_SSID
    send BACKLOG command to set:
      SSID1=WIFI_SSID
      Password1=`winfo --key WIFI_SSID`
    NOTE: to set up a new device:
        -connect to SSID (looks like: tasmota_FFFFFF-9999)
        -run `$EXEC --mac init` (and note the MAC)
        -run `$EXEC --setup-wifi`
        -add a static DHCP entry for MAC
        -add IP, device type, device aliases, and init commands to device list
        -restart router, and wait for device to be pingable again
        -run `$EXEC --template <DEVICE>` #and wait for it be pingable again
        -run `$EXEC --config <DEVICE>`
    TO FLASH TASMOTA ON KAUF:
        -change ROUTER ssid + wpa => initial_ap2 + asdfasdfasdfasdf
        -plug in device, will flash when connected (try 'initial_ap' if not)
        -find device on local network, open in google-chrome
        -open network tab, click 'upload', and select:
            /media/stuff/Images/tasmota/tasmota_12.1.1_2022-08-25_13-59.bin.gz
        -if nothing happens, open the same tab in chrome and see if you see debug log
        -if debug log gets all the way to 100, tasmota SSID will probably appear in a min
        -otherwise, wait 1min, turn off bulb, and start over, maybe bricking device

  $EXEC [OPTS] --config [DEVICE DEVICE ..]
    run the device-specific config commands for each <DEVICE>

  $EXEC [OPTS] --template [DEVICE DEVICE ..]
    get device type for each device, lookup template for type, and set it

  $EXEC [OPTS] [DEVICE DEVICE ..] COMMAND
    use curl to send <COMMAND> to each named <DEVICE>
    <DEVICE> defaults to '$DEFAULT_DEVICE' if none are given
    available <DEVICE> arguments:
      $DEVICE_ALIASES_REGEX|$DEVICES_REGEX

  $EXEC [OPTS] [DEVICE DEVICE ..] COMMAND_ALIAS
    get <COMMAND> from <COMMAND_ALIAS> (case insensitive)
    same as: $EXEC DEVICE DEVICE .. COMMAND

  $EXEC [OPTS] --toggle-all  [DEVICE DEVICE ..]
  $EXEC [OPTS] -t [DEVICE DEVICE ..]
  $EXEC [OPTS] [DEVICE DEVICE ..]
    either turn on all devices, or turn off all devices,
      by toggling all and then turning off stragglers
    -send 'POWER TOGGLE' to all devices
    -check the current power status after toggling
    -if at least one is 'OFF' and at least one is 'ON', send 'off' to all

  $EXEC [OPTS] --dimmer [DEVICE DEVICE ..] DIMMER_PCT_ARG [DIMMER_PCT_ARG DIMMER_PCT_ARG]
  $EXEC [OPTS] [DEVICE DEVICE ..] DIMMER_PCT_ARG [DIMMER_PCT_ARG DIMMER_PCT_ARG]
    -get the current <DIMMER_PCT> value from all devices, and select the smallest value
    -select the smallest <DIMMER_PCT_ARG> that is strictly greater than <DIMMER_PCT>
    -if there is no such <DIMMER_PCT_ARG>, use the smallest <DIMMER_PCT_ARG> given
    -run command 'DIMMER <DIMMER_PCT_ARG>'
      e.g.:
        $EXEC --dimmer 33 66 100     #DIMMER 100 => 33
        $EXEC --dimmer 33 66 100     #DIMMER 33  => 66
        $EXEC --dimmer 33 66 100     #DIMMER 66  => 100

  $EXEC [OPTS] --power|power|pow|--watts|watts|watt [DEVICE DEVICE ..]
    -run 'STATUS 10' (show connected sensor information)
    -parse out JSON result: StatusSNS.ENERGY.Power
    -print integer power in Watts, one per line, for each DEVICE, in order given

  $EXEC [OPTS] --mac [DEVICE DEVICE ..]
    send 'Status 0' command and parse the output to get the MAC address

  DEVICE = DEVICE_NAME | DEVICE_IP4 | DEVICE_IP4_OVERRIDE | DEVICE_ALIAS
    name or IP or both of a single device, or named alias for a list of devices

    DEVICE_NAME
      $DEVICES_REGEX

    DEVICE_IP4
      IPv4 address of device

    DEVICE_IP4_OVERRIDE
      <DEVICE_NAME>=<DEVICE_IP4>
      set the DEVICE_IP4 for the DEVICE_NAME, e.g.: outlet1=192.168.11.105

    DEVICE_ALIAS"
      . "\n$DEVICE_ALIAS_FMT"
      . "
  COMMAND_ALIAS"
    . "\n$COMMAND_ALIAS_FMT"
    . "

  OPTS
";

my $MODE_COMMAND = "command";
my $MODE_TOGGLE_ALL = "toggle-all";
my $MODE_DIMMER = "dimmer";
my $MODE_POWER = "power";
my $MODE_MAC = "mac";
my $MODE_SETUP_WIFI = "setup-wifi";
my $MODE_CONFIG_DEVICE = "config-device";
my $MODE_SET_TEMPLATE = "set-template";

sub main(@){
  my $mode = $MODE_TOGGLE_ALL;
  my (@devices, $cmd, @dimmerArgs, $ssid);
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-s|--setup-wifi)$/){
      $mode = $MODE_SETUP_WIFI;
    }elsif($arg =~ /^(--config)$/){
      $mode = $MODE_CONFIG_DEVICE;
    }elsif($arg =~ /^(--template)$/){
      $mode = $MODE_SET_TEMPLATE;
    }elsif($arg =~ /^($DEVICES_REGEX)$/){
      push @devices, $arg;
    }elsif($arg =~ /^($DEVICE_ALIASES_REGEX)$/){
      @devices = (@devices, @{$DEVICES_BY_ALIAS{$arg}});
    }elsif($arg =~ /^(\d+\.\d+\.\d+\.\d+)$/){
      push @devices, $arg;
    }elsif($arg =~ /^($DEVICES_REGEX)=(\d+\.\d+\.\d+\.\d+)$/){
      my ($device, $ip) = ($1, $2);
      $DEVICE_IPS{$device} = $ip;
      push @devices, $device;
    }elsif($arg =~ /^(--toggle-all|-t)$/){
      $mode = $MODE_TOGGLE_ALL;
      $cmd = undef;
    }elsif($arg =~ /^(--dimmer)$/){
      $mode = $MODE_DIMMER;
      $cmd = undef;
    }elsif($arg =~ /^(\d+)$/){
      push @dimmerArgs, $1;
      $mode = $MODE_DIMMER;
    }elsif($arg =~ /^(--power|power|pow|--watts|watts|watt)$/){
      $mode = $MODE_POWER;
      $cmd = undef;
    }elsif($arg =~ /^(--mac)$/){
      $mode = $MODE_MAC;
      $cmd = undef;
    }elsif($arg =~ /^--ssid=(.+)$/){
      $ssid = $1;
    }elsif(defined $COMMAND_ALIASES{lc $arg}){
      $mode = $MODE_COMMAND;
      $cmd = $COMMAND_ALIASES{lc $arg};
    }elsif(not defined $cmd and @_ == 0){
      $mode = $MODE_COMMAND;
      $cmd = $arg;
    }else{
      die $USAGE;
    }
  }

  if(@devices == 0){
    @devices = $mode eq $MODE_SETUP_WIFI ? ($INIT_DEVICE) : ($DEFAULT_DEVICE);
  }

  if($mode eq $MODE_COMMAND){
    my $outputByDevice = runCommandOnDevices($cmd, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
  }elsif($mode eq $MODE_TOGGLE_ALL){
    print "toggling all =>\n";
    my $outputByDevice = runCommandOnDevices("POWER TOGGLE", @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    my $someOff = 0;
    my $someOn = 0;
    for my $device(@devices){
      my $output = $$outputByDevice{$device};
      $output = "" if not defined $output;
      if($output =~ /{"POWER":"OFF"}/i){
        $someOff = 1;
      }elsif($output =~ /{"POWER":"ON"}/i){
        $someOn = 1;
      }
    }
    if($someOff and $someOn){
      print "\nsome devices off, some devices on, turning all off =>\n";
      $outputByDevice = runCommandOnDevices("POWER OFF", @devices);
      print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    }
    #if toggled on, also run default cmd
    if(not $someOff){
      $outputByDevice = runCommandOnDevices($COMMAND_ALIASES{default}, @devices);
      print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    }
  }elsif($mode eq $MODE_DIMMER){
    die "ERROR: no DIMMER_PCT_ARG given\n" if @dimmerArgs == 0;
    my $curDimmer = readMinDimmer(@devices);
    @dimmerArgs = sort {$a <=> $b} @dimmerArgs;
    my $targetDimmerVal = undef;
    for my $dimmerArg(@dimmerArgs){
      if($dimmerArg > $curDimmer){
        $targetDimmerVal = $dimmerArg;
        last;
      }
    }
    $targetDimmerVal = $dimmerArgs[0] if not defined $targetDimmerVal;
    print "dimmer $curDimmer => $targetDimmerVal\n";
    my $outputByDevice = runCommandOnDevices("Dimmer $targetDimmerVal", @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
  }elsif($mode eq $MODE_POWER){
    my $outputByDevice = runCommandOnDevices("Status 10", @devices);
    for my $device(@devices){
      my $json = $$outputByDevice{$device};
      my $power;
      if($json =~ /^{"StatusSNS".*"ENERGY":.*"Power":(\d+|\d*\.\d+)/){
        $power = $1;
      }
      $power = "???" if not defined $power;
      print "$power\n";
    }
  }elsif($mode eq $MODE_MAC){
    my $outputByDevice = runCommandOnDevices("STATUS 0", @devices);
    for my $device(@devices){
      my $out = $$outputByDevice{$device};
      my $mac = $1 if $out =~ /"Mac":"([^"]+)"/;
      $mac = "?" if not defined $mac;
      print "$device - $mac\n";
    }
  }elsif($mode eq $MODE_SETUP_WIFI){
    $ssid = $WIFI_SSID if not defined $ssid;

    my $key = `winfo --key $ssid`;
    chomp $key;
    for my $device(@devices){
      my $wifiCmd = "BACKLOG SSID1 $ssid; Password1 $key";
      my $deviceIP = $device =~ /^\d+\.\d+\.\d+\.\d+$/ ? $device : $DEVICE_IPS{$device};
      print "$device ($deviceIP) => $wifiCmd\n";
      cmd($device, $wifiCmd);
    }
  }elsif($mode eq $MODE_CONFIG_DEVICE){
    for my $device(@devices){
      my $cmds = $DEVICE_CONFIG_COMMANDS{$device};
      if(not defined $cmds){
        print "$device - no config commands found\n";
        next;
      }
      for my $cmd(@$cmds){
        if(defined $COMMAND_ALIASES{$cmd}){
          $cmd = $COMMAND_ALIASES{$cmd};
        }
        my $out = cmd($device, $cmd);
        print "$device - $cmd - $out\n";
      }
    }
  }elsif($mode eq $MODE_SET_TEMPLATE){
    for my $device(@devices){
      my $type = $DEVICE_TYPES{$device};
      my $template = $DEV_TEMPLATES{$type};
      if(not defined $template){
        print "$device - no template found\n";
        next;
      }
      my $cmd = "TEMPLATE $template";
      my $out = cmd($device, $cmd);
      print "$device - $out\n";
    }
  }else{
    die "ERROR: unknown mode \"$mode\"\n";
  }
}

sub readMinDimmer(@){
  my (@devices) = @_;
  my $outputByDevice = runCommandOnDevices("DIMMER", @devices);
  my $minDimmer = 100;
  for my $device(@devices){
    my $output = $$outputByDevice{$device};
    $output = "" if not defined $output;
    if($output =~ /{"Dimmer":(\d+)}/i){
      my $dimmerVal = $1;
      if($dimmerVal < $minDimmer){
        $minDimmer = $dimmerVal;
      }
    }
  }
  return $minDimmer;
}

sub runCommandOnDevices($@){
  my ($cmd, @devices) = @_;
  my $outputByDevice = {};
  if($FORKMGR_LIB){
    my $tmpDir = "/tmp/$EXEC-perl-storable";
    $ENV{TMPDIR} = $tmpDir;
    system "mkdir", "-p", "/tmp/$EXEC-perl-storable";

    my $pm = Parallel::ForkManager->new(10, $tmpDir);
    $pm->set_waitpid_blocking_sleep(0);  #enable true blocking calls

    for my $device(@devices){
      if(defined $$outputByDevice{$device}){
        die "ERROR: duplicate device $device (not allowed in parallel)\n";
      }
      $$outputByDevice{$device} = "UNKNOWN";
    }

    $pm->run_on_finish(
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
        $$outputByDevice{$ident} = $$data_structure_reference;
      }
    );

    for my $device(@devices){
      my $pid = $pm->start($device);
      next if $pid;

      my $out = cmd $device, $cmd;
      $pm->finish(0, \$out);
    }
    $pm->wait_all_children();
  }else{
    for my $device(@devices){
      my $out = cmd $device, $cmd;
      $$outputByDevice{$device} = $out;
    }
  }
  return $outputByDevice;
}

sub cmd($$){
  my ($device, $cmd) = @_;
  my $deviceIP = $device =~ /^\d+\.\d+\.\d+\.\d+$/ ? $device : $DEVICE_IPS{$device};

  $cmd =~ s/ /%20/g;
  $cmd =~ s/;/%3B/g;
  $cmd =~ s/\{/%7B/g;
  $cmd =~ s/\}/%7D/g;
  $cmd =~ s/\[/%5B/g;
  $cmd =~ s/\]/%5D/g;
  $cmd =~ s/'/'\\''/g;

  my $timeout = sprintf "%.3f", ($MAX_TIMEOUT_MILLIS / 1000.0);
  my $curlCmd = "curl -m $timeout -s 'http://$deviceIP/cm?cmnd=$cmd'";

  my ($out, $exitCode);
  my $success = 0;
  my $attemptsRemaining = $MAX_COMMAND_ATTEMPTS;
  while(not $success and $attemptsRemaining > 0){
    $out = `$curlCmd`;
    $exitCode = $? >> 8;
    $attemptsRemaining--;

    if($out =~ /\S/){
      $success = 1;
    }elsif($exitCode == 2){
      my $curlVersion = `curl --version`;
      my $v = $1 if $curlVersion =~ /^curl (\d+\.[0-9\.]+)/;
      if($timeout =~ /\./ and cmpVersion($v, "7.32.0") < 0){
        $attemptsRemaining++;
        print STDERR "WARNING: curl version $v, changing timeout to integral seconds\n";
        $timeout = sprintf "%d", ($MAX_TIMEOUT_MILLIS / 1000.0);
        $curlCmd = "curl -m $timeout -s 'http://$deviceIP/cm?cmnd=$cmd'";
      }
      $success = 0;
    }elsif($exitCode == 28){
      #curl timeout
      $success = 0;
    }else{
      #treat any other exit code as success
      $success = 1;
    }
  }

  return $out;
}

sub parseVersion($){
  my ($v) = @_;
  my ($maj, $min, $pt);
  if($v =~ /^(\d+)\.(\d+)\.(\d+)$/){
    ($maj, $min, $pt) = ($1, $2, $3);
  }elsif($v =~ /^(\d+)\.(\d+)$/){
    ($maj, $min, $pt) = ($1, $2, 0);
  }elsif($v =~ /^(\d+)$/){
    ($maj, $min, $pt) = ($1, 0, 0);
  }else{
    die "ERROR: could not parse version \"$v\"\n";
  }

  return ($maj, $min, $pt);
}

sub cmpVersion($$){
  my ($v1, $v2) = @_;
  my ($maj1, $min1, $pt1) = parseVersion($v1);
  my ($maj2, $min2, $pt2) = parseVersion($v2);
  return ($maj1 <=> $maj2) || ($min1 <=> $min2) || ($pt1 <=> $pt2);
}

&main(@ARGV);
