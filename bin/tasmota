#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use List::Util qw(first);
use Time::HiRes qw(time);
use JSON qw(from_json);
my $FORKMGR_LIB = eval {require Parallel::ForkManager};

sub readDevicesConfig();
sub appendLog($$);
sub maybeRotateLog($);
sub rotateLog($);
sub extractDevicesByAlias($$);
sub sortAliasesByFirstDevice($$);
sub extractTemplateJSONByDevType($);
sub formatTemplateJSON($);

sub parseStatusJson($);
sub getNestedMapVal($@);
sub getSSID();
sub readMinDimmer($@);
sub runCommandOnDevices($$@);
sub cmd($$$);
sub parseVersion($);
sub cmpVersion($$);
sub readFile($);
sub writeFile($$);
sub nowMillis();

my $DEVICES_CONFIG_FILE = "$ENV{HOME}/.config/tasmota.conf";
my $LOG_DIR = "$ENV{HOME}/.cache/logs/tasmota";
my $DDWRT_CONFIG_FILE = "$ENV{HOME}/ddwrt/68u";
my $DEFAULT_MAX_TIMEOUT_MILLIS = 1200;
my $DEFAULT_MAX_COMMAND_ATTEMPTS = 2;

my $INITIAL_DEVICE_IP = "192.168.4.1";

my @DEVICES_ARR = readDevicesConfig();
my %DEVICES = @DEVICES_ARR;
my @DEVICE_NAMES = map {$DEVICES_ARR[$_]} grep {$_ % 2 == 0} (0..$#DEVICES_ARR);
my $DEVICES_REGEX = join "|", @DEVICE_NAMES;
my %DEVICE_HOSTNAMES       = map {$_ => ${$DEVICES{$_}}[0]} @DEVICE_NAMES;
my %DEVICE_MACS            = map {$_ => ${$DEVICES{$_}}[1]} @DEVICE_NAMES;
my %DEVICE_IPS             = map {$_ => ${$DEVICES{$_}}[2]} @DEVICE_NAMES;
my %DEVICE_SSIDS           = map {$_ => ${$DEVICES{$_}}[3]} @DEVICE_NAMES;
my %DEVICE_TYPES           = map {$_ => ${$DEVICES{$_}}[4]} @DEVICE_NAMES;
my %DEVICE_ALIASES         = map {$_ => ${$DEVICES{$_}}[5]} @DEVICE_NAMES;

my %DEVICES_BY_ALIAS = extractDevicesByAlias([@DEVICE_NAMES], {%DEVICE_ALIASES});
my @DEVICE_ALIAS_NAMES = sortAliasesByFirstDevice([@DEVICE_NAMES], {%DEVICES_BY_ALIAS});
my $DEVICE_ALIASES_REGEX = join "|", @DEVICE_ALIAS_NAMES;


my @DEV_TYPES_ARR = (
  #DEV_TYPE    => [INIT_CMDS,                       POWER_ON_CMDS, TEMPLATE_GPIO_CONFIG]
  athom_7w     => [[qw(starton dimnopow normal)],   [qw(normal)],  [ GPIO => '[0,0,0,0,37,40,0,0,38,41,39,0,0]']],
  athom_15w    => [[qw(starton dimnopow normal)],   [qw(normal)],  [ GPIO => '[0,0,0,0,416,419,0,0,417,452,418,0,0,0]']],
  kauf_10w     => [[qw(starton dimnopow normal)],   [qw(normal)],  [ GPIO => '[0,0,0,0,416,419,0,0,417,420,418,0,0,0]',
                                                                     CMND => '"SO105 1|RGBWWTable 204,204,122,153,153"']],
  athom_outlet => [[qw(startlast energyres tz_ny)], [qw()],        [ GPIO => '[0,0,0,32,2720,2656,0,0,2624,320,224,0,0,1]']],
  cf_switch    => [[qw(startlast)],                 [qw()],        [ GPIO => '[0,224,0,32,320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]']],
  athom_switch => [[qw(startlast)],                 [qw()],        [ GPIO => '[576,0,0,32,0,0,0,0,0,224,320,0,0,0']],
);
my %DEV_TYPES = @DEV_TYPES_ARR;
my @DEV_TYPE_NAMES = map {$DEV_TYPES_ARR[$_]} grep {$_ % 2 == 0} (0..$#DEV_TYPES_ARR);
my %DEV_TYPE_INIT_CMDS         = map {$_ => ${$DEV_TYPES{$_}}[0]} @DEV_TYPE_NAMES;
my %DEV_TYPE_POWER_ON_CMDS     = map {$_ => ${$DEV_TYPES{$_}}[1]} @DEV_TYPE_NAMES;
my %DEV_TYPE_TEMPLATE_GPIO_CFG = map {$_ => ${$DEV_TYPES{$_}}[2]} @DEV_TYPE_NAMES;

my %DEV_TYPE_TEMPLATE_JSON = extractTemplateJSONByDevType({%DEV_TYPE_TEMPLATE_GPIO_CFG});


my @COMMAND_ALIASES_ARR = (
  #ALIAS    => COMMAND
  starton   => 'PowerOnState 1',
  startoff  => 'PowerOnState 0',
  startlast => 'PowerOnState 3',
  energyres => 'EnergyRes 5',
  dimnopow  => 'SetOption20 1',

  tz_ny     => 'Backlog Timezone 99; TimeStd 0,1,11,1,2,-300; TimeDst 0,2,3,1,2,-240',

  normal    => 'COLOR 99999999ff',
  warm      => 'COLOR 00000000ff',
  cold      => 'COLOR ffffffffff',
  bright    => 'COLOR ffffffffff',

  dim       => 'COLOR 0000000044',
  soft      => 'COLOR 0000000099',
  softyel   => 'COLOR 9171000070',

  red       => 'COLOR ff00000000',
  green     => 'COLOR 00ff000000',
  blue      => 'COLOR 0000ff0000',

  cyan      => 'COLOR 00ffff0000',
  magenta   => 'COLOR ff00ff0000',
  yellow    => 'COLOR ffff000000',

  purple    => 'COLOR 8000800000',
  brown     => 'COLOR 6543210000',

  map {("d$_" => "DIMMER $_")} (10,20,30,40,50,60,70,80,90,100), #e.g.: d10 => DIMMER 10
);
my %COMMAND_ALIASES = @COMMAND_ALIASES_ARR;
my @COMMAND_ALIAS_NAMES = map {$COMMAND_ALIASES_ARR[$_]}
                          grep {$_ % 2 == 0} (0..$#COMMAND_ALIASES_ARR);



my $MODE_COMMAND = "command";
my $MODE_TOGGLE = "toggle";
my $MODE_ON = "on";
my $MODE_OFF = "off";
my $MODE_DIMMER = "dimmer";
my $MODE_INFO = "info";
my $MODE_MAC = "mac";
my $MODE_DDWRT = "ddwrt";
my $MODE_SET_SSID = "set-ssid";
my $MODE_CONFIG_DEVICE = "config-device";
my $MODE_SET_TEMPLATE = "set-template";


my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS] --ssid=WIFI_SSID DEVICE [DEVICE DEVICE ..]
    -fetch WIFI_PASSWORD using `winfo --key WIFI_ROUTER_SSID`
    -run the command \"BACKLOG SSID1 <WIFI_SSID>; Password1 <WIFI_PASSWORD>\" on each DEVICE
      -use 'init' for DEVICE if connected to tasmota initial wifi network

  $EXEC --ssid DEVICE [DEVICE DEVICE ..]
    -for each DEVICE:
      -if DEVICE is a named device in $DEVICES_CONFIG_FILE
        -use TARGET_SSID for that device as WIFI_SSID
      -if DEVICE is not a named device:
        -get the CURRENT_SSID with `wstatus --ssid`
        -if CURRENT_SSID matches the HOSTNAME of a device:
          -use the TARGET_SSID for that device
      -same as: $EXEC --ssid=WIFI_SSID

    NOTE: to set up a new tasmota device named 'KITCHEN1':
        -connect to tasmota SSID, e.g.: tasmota_123FED-9922
        -run `$EXEC --mac init`
        -run `$EXEC --ssid=DESIRED_WIFI_SSID init`
        -add device entry to $DEVICES_CONFIG_FILE with:
           desired name
           ACTUAL  device hostname/SSID (e.g.: tasmota_123FED-9922)
           ACTUAL  device MAC
           desired IP on local network
           desired local network SSID
           ACTUAL  device type (one of: @DEV_TYPE_NAMES)
           desired device aliases
         e.g.:
            KITCHEN1 | tasmota_123FED-9922 | 12:34:56:78:9A:BC | 192.168.11.99 | MyNetwork | cf_switch | k1
        -run `$EXEC --ddwrt` to populate MAC and desired IP in ddwrt config
        -run `ddwrt --restore` to setup+restart router
        -wait for device to be pingable on the desired IP address
        -run `$EXEC --template KITCHEN1`
          -wait for it be pingable again
        -run `$EXEC --config KITCHEN1`
          -should still be pingable

    TO FLASH TASMOTA ON KAUF:
        -change ROUTER ssid + wpa => initial_ap2 + asdfasdfasdfasdf
        -plug in device, will flash when connected (try 'initial_ap' if not)
        -find device on local network, open in google-chrome
        -open network tab, click 'upload', and select:
            /media/stuff/Images/tasmota/tasmota_12.1.1_2022-08-25_13-59.bin.gz
        -if nothing happens, open the same tab in chrome and see if you see debug log
        -if debug log gets all the way to 100, tasmota SSID will probably appear in a min
        -otherwise, wait 1min, turn off bulb, and start over, maybe bricking device

  $EXEC [OPTS] --config DEVICE [DEVICE DEVICE ..]
    run the device-specific config commands for each <DEVICE>

  $EXEC [OPTS] --template DEVICE [DEVICE DEVICE ..]
    get device type for each device, lookup template for type, and set it with 'Template'
    also apply the template with 'Module 0'

  $EXEC [OPTS] DEVICE [DEVICE ..] COMMAND
    use curl to send <COMMAND> to each named <DEVICE>
    available <DEVICE> arguments:
      $DEVICE_ALIASES_REGEX|$DEVICES_REGEX

  $EXEC [OPTS] DEVICE [DEVICE ..] COMMAND_ALIAS
    get <COMMAND> from <COMMAND_ALIAS> (case insensitive)
    same as: $EXEC DEVICE DEVICE .. COMMAND

  $EXEC [OPTS] DEVICE [DEVICE ..]
  $EXEC [OPTS] -t|--toggle|toggle DEVICE [DEVICE ..]
    toggle devices - if all are OFF, turn all ON, otherwise turn all OFF
      -send 'POWER TOGGLE' to all devices
      -ignore all devices that did not respond at all
      -check the current power status of all devices that did toggle
      -if at least one turned OFF, send 'POWER OFF' to any that turned ON
      -otherwise, send POWER_ON_CMDS to devices that turned ON

  $EXEC [OPTS] on | --on DEVICE [DEVICE DEVICE ..]
    send 'POWER ON' to each DEVICE given
    send POWER_ON_CMDS to each device given

  $EXEC [OPTS] off | --off DEVICE [DEVICE DEVICE ..]
    send 'POWER OFF' to each DEVICE given

  $EXEC [OPTS] --dimmer DEVICE [DEVICE DEVICE ..] DIMMER_PCT_ARG [DIMMER_PCT_ARG DIMMER_PCT_ARG]
  $EXEC [OPTS] DEVICE [DEVICE DEVICE ..] DIMMER_PCT_ARG [DIMMER_PCT_ARG DIMMER_PCT_ARG]
    -get the current <DIMMER_PCT> value from all devices, and select the smallest value
    -select the smallest <DIMMER_PCT_ARG> that is strictly greater than <DIMMER_PCT>
    -if there is no such <DIMMER_PCT_ARG>, use the smallest <DIMMER_PCT_ARG> given
    -run command 'DIMMER <DIMMER_PCT_ARG>'
      e.g.:
        $EXEC --dimmer bed 33 66 100     #DIMMER 100 => 33
        $EXEC --dimmer bed 33 66 100     #DIMMER 33  => 66
        $EXEC --dimmer bed 33 66 100     #DIMMER 66  => 100

  $EXEC [OPTS] --info|info|-i
  $EXEC [OPTS] --info|info|-i DEVICE [DEVICE DEVICE ..]
    -if no DEVICE is given, default to all devices
    -run 'STATUS 0' (show connected sensor information)
    -parse out JSON results:
      state           = Status.Power (formatted as 'on ', 'off', or '???')
      power           = StatusSNS.ENERGY.Power (integer power in watts)
      energyTotal     = StatusSNS.ENERGY.Total (fractional energy in kWh)
      energyYesterday = StatusSNS.ENERGY.Yesterday (fractional energy in kWh)
      energyToday     = StatusSNS.ENERGY.Today (fractional energy in kWh)
      color           = StatusSTS.Color (hex color, usually RRGGBBCWWW)
    -print info for each DEVICE, one per line, in order given, formatted:
      <DEVICE>: <state> <energyTotal>kWh <power>W color=<color>
      (omit power/energyTotal/color if missing)
    -write date and info for each DEVICE
      -write to file: $LOG_DIR/info-<DEVICE>.txt
      -formatted: <YYYY>-<mm>-<dd> <HH>:<MM>:<SS> | energyTotal=<energyTotal> | power=<power> | color=<color>

  $EXEC [OPTS] --mac DEVICE [DEVICE DEVICE ..]
    send 'Status 0' command and parse the output to get the MAC address

  $EXEC [OPTS] --ddwrt
    -generate IP, mac, and device name in DDWRT config file format for all devices
    -edit $DDWRT_CONFIG_FILE
      -remove all content between '#TASMOTA_START#' and '#TASMOTA_END#'
      -get whitespace indent from the line '#TASMOTA_START#'
      -insert all devices between '#TASMOTA_START#' and '#TASMOTA_END#', one per line, indented
      -indent '#TASMOTA_END#'

  DEVICE = DEVICE_NAME | DEVICE_IP4 | DEVICE_ALIAS
    name or IP of a single device, or named alias for a list of devices

    DEVICE_NAME
      $DEVICES_REGEX

    DEVICE_IP4 | init
      IPv4 address of device, or 'init' for $INITIAL_DEVICE_IP

    DEVICE_ALIAS"
      . "\n" . join("",
                 map {sprintf "      %-5s = %s\n", $_, "@{$DEVICES_BY_ALIAS{$_}}"}
                 @DEVICE_ALIAS_NAMES)
      . "
  COMMAND_ALIAS"
    . "\n" . join("",
               map {sprintf "    %-10s = %s\n", $_, "$COMMAND_ALIASES{$_}"}
               @COMMAND_ALIAS_NAMES)
    . "

  OPTS
    --force-ip=IP4_ADDRESS
      override all IP addresses with IP4_ADDRESS

    --timeout=TIMEOUT_MILLIS
      override device timeout millis (default=${DEFAULT_MAX_TIMEOUT_MILLIS}ms)
      TIMEOUT_MILLIS must be a positive integer

    --attempts=COMMAND_ATTEMPTS
      override device command attempts (default=${DEFAULT_MAX_COMMAND_ATTEMPTS} attempts)
      COMMAND_ATTEMPTS must be a positive integer
      (--attempts=1 means one try total, no retries)
";

sub main(@){
  my $mode = $MODE_TOGGLE;
  my $ssidOverride = undef;
  my $forceIP = undef;
  my (@devices, $cmd, @dimmerArgs);
  my $opts = {
    maxTimeoutMillis   => $DEFAULT_MAX_TIMEOUT_MILLIS,
    maxCommandAttempts => $DEFAULT_MAX_COMMAND_ATTEMPTS,
  };
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--ssid)$/){
      $mode = $MODE_SET_SSID;
      $ssidOverride = undef;
    }elsif($arg =~ /^--ssid=(.+)$/){
      $mode = $MODE_SET_SSID;
      $ssidOverride = $1;
    }elsif($arg =~ /^(--config)$/){
      $mode = $MODE_CONFIG_DEVICE;
    }elsif($arg =~ /^(--template)$/){
      $mode = $MODE_SET_TEMPLATE;
    }elsif($arg =~ /^($DEVICES_REGEX)$/){
      push @devices, $arg;
    }elsif($arg =~ /^($DEVICE_ALIASES_REGEX)$/){
      @devices = (@devices, @{$DEVICES_BY_ALIAS{$arg}});
    }elsif($arg =~ /^(\d+\.\d+\.\d+\.\d+)$/){
      push @devices, $arg;
    }elsif($arg =~ /^(init)$/){
      push @devices, $INITIAL_DEVICE_IP;
    }elsif($arg =~ /^(-t|--toggle|toggle)$/){
      $mode = $MODE_TOGGLE;
      $cmd = undef;
    }elsif($arg =~ /^(on|--on)$/){
      $mode = $MODE_ON;
      $cmd = undef;
    }elsif($arg =~ /^(off|--off)$/){
      $mode = $MODE_OFF;
      $cmd = undef;
    }elsif($arg =~ /^(--dimmer)$/){
      $mode = $MODE_DIMMER;
      $cmd = undef;
    }elsif($arg =~ /^(\d+)$/){
      push @dimmerArgs, $1;
      $mode = $MODE_DIMMER;
    }elsif($arg =~ /^(--info|info|-i)$/){
      $mode = $MODE_INFO;
      $cmd = undef;
    }elsif($arg =~ /^(--mac)$/){
      $mode = $MODE_MAC;
      $cmd = undef;
    }elsif($arg =~ /^(--ddwrt)$/){
      $mode = $MODE_DDWRT;
    }elsif($arg =~ /^--force-ip=(\d+\.\d+\.\d+\.\d+)$/){
      $forceIP = $1;
    }elsif($arg =~ /^--timeout=(\d+)$/){
      $$opts{maxTimeoutMillis} = $1;
    }elsif($arg =~ /^--attempts=(\d+)$/){
      $$opts{maxCommandAttempts} = $1;
    }elsif(defined $COMMAND_ALIASES{lc $arg}){
      $mode = $MODE_COMMAND;
      $cmd = $COMMAND_ALIASES{lc $arg};
    }elsif(not defined $cmd and @_ == 0){
      $mode = $MODE_COMMAND;
      $cmd = $arg;
    }else{
      die $USAGE;
    }
  }

  if($$opts{maxTimeoutMillis} <= 0){
    die "$USAGE\nERROR: --timeout must be greater than 0ms\n";
  }

  if($$opts{maxCommandAttempts} <= 0){
    die "$USAGE\nERROR: --attempts must be greater than 0\n";
  }

  if($mode =~ /^($MODE_INFO)$/ and @devices == 0){
    @devices = @DEVICE_NAMES;
  }

  if($mode =~ /^($MODE_DDWRT)$/){
    die "$USAGE\nERROR: canonot specify DEVICE for mode=$mode\n" if @devices > 0;
  }else{
    die "$USAGE\nERROR: at least one DEVICE must be given for mode=$mode\n" if @devices == 0;
  }

  if(defined $forceIP){
    print "using IP $forceIP for all devices\n";
    for my $device(@devices){
      $DEVICE_IPS{$device} = $forceIP;
    }
  }

  if($mode eq $MODE_COMMAND){
    my $outputByDevice = runCommandOnDevices($cmd, $opts, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
  }elsif($mode eq $MODE_ON){
    my $outputByDevice = runCommandOnDevices("POWER ON", $opts, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    for my $device(@devices){
      my $devType = $DEVICE_TYPES{$device};
      next if not defined $devType;
      my $cmds = $DEV_TYPE_POWER_ON_CMDS{$devType};
      next if not defined $cmds;
      for my $cmd(@$cmds){
        if(defined $COMMAND_ALIASES{$cmd}){
          $cmd = $COMMAND_ALIASES{$cmd};
        }
        my $out = cmd($cmd, $opts, $device);
        print "$device - $cmd - $out\n";
      }
    }
  }elsif($mode eq $MODE_OFF){
    my $outputByDevice = runCommandOnDevices("POWER OFF", $opts, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
  }elsif($mode eq $MODE_TOGGLE){
    print "toggling all =>\n";
    my $outputByDevice = runCommandOnDevices("POWER TOGGLE", $opts, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
    my @devsTurnedOn;
    my @devsTurnedOff;
    my @devsIgnored;
    for my $device(@devices){
      my $output = $$outputByDevice{$device};
      $output = "" if not defined $output;
      if($output =~ /{"POWER":"OFF"}/i){
        push @devsTurnedOff, $device;
      }elsif($output =~ /{"POWER":"ON"}/i){
        push @devsTurnedOn, $device;
      }else{
        push @devsIgnored, $device;
      }
    }

    if(@devsTurnedOff > 0 and @devsTurnedOn > 0){
      print "\nsome devices off, some devices on, turning OFF\n";
      $outputByDevice = runCommandOnDevices("POWER OFF", $opts, @devsTurnedOn);
      print "$_ - $$outputByDevice{$_}\n" foreach @devsTurnedOn;
      @devsTurnedOff = (@devsTurnedOff, @devsTurnedOn);
      @devsTurnedOn = ();
    }

    if(@devsTurnedOn > 0){
      print "\nrunning POWER_ON_CMDS commands\n";
      for my $device(@devsTurnedOn){
        my $devType = $DEVICE_TYPES{$device};
        next if not defined $devType;
        my $cmds = $DEV_TYPE_POWER_ON_CMDS{$devType};
        next if not defined $cmds;
        for my $cmd(@$cmds){
          if(defined $COMMAND_ALIASES{$cmd}){
            $cmd = $COMMAND_ALIASES{$cmd};
          }
          my $out = cmd($cmd, $opts, $device);
          print "$device - $cmd - $out\n";
        }
      }
    }

    print "\n";
    print "IGNORED: @devsIgnored\n" if @devsIgnored > 0;
    print "ON: @devsTurnedOn\n" if @devsTurnedOn > 0;
    print "OFF: @devsTurnedOff\n" if @devsTurnedOff > 0;
  }elsif($mode eq $MODE_DIMMER){
    die "ERROR: no DIMMER_PCT_ARG given\n" if @dimmerArgs == 0;
    my $curDimmer = readMinDimmer($opts, @devices);
    @dimmerArgs = sort {$a <=> $b} @dimmerArgs;
    my $targetDimmerVal = undef;
    for my $dimmerArg(@dimmerArgs){
      if($dimmerArg > $curDimmer){
        $targetDimmerVal = $dimmerArg;
        last;
      }
    }
    $targetDimmerVal = $dimmerArgs[0] if not defined $targetDimmerVal;
    print "dimmer $curDimmer => $targetDimmerVal\n";
    my $outputByDevice = runCommandOnDevices("Dimmer $targetDimmerVal", $opts, @devices);
    print "$_ - $$outputByDevice{$_}\n" foreach @devices;
  }elsif($mode eq $MODE_INFO){
    my $outputByDevice = runCommandOnDevices("Status 0", $opts, @devices);
    my $date = `date '+%Y-%m-%d %H:%M:%S'`;
    chomp $date;
    for my $device(@devices){
      my $json = $$outputByDevice{$device};
      my $info = parseStatusJson($json);
      my $state = $$info{state};
      $state = "???" if not defined $state;
      $state = "on " if $state eq 1;
      $state = "off" if $state eq 0;

      my $fmt = "$device: $state";
      $fmt .= sprintf " %11.5fkWh", $$info{energyTotal} if defined $$info{energyTotal};
      $fmt .= sprintf " %4dW", $$info{power} if defined $$info{power};
      $fmt .= " color=$$info{color}" if defined $$info{color};
      print "$fmt\n";

      my $logFmt = "$date | $state";
      $logFmt .= sprintf " | energyTotal=%11.5f", $$info{energyTotal} if defined $$info{energyTotal};
      $logFmt .= sprintf " | power=%4d", $$info{power} if defined $$info{power};
      $logFmt .= " | color=$$info{color}" if defined $$info{color};
      if(defined $$info{state}){
        appendLog("info-$device.txt", "$logFmt\n");
      }
    }
  }elsif($mode eq $MODE_MAC){
    my $outputByDevice = runCommandOnDevices("STATUS 0", $opts, @devices);
    for my $device(@devices){
      my $out = $$outputByDevice{$device};
      my $mac = $1 if $out =~ /"Mac":"([^"]+)"/;
      $mac = "?" if not defined $mac;
      print "$device - $mac\n";
    }
  }elsif($mode eq $MODE_DDWRT){
    my $contents = readFile $DDWRT_CONFIG_FILE;
    my $indent = "";
    if($contents =~ /(?:^|\n)([ \t]*)#TASMOTA_START#/){
      $indent = $1;
    }

    my $fmt = "#TASMOTA_START#";
    for my $dev(@DEVICE_NAMES){
      my $ip = $DEVICE_IPS{$dev};
      my $mac = $DEVICE_MACS{$dev};
      my $ipSuffix = $1 if $ip =~ /\.(\d+)$/;
      $fmt .= "\n$indent$ipSuffix = $mac ts-$dev";
    }
    $fmt .= "\n$indent#TASMOTA_END#";

    print "$indent$fmt\n";

    my $oldContents = $contents;

    if($contents =~ s/(#TASMOTA_START#).*(#TASMOTA_END#)/$fmt/s){
      if($oldContents eq $contents){
        print "\nskipping unchanged $DDWRT_CONFIG_FILE\n";
      }else{
        writeFile $DDWRT_CONFIG_FILE, $contents;
        print "\nSUCCESS, updated $DDWRT_CONFIG_FILE\n";
      }
    }else{
      die "\nERROR: could not edit tasmota block in $DDWRT_CONFIG_FILE\n";
    }
  }elsif($mode eq $MODE_SET_SSID){
    for my $device(@devices){
      my $ssid = $ssidOverride;

      if(not defined $ssid and defined $DEVICE_SSIDS{$device}){
        $ssid = $DEVICE_SSIDS{$device};
      }

      if(not defined $ssid){
        my $currentSSID = getSSID();
        for my $namedDevice(@DEVICE_NAMES){
          if($DEVICE_HOSTNAMES{$namedDevice} eq $currentSSID){
            print "$namedDevice hostname matches current SSID $currentSSID\n";
            $ssid = $DEVICE_SSIDS{$namedDevice};
          }
        }
      }

      if(not defined $ssid){
        print "ERROR: no SSID configured for $device and no --ssid specified\n";
        next;
      }

      print "using SSID=$ssid\n";

      my $key = `winfo --key $ssid`;
      chomp $key;
      if($key !~ /\S/){
        print "ERROR: could not obtain password for $ssid\n";
        next;
      }

      my $wifiCmd = "BACKLOG SSID1 $ssid; Password1 $key";
      my $deviceIP = $device =~ /^\d+\.\d+\.\d+\.\d+$/ ? $device : $DEVICE_IPS{$device};
      print "$device ($deviceIP) => $wifiCmd\n";
      cmd($wifiCmd, $opts, $device);
    }
  }elsif($mode eq $MODE_CONFIG_DEVICE){
    for my $device(@devices){
      my $devType = $DEVICE_TYPES{$device};
      if(not defined $devType){
        print "$device - device type unknown\n";
        next;
      }
      my $cmds = $DEV_TYPE_INIT_CMDS{$devType};
      if(not defined $cmds){
        print "$device - no config commands found\n";
        next;
      }
      for my $cmd(@$cmds){
        if(defined $COMMAND_ALIASES{$cmd}){
          $cmd = $COMMAND_ALIASES{$cmd};
        }
        my $out = cmd($cmd, $opts, $device);
        print "$device - $cmd - $out\n";
      }
    }
  }elsif($mode eq $MODE_SET_TEMPLATE){
    for my $device(@devices){
      my $devType = $DEVICE_TYPES{$device};
      if(not defined $devType){
        print "$device - device type unknown\n";
        next;
      }
      my $templateJSON = $DEV_TYPE_TEMPLATE_JSON {$devType};
      if(not defined $templateJSON){
        print "$device - no template found\n";
        next;
      }
      my $cmd = "TEMPLATE $templateJSON";
      my $out = "";
      $out .= cmd($cmd, $opts, $device);
      $out .= cmd("Module 0", $opts, $device);
      print "$device - $out\n";
    }
  }else{
    die "ERROR: unknown mode \"$mode\"\n";
  }
}

sub readDevicesConfig(){
  if(not -f $DEVICES_CONFIG_FILE){
    print STDERR "WARNING: missing config file $DEVICES_CONFIG_FILE\n";
    return ();
  }

  my $byte = "[0-9a-fA-f][0-9a-fA-F]";

  my @lines = split /\n/, readFile $DEVICES_CONFIG_FILE;
  my @devicesArr;
  for my $line(@lines){
    $line =~ s/#.*//;
    $line =~ s/^\s*//;
    $line =~ s/\s*$//;
    $line =~ s/[\r\n]//g;
    next if $line eq "";
    if($line =~ /
       ^      \s* (\w+)
       \s* \| \s* ([^|]+?)
       \s* \| \s* ($byte:$byte:$byte:$byte:$byte:$byte)
       \s* \| \s* (\d+\.\d+\.\d+\.\d+)
       \s* \| \s* ([^|]+?)
       \s* \| \s* (\w+)
       \s* \| \s* ([a-zA-Z0-9_\-\ ,]+)
      $/x
    ){
      my ($dev, $hostname, $mac, $targetIP4, $targetSSID, $devType, $aliasNamesStr) =
        ($1, $2, $3, $4, $5, $6, $7);
      my @aliasNames = split /[ ,]+/, $aliasNamesStr;
      push @devicesArr, $dev;
      push @devicesArr, [$hostname, $mac, $targetIP4, $targetSSID, $devType, [@aliasNames]];
    }else{
      print STDERR "WARNING: malformed line in $DEVICES_CONFIG_FILE:\n$line\n";
    }
  }
  return @devicesArr;
}

sub appendLog($$){
  my ($logFileName, $msg) = @_;
  maybeRotateLog($logFileName);
  my $logFile = "$LOG_DIR/$logFileName";
  system "mkdir", "-p", $LOG_DIR;
  open FH, ">>", $logFile
    or die "ERROR: could not write to $logFile\n$!\n";
  print FH $msg;
  close FH;
}

sub maybeRotateLog($){
  my ($logFileName) = @_;
  my $logFile = "$LOG_DIR/$logFileName";
  if(-e $logFile){
    my $lineCount = `cat $logFile | wc -l`;
    chomp $lineCount;
    if($lineCount >= 1000){
      rotateLog($logFileName);
    }
  }
}

sub rotateLog($){
  my ($logFileName) = @_;
  my $logFile = "$LOG_DIR/$logFileName";
  if(-e $logFile){
    my $firstLine = `head -1 $logFile`;
    my $lastLine = `tail -1 $logFile`;
    my $startDtmFmt;
    if($firstLine =~ /^(\d\d\d\d-\d\d-\d\d) (\d\d:\d\d:\d\d)/){
      my ($date, $time) = ($1, $2);
      $date =~ s/-//g;
      $time =~ s/://g;
      $startDtmFmt = "${date}_${time}";
    }else{
      $startDtmFmt = "";
    }
    my $nowMillis = nowMillis();
    my $newFile = "$logFile.$startDtmFmt.$nowMillis";
    system "mv $logFile $newFile";
    system "xz $newFile";
    system "rm -f $logFile.previous.xz";
    system "ln -s $newFile.xz $logFile.previous.xz";
  }
}

sub extractDevicesByAlias($$){
  my @deviceNames = @{$_[0]};
  my %deviceAliases = %{$_[1]};

  my %uniqAliases = map {$_ => 1} map {@{$deviceAliases{$_}}} @deviceNames;

  my %devicesByAlias = map {$_ => []} sort keys %uniqAliases;
  for my $device(@deviceNames){
    my %aliasesForDevice = map {$_ => 1} @{$deviceAliases{$device}};
    for my $alias(sort keys %uniqAliases){
      push @{$devicesByAlias{$alias}}, $device if defined $aliasesForDevice{$alias};
    }
  }

  return %devicesByAlias;
}

sub sortAliasesByFirstDevice($$){
  my @deviceNames = @{$_[0]};
  my %devicesByAlias = %{$_[1]};

  my @aliasNames = sort {
    my @aDevs = @{$devicesByAlias{$a}};
    my @bDevs = @{$devicesByAlias{$b}};
    my $aSize = 0 + @aDevs;
    my $bSize = 0 + @bDevs;
    my $aIsSingle = $aSize == 1 ? 1 : 0;
    my $bIsSingle = $bSize == 1 ? 1 : 0;
    my $aFirstDevIndex = first {$aDevs[0] eq $deviceNames[$_]} 0..$#deviceNames;
    my $bFirstDevIndex = first {$bDevs[0] eq $deviceNames[$_]} 0..$#deviceNames;

    return $aIsSingle <=> $bIsSingle          #single-device aliases last
      || $aFirstDevIndex <=> $bFirstDevIndex  #sort groups by first device
      || $bSize <=> $aSize                    #show larger groups first, within same first dev
      || $a cmp $b                            #sort by alias name last as tie-breaker
    ;
  } keys %devicesByAlias;

  return @aliasNames;
}

sub extractTemplateJSONByDevType($){
  my ($devTypeTemplateGpioCfg) = @_;
  my %devTypeTemplateJSON;
  for my $devType(sort keys %$devTypeTemplateGpioCfg){
    $devTypeTemplateJSON{$devType} = formatTemplateJSON([
      NAME => "\"$devType\"",
      @{$$devTypeTemplateGpioCfg{$devType}},
      FLAG => 0,
      BASE => 18,
    ]);
  }
  return %devTypeTemplateJSON;
}

sub formatTemplateJSON($){
  my ($templateCfgArr) = @_;
  my %cfg = @$templateCfgArr;
  my @cfgKeys = map {$$templateCfgArr[$_]} grep {$_ % 2 == 0} (0..$#{$templateCfgArr});

  my $fmt = '';
  for(my $i=0; $i<@cfgKeys; $i++){
    my $key = $cfgKeys[$i];
    my $val = $cfg{$key};
    if($i == 0){
      $fmt .= "{ ";
    }else{
      $fmt .= ", ";
    }
    $fmt .= "\"$key\":$val";
  }
  $fmt .= " }";

  return $fmt;
}

sub parseStatusJson($){
  my ($json) = @_;
  my $obj = eval {
    from_json($json);
  };

  return {
    state           => getNestedMapVal($obj, ("Status" => "Power")),
    power           => getNestedMapVal($obj, ("StatusSNS" => "ENERGY" => "Power")),
    energyTotal     => getNestedMapVal($obj, ("StatusSNS" => "ENERGY" => "Total")),
    energyToday     => getNestedMapVal($obj, ("StatusSNS" => "ENERGY" => "Today")),
    energyYesterday => getNestedMapVal($obj, ("StatusSNS" => "ENERGY" => "Yesterday")),
    color           => getNestedMapVal($obj, ("StatusSTS" => "Color")),
  };
}

sub getNestedMapVal($@){
  my ($map, @keys) = @_;
  my $val = $map;
  while(@keys > 0){
    return undef if not defined $val or ref($val) ne 'HASH';
    my $key = shift @keys;
    $val = $$val{$key};
  }
  return $val;
}

sub getSSID(){
  my $ssid = `wstatus --ssid 2>/dev/null`;
  chomp $ssid;
  return $ssid;
}

sub readMinDimmer($@){
  my ($opts, @devices) = @_;
  my $outputByDevice = runCommandOnDevices("DIMMER", $opts, @devices);
  my $minDimmer = 100;
  for my $device(@devices){
    my $output = $$outputByDevice{$device};
    $output = "" if not defined $output;
    if($output =~ /{"Dimmer":(\d+)}/i){
      my $dimmerVal = $1;
      if($dimmerVal < $minDimmer){
        $minDimmer = $dimmerVal;
      }
    }
  }
  return $minDimmer;
}

sub runCommandOnDevices($$@){
  my ($cmd, $opts, @devices) = @_;
  my $outputByDevice = {};
  if($FORKMGR_LIB){
    my $tmpDir = "/tmp/$EXEC-perl-storable";
    $ENV{TMPDIR} = $tmpDir;
    system "mkdir", "-p", "/tmp/$EXEC-perl-storable";

    my $pm = Parallel::ForkManager->new(10, $tmpDir);
    $pm->set_waitpid_blocking_sleep(0);  #enable true blocking calls

    for my $device(@devices){
      if(defined $$outputByDevice{$device}){
        die "ERROR: duplicate device $device (not allowed in parallel)\n";
      }
      $$outputByDevice{$device} = "UNKNOWN";
    }

    $pm->run_on_finish(
      sub {
        my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_structure_reference) = @_;
        $$outputByDevice{$ident} = $$data_structure_reference;
      }
    );

    for my $device(@devices){
      my $pid = $pm->start($device);
      next if $pid;

      my $out = cmd $cmd, $opts, $device;
      $pm->finish(0, \$out);
    }
    $pm->wait_all_children();
  }else{
    for my $device(@devices){
      my $out = cmd $cmd, $opts, $device;
      $$outputByDevice{$device} = $out;
    }
  }
  return $outputByDevice;
}

sub cmd($$$){
  my ($cmd, $opts, $device) = @_;
  my $deviceIP = $device =~ /^\d+\.\d+\.\d+\.\d+$/ ? $device : $DEVICE_IPS{$device};

  $cmd =~ s/ /%20/g;
  $cmd =~ s/;/%3B/g;
  $cmd =~ s/\{/%7B/g;
  $cmd =~ s/\}/%7D/g;
  $cmd =~ s/\[/%5B/g;
  $cmd =~ s/\]/%5D/g;
  $cmd =~ s/'/'\\''/g;

  my $timeout = sprintf "%.3f", ($$opts{maxTimeoutMillis} / 1000.0);
  my $curlCmd = "curl -m $timeout -s 'http://$deviceIP/cm?cmnd=$cmd'";

  my ($out, $exitCode);
  my $success = 0;
  my $attemptsRemaining = $$opts{maxCommandAttempts};
  while(not $success and $attemptsRemaining > 0){
    $out = `$curlCmd`;
    $exitCode = $? >> 8;
    $attemptsRemaining--;

    if($out =~ /\S/){
      $success = 1;
    }elsif($exitCode == 2){
      my $curlVersion = `curl --version`;
      my $v = $1 if $curlVersion =~ /^curl (\d+\.[0-9\.]+)/;
      if($timeout =~ /\./ and cmpVersion($v, "7.32.0") < 0){
        $attemptsRemaining++;
        print STDERR "WARNING: curl version $v, changing timeout to integral seconds\n";
        $timeout = sprintf "%d", ($$opts{maxTimeoutMillis} / 1000.0);
        $curlCmd = "curl -m $timeout -s 'http://$deviceIP/cm?cmnd=$cmd'";
      }
      $success = 0;
    }elsif($exitCode == 0){
      $success = 1;
    }else{
      #treat any other exit code as failure
      $success = 0;
    }
  }

  return $out;
}

sub parseVersion($){
  my ($v) = @_;
  my ($maj, $min, $pt);
  if($v =~ /^(\d+)\.(\d+)\.(\d+)$/){
    ($maj, $min, $pt) = ($1, $2, $3);
  }elsif($v =~ /^(\d+)\.(\d+)$/){
    ($maj, $min, $pt) = ($1, $2, 0);
  }elsif($v =~ /^(\d+)$/){
    ($maj, $min, $pt) = ($1, 0, 0);
  }else{
    die "ERROR: could not parse version \"$v\"\n";
  }

  return ($maj, $min, $pt);
}

sub cmpVersion($$){
  my ($v1, $v2) = @_;
  my ($maj1, $min1, $pt1) = parseVersion($v1);
  my ($maj2, $min2, $pt2) = parseVersion($v2);
  return ($maj1 <=> $maj2) || ($min1 <=> $min2) || ($pt1 <=> $pt2);
}

sub readFile($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n$!\n";
  my $contents = join '', <FH>;
  close FH;
  return $contents;
}

sub writeFile($$){
  my ($file, $contents) = @_;
  open FH, "> $file" or die "ERROR: could not write $file\n$!\n";
  print FH $contents;
  close FH;
}

sub nowMillis(){
  return int(time*1000.0 + 0.5);
}

&main(@ARGV);
