#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(time);

sub bluetoothctlDevCmd($$);
sub setup($);
sub devInitCmd($);
sub parseBluetoothDevicesConf();
sub run(@);
sub runOrDie(@);
sub runUntilSuccess(@);
sub nowMillis();

my $BLUETOOTH_RESTART_CMD = "sudo bluetooth unblock off on module-reload restart";

my $DEVICE_CSV_FILE = "$ENV{HOME}/.config/bluetooth-devices.conf";

my @DEVICE_CSV_ARR = parseBluetoothDevicesConf();
my @DEVICE_NAMES = map {uc $$_[0]} @DEVICE_CSV_ARR;
my %DEVICE_MACS = map {uc $$_[0] => $$_[1]} @DEVICE_CSV_ARR;
my %DEVICE_INIT_CMDS = map {uc $$_[0] => $$_[2]} @DEVICE_CSV_ARR;

my @BLUETOOTHCTL_DEV_CMDS = qw(
  pair trust untrust block unblock remove connect disconnect info
);
my $REGEX_BLUETOOTHCTL_DEV_CMD = join "|", @BLUETOOTHCTL_DEV_CMDS;

my $LOG_PREFIX = "/tmp/bt-scan";
my $LOG_SYMLINK = $LOG_PREFIX;

my $COMMAND_RERUN_TIMEOUT_MILLIS = 60 * 1000;

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC DEVICE_NAME
  $EXEC setup DEVICE_NAME
  $EXEC --setup DEVICE_NAME
    -obtain DEVICE_MAC for DEVICE_NAME
    -restart/reload/unblock bluetooth (modprobe/systemctl/rfkill) with `bluetooth` cmd
    -start scan with `screen-daemon` and `bluetoothctl`
    -attempt to connect to DEVICE_MAC once
    -if connect fails:
      -remove the DEVICE_MAC
      -every 3s, until success, run: `bluetoothctl pair DEVICE_MAC`
      -every 3s, until success, run: `bluetoothctl connect DEVICE_MAC`
    -run: `DEVICE_INIT_CMD`

  $EXEC restart
  $EXEC --restart
    restart/reload/unblock bluetooth (modprobe/systemctl/rfkill) with `bluetooth` cmd
    -run: $BLUETOOTH_RESTART_CMD

  $EXEC init DEVICE_NAME
  $EXEC --init DEVICE_NAME
    -obtain DEVICE_INIT_CMD for DEVICE_NAME
    -run: `DEVICE_INIT_CMD`

  $EXEC BLUETOOTHCTL_DEV_CMD DEVICE_NAME
  $EXEC --BLUETOOTHCTL_DEV_CMD DEVICE_NAME
    -obtain DEVICE_MAC for DEVICE_NAME
    -run: `bluetoothctl BLUETOOTHCTL_CMD DEVICE_MAC`
      e.g.:
        $EXEC --pair DEVICE_NAME
        $EXEC trust DEVICE_NAME

   BLUETOOTHCTL_DEV_CMD
     one of: @BLUETOOTHCTL_DEV_CMDS

   DEVICE_NAME
     one of: @DEVICE_NAMES

   DEVICE_MAC
     the MAC address of the device

   DEVICE_INIT_CMD
     the command, if any, that will be run after connecting the device
";

my $CMD_SETUP = "setup";
my $CMD_RESTART_BLUETOOTH = "restart-bluetooth";
my $CMD_INIT = "init";
my $CMD_BLUETOOTHCTL_DEV_CMD = "bluetoothctl-dev-cmd";

sub main(@){
  my $deviceName;
  my $cmd = $CMD_SETUP;
  my $bluetoothctlDevCmd = undef;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(setup|--setup)$/){
      $cmd = $CMD_SETUP;
    }elsif($arg =~ /^(restart|--restart)$/){
      $cmd = $CMD_RESTART_BLUETOOTH;
    }elsif($arg =~ /^(init|--init)$/){
      $cmd = $CMD_INIT;
    }elsif($arg =~ /^(?:--)?($REGEX_BLUETOOTHCTL_DEV_CMD)$/i){
      $cmd = $CMD_BLUETOOTHCTL_DEV_CMD;
      $bluetoothctlDevCmd = lc $1;
    }elsif(defined $DEVICE_MACS{uc $arg}){
      $deviceName = uc $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($cmd eq $CMD_SETUP){
    die "ERROR: missing DEVICE_NAME\n" if not defined $deviceName;
    setup($deviceName);
  }elsif($cmd eq $CMD_RESTART_BLUETOOTH){
    runOrDie $BLUETOOTH_RESTART_CMD;
  }elsif($cmd eq $CMD_INIT){
    die "ERROR: missing DEVICE_NAME\n" if not defined $deviceName;
    devInitCmd($deviceName);
  }elsif($cmd eq $CMD_BLUETOOTHCTL_DEV_CMD){
    die "ERROR: missing DEVICE_NAME\n" if not defined $deviceName;
    bluetoothctlDevCmd($deviceName, $bluetoothctlDevCmd);
  }else{
    die "ERROR: unknown command $cmd\n";
  }
}

sub bluetoothctlDevCmd($$){
  my ($deviceName, $cmd) = @_;
  my $deviceMac = $DEVICE_MACS{$deviceName};
  return run "bluetoothctl", $cmd, $deviceMac;
}

sub setup($){
  my ($deviceName) = @_;
  my $deviceMac = $DEVICE_MACS{$deviceName};
  my $deviceInitCmd = $DEVICE_INIT_CMDS{$deviceName};
  print "\nrestarting/reloading bluetooth\n";
  runOrDie $BLUETOOTH_RESTART_CMD;
  sleep 3;
  runOrDie "bluetoothctl power off";
  runOrDie "bluetoothctl power on";

  my $logFile = "$LOG_PREFIX-" . nowMillis();
  print "\nstarting scan in screen\n";
  run "rm -f $LOG_PREFIX*";
  run "ln -s $logFile $LOG_SYMLINK";

  runOrDie "screen-daemon bt-scan --start 0 0 'unbuffer bluetoothctl scan on | tee $logFile'";
  print "logging to $logFile (symlink at $LOG_SYMLINK)\n";
  sleep 3;

  print "\ntrying ONCE to connect device\n";
  my $success = run "bluetoothctl connect $deviceMac";
  if(not $success){
    print "\nremoving, pairing, and connecting device\n";
    run "bluetoothctl remove $deviceMac";
    runUntilSuccess "bluetoothctl pair $deviceMac";
    runUntilSuccess "bluetoothctl connect $deviceMac";
  }

  runOrDie "screen-daemon bt-scan --stop";

  run "bluetoothctl trust $deviceMac";

  if(defined $deviceInitCmd){
    print "\ninit-cmd - waiting 2s and running $deviceInitCmd\n";
    sleep 2;
    run $deviceInitCmd;
  }
}

sub devInitCmd($){
  my ($deviceName) = @_;
  my $deviceInitCmd = $DEVICE_INIT_CMDS{$deviceName};
  run "$deviceInitCmd" if defined $deviceInitCmd;
}

sub parseBluetoothDevicesConf(){
  my @devicesCsv;
  if(not -f $DEVICE_CSV_FILE){
    print STDERR "WARNING: missing $DEVICE_CSV_FILE\n";
    return @devicesCsv;
  }
  open my $fh, "< $DEVICE_CSV_FILE" or die "ERROR: could not read $DEVICE_CSV_FILE\n$!\n";
  my @lines = <$fh>;
  close $fh;
  my $byteRe = '[0-9a-f][0-9a-f]';
  for my $line(@lines){
    $line =~ s/#.*//;
    next if $line =~ /^\s*$/;
    if($line =~ /^\s*(\w+)\s*,\s*($byteRe:$byteRe:$byteRe:$byteRe:$byteRe:$byteRe)\s*,(.*)$/i){
      my ($devName, $mac, $initCmd) = ($1, $2, $3);
      $mac = uc $mac;
      $initCmd =~ s/^\s*//;
      $initCmd =~ s/\s*$//;
      $initCmd = undef if $initCmd eq "";

      push @devicesCsv, [$devName, $mac, $initCmd];
    }else{
      print STDERR "WARNING: malformed line in $DEVICE_CSV_FILE\n$line";
    }
  }

  if(@devicesCsv == 0){
    print STDERR "WARNING: no devices in $DEVICE_CSV_FILE\n";
  }

  return @devicesCsv;
}

sub run(@){
  print "@_\n";
  system @_;
  return $? == 0 ? 1 : 0;
}
sub runOrDie(@){
  run @_ or die "ERROR: @_ failed\n";
}
sub runUntilSuccess(@){
  my $startTime = nowMillis();
  while(1){
    my $isSuccess = run @_;
    if($isSuccess){
      last;
    }else{
      my $elapsedMillis = nowMillis() - $startTime;
      if($elapsedMillis > $COMMAND_RERUN_TIMEOUT_MILLIS){
        die "ERROR: command-rerun timeout exceeded for @_\n";
      }
      print "@_ failed, waiting 3s and retrying...\n";
      sleep 3;
    }
  }
}

sub nowMillis(){
  return int(time() * 1000 + 0.5);
}

&main(@ARGV);
