#!/usr/bin/perl
use strict;
use warnings;
use DateTime qw();
use Date::Format qw(time2str);
use Digest::MD5 qw();
use File::Basename qw(basename);
use Cpanel::JSON::XS qw();
use Time::HiRes qw(time);
use Time::Local qw(timegm_posix timelocal_posix);
use List::Util qw(max min);
use POSIX qw(ceil floor);

sub parseDistanceFmt($);
sub formatWorkoutDetails($$);
sub formatWorkoutsSummary($$@);
sub gnuplotDurations($$$@);
sub gnuplotDistances($$$@);
sub gnuplotSpeeds($$@);
sub gnuplotHeartrates($$@);
sub readCachedWorkouts();
sub readCachedWorkoutLatest();
sub readExtraInfo();
sub insertExtraInfo($@);
sub splitUpLargeIntervals($);
sub groupIntervalsIntoSpeedSegments($);
sub formatSpeedSegment($);
sub getHrmonHrByEpoch($);
sub getAmazfishHrByEpoch($);
sub readHrCache($$);
sub writeHrCache($$$);
sub isWorkoutNeedsExternalHeartrate($);
sub insertExternalHeartrates($$);
sub removeHeartrateErrors($$$);
sub calculateIntervals($);
sub calculateScaledTimeAndDistance($);
sub calculateDistanceTargets($);
sub getBestTimeForDistance($$);
sub readWorkoutsCombine();
sub applyAndFilterCombinedWorkouts($@);
sub getCombinedWorkout($$);
sub fetchViewfitWorkouts();
sub mergeCachedJsonFiles();
sub groupWorkoutsIntoPeriods($$@);
sub readFile($);
sub readFileGZ($);
sub writeFile($$);
sub getExerciserUUID();
sub readSecrets();
sub decrypt($);
sub formatTimeMinSec($);
sub formatTimeHrMinSec($);
sub formatTimeRelative($);
sub dtmStrToEpoch($);
sub getEpochFracS($$$$$$$$);
sub dateFmt($$);
sub getDateBoundary($$);
sub binarySearchIdx($$$);
sub nvl($$);
sub md5sumFile($);
sub mtime($);
sub nowMillis();
sub run(@);
sub runQuiet(@);

my $EXEC = basename $0;
my $WORKOUTS_JSON_CACHE_DIR = "$ENV{HOME}/.cache/workouts/viewfit-workouts-json";
my $WORKOUTS_MERGED_JSON_FILE = "$ENV{HOME}/.cache/workouts/viewfit-workouts-merged.json";
my $WORKOUTS_EXTRA_INFO_FILE = "$ENV{HOME}/.cache/workouts/viewfit-workouts-extra-info";
my $WORKOUTS_COMBINE_FILE = "$ENV{HOME}/.cache/workouts/viewfit-workouts-combine";
my $WORKOUTS_INTERVAL_CACHE_DIR = "$ENV{HOME}/.cache/workouts/interval-cache";

my $GNUPLOT_OUTPUT_DIR = "$ENV{HOME}/.cache/workouts/plots";

my $DEFAULT_MIN_HEART_RATE_PLOT = 60;

my $CURL_FETCH_MAX_TIME_S = 60;

my $HRMON_LOG_DIR = "$ENV{HOME}/.cache/logs/hrmon";

my $HR_CACHE_DIR_HRMON = "$ENV{HOME}/.cache/workouts/hr-cache-hrmon";
my $HR_CACHE_DIR_AMAZFISH = "$ENV{HOME}/.cache/workouts/hr-cache-amazfish";

my $VIEWFIT_EXERCISER_BASE_URL = 'https://apollo.jfit.co/exerciser';

my $SECRETS_FILE = "$ENV{HOME}/.secrets";
my $SECRETS_PREFIX = "viewfit";
my $SECRETS_KEYS_REGEX = join "|", qw(exerciser);
my %SECRETS_ENC_KEYS = map {$_ => 1} qw();

my $MILES_PER_KM = 0.62137119;

my %NAMED_TARGETS = (
  "10k"    => 1000 * 10,
  "5k"     => 1000 * 5,
  "1.5mi"  => 1000 * (1.5 / $MILES_PER_KM),
  "1.0mi"  => 1000 * (1.0 / $MILES_PER_KM),
  "0.5mi"  => 1000 * (0.5 / $MILES_PER_KM),
);
my @SORTED_TARGET_NAMES =
  sort {$NAMED_TARGETS{$b} <=> $NAMED_TARGETS{$a}}
  keys %NAMED_TARGETS;
my $OK_NAMED_TARGET_REGEX = join("|", @SORTED_TARGET_NAMES);

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS]
  $EXEC [OPTS] -g | --get
    -parse workouts in $WORKOUTS_MERGED_JSON_FILE

  $EXEC [OPTS] -f | --fetch
    -fetch workouts from:
      $VIEWFIT_EXERCISER_BASE_URL/<UUID>/workouts
    -check if identical JSON already cached by md5sum
    -if not, store in:
      $WORKOUTS_JSON_CACHE_DIR/workouts_YYYY-MM-DD_HHMMSS_MD5SUM_MILLIS.json
    -parse all workouts from all JSON fetches and merge into one JSON file:
      $WORKOUTS_MERGED_JSON_FILE
    -read workouts as in --get, and print info for latest workout

  $EXEC [OPTS] -l | --loop | --fetch-loop
    -fork and read from stdin
      -if any input received at any time, immediately exit
    -repeatedly fetch workouts, as in: $EXEC --fetch

  $EXEC [OPTS] -c | --clear-cache
    delete performance cache files
    (only deletes files that are fully reconstructable)
      -delete all files in: $WORKOUTS_INTERVAL_CACHE_DIR/

  OPTS
    --id=WORKOUT_ID
      show only workouts that match WORKOUT_ID

    --date=YYYY-MM-DD
      show only workouts that match YYYY-MM-DD
      can be given multiple times to include multiple single dates

    YYYY-MM-DD
      same as: --date=YYYY-MM-DD

    --min-date=YYYY-MM-DD
      show only workouts with date <= YYYY-MM-DD
      NOTE: can be given only once, latest value overrides previous
    --max-date=YYYY-MM-DD
      show only workouts with date >= YYYY-MM-DD
      NOTE: can be given only once, latest value overrides previous

    MIN_YYYYMMDD:MAX_YYYYMMDD
      same as: --min-date=MIN_YYYYMMDD --max-date=MAX_YYYYMMDD
    MIN_YYYYMMDD:
      same as: --min-date=MIN_YYYYMMDD
    :MAX_YYYYMMDD
      same as: --max-date=MAX_YYYYMMDD

    --min-distance=DISTANCE_WITH_UNITS
      show only workouts with total distance at least DISTANCE_WITH_UNITS
      DISTANCE_WITH_UNITS = <DISTANCE_VAL><UNIT>
        DISTANCE_VAL
          rational number expressed as a decimal
        UNIT
          k | km   = one kilometer
          mi       = 1.609344 kilometers
        e.g.:
          1k  or  1.000km  or ${MILES_PER_KM}mi

    -d DISTANCE_WITH_UNITS
      same as: --min-distance=DISTANCE_WITH_UNITS

    -b DISTANCE_WITH_UNITS
    --best=DISTANCE_TARGET
      skip workouts where another earlier workout has a better time for the given distance

    --trim-intervals=DISTANCE_WITH_UNITS
      include intervals until distance is at least DISTANCE_WITH_UNITS,
        then ignore any additional intervals
        (distance will be at most DISTANCE_WITH_UNITS plus the distance of the last interval)

    --intervals-remove-large-hr-errors
      after reading/writing cache and calculating intervals,
        zero-out heartrates that drop by 35% for up to 60 intervals (~10 minutes)

    --details
      show details for each workout
      (this is the default)

    -w | --week | --weekly
      show a summary of each calendar week, Monday-Sunday, with a workout in it

    -m | --month | --monthly
      show a summary of each calendar month, Monday-Sunday, with a workout in it

    -p PLOT_TYPE | --plot PLOT_TYPE | --gnuplot PLOT_TYPE
    --plot=PLOT_TYPE | --gnuplot=PLOT_TYPE
      produce a PNG of the data in --get with gnuplot
        -format the data in --get as gnuplot points
        -generate a gnuplot script
        -get current date/time DTM_YMD_HMS as 'YYYY-mm-dd HH:MM:SS'
        -run the gnuplot script and produce a PNG named:
          $GNUPLOT_OUTPUT_DIR/<DTM_YMD_HMS>_<PLOT_TYPE>.png
        -open the PNG in feh

      PLOT_TYPE
        $OK_NAMED_TARGET_REGEX
          -include only workouts at least as long as the indicated distance target
          -calculate the minimum duration for that distance target, as in --target
          -plot workouts as points with x=workout_date_time and y=duration
        hr | heartrate
          -plot each workout as a separate plot with x=duration and y=heartrate
        d | distance
          -plot the total distance of each workout with x=workout_date_time and y=distance

    --min-hr-plot=HEARTRATE
      when plotting heartrates with --gnuplot,
      restrict the heartrate y-axis to values above HEARTRATE
      (the default is $DEFAULT_MIN_HEART_RATE_PLOT)

    --target=DISTANCE_TARGET
      when including targets as in --print-targets,
        only print the indicated distance target
        (leave blank if distance is less)
      one of: @SORTED_TARGET_NAMES

    $OK_NAMED_TARGET_REGEX
      same as: --target=DISTANCE_TARGET

    --start-time | --print-start-time
      format workout start datetime as 'YYYY-mm-dd HH:MM:SS'

    --no-start-time | --no-print-start-time
      format workout start datetime as 'YYYY-mm-dd', without time
      (this is the default)

    --ids | --print-ids
      show ids in format
    --no-ids | --no-print-ids
      do not show ids in format
      (this is the default)

    -s | --segments | --print-segments
      print speed segments

    --no-segments | --no-print-segments
      do not print speed segments when printing workouts
      (this is the default)

    --targets | --print-targets
      include the best time for the largest fixed-distance in a workout from:
        @SORTED_TARGET_NAMES
      (this is the default

    --no-targets | --no-print-targets
      do not include distance targets

    --intervals | --print-intervals
      when printing workouts, print interval information after, one per line
      NOTE: this output is very large

    --no-intervals | --no-print-intervals
      do not print interval information
      (this is the default)
";

my $COMMAND_GET = "get";
my $COMMAND_FETCH = "fetch";
my $COMMAND_FETCH_LOOP = "fetch-loop";
my $COMMAND_CLEAR_CACHE = "clear-cache";

my $FORMAT_DETAILS = "details";
my $FORMAT_WEEKLY = "weekly";
my $FORMAT_MONTHLY = "monthly";
my $FORMAT_GNUPLOT = "gnuplot";

my $DATE_BOUNDARY_WEEK_START = "week-start";
my $DATE_BOUNDARY_WEEK_END = "week-end";
my $DATE_BOUNDARY_MONTH_START = "month-start";
my $DATE_BOUNDARY_MONTH_END = "month-end";

sub main(@){
  my $cmd = $COMMAND_GET;
  my $opts = {
    workoutIdFilter => undef,
    dateFilter => [],
    minDateFilter => undef,
    maxDateFilter => undef,
    minDistanceFilter => undef,
    bestDistanceFilter => undef,
    trimIntervalsDistance => undef,
    intervalsRemoveLargeHeartrateErrors => 0,
    format => $FORMAT_DETAILS,
    plotType => undef,
    minHeartratePlot => $DEFAULT_MIN_HEART_RATE_PLOT,
    distanceNamedTarget => undef,
    printStartTime => 0,
    printIds => 0,
    printSpeedSegments => 0,
    printDistanceTargets => 1,
    printIntervals => 0,
  };
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-g|--get)$/){
      $cmd = $COMMAND_GET;
    }elsif($arg =~ /^(-f|--fetch)$/){
      $cmd = $COMMAND_FETCH;
    }elsif($arg =~ /^(-l|--loop|--fetch-loop)$/){
      $cmd = $COMMAND_FETCH_LOOP;
    }elsif($arg =~ /^(-c|--clear-cache)$/){
      $cmd = $COMMAND_CLEAR_CACHE;
    }elsif($arg =~ /^--id=(.+)$/){
      $$opts{workoutIdFilter} = $1;
    }elsif($arg =~ /^(?:--date=)?(\d\d\d\d-\d\d-\d\d)$/){
      push @{$$opts{dateFilter}}, $1;
    }elsif($arg =~ /^--min-date=(\d\d\d\d-\d\d-\d\d)$/){
      $$opts{minDateFilter} = $1;
    }elsif($arg =~ /^--max-date=(\d\d\d\d-\d\d-\d\d)$/){
      $$opts{maxDateFilter} = $1;
    }elsif($arg =~ /^(\d\d\d\d-\d\d-\d\d):$/){
      $$opts{minDateFilter} = $1;
    }elsif($arg =~ /^:(\d\d\d\d-\d\d-\d\d)$/){
      $$opts{maxDateFilter} = $2;
    }elsif($arg =~ /^(\d\d\d\d-\d\d-\d\d):(\d\d\d\d-\d\d-\d\d)$/){
      $$opts{minDateFilter} = $1;
      $$opts{maxDateFilter} = $2;
    }elsif($arg =~ /^--min-distance=(.+)$/i){
      $$opts{minDistanceFilter} = parseDistanceFmt($1);
    }elsif($arg =~ /^(-d)$/ and @_ > 0){
      my $distArg = shift @_;
      $$opts{minDistanceFilter} = parseDistanceFmt($distArg);
    }elsif($arg =~ /^(-b)$/ and @_ > 0){
      my $distArg = shift @_;
      $$opts{bestDistanceFilter} = parseDistanceFmt($distArg);
    }elsif($arg =~ /^--trim-intervals=(.+)$/i){
      $$opts{trimIntervalsDistance} = parseDistanceFmt($1);
    }elsif($arg =~ /^(--intervals-remove-large-hr-errors)$/i){
      $$opts{intervalsRemoveLargeHeartrateErrors} = 1;
    }elsif($arg =~ /^(--details)$/){
      $$opts{format} = $FORMAT_DETAILS;
    }elsif($arg =~ /^(-w|--week|--weekly)$/){
      $$opts{format} = $FORMAT_WEEKLY;
    }elsif($arg =~ /^(-m|--month|--monthly)$/){
      $$opts{format} = $FORMAT_MONTHLY;
    }elsif($arg =~ /^(-p|--plot|--gnuplot)$/ and @_ > 0){
      $$opts{format} = $FORMAT_GNUPLOT;
      $$opts{plotType} = shift @_;
    }elsif($arg =~ /^(?:--plot|--gnuplot)=(.+)$/){
      $$opts{format} = $FORMAT_GNUPLOT;
      $$opts{plotType} = $1;
    }elsif($arg =~ /^--min-hr-plot=(\d+)$/){
      $$opts{minHeartratePlot} = $1;
    }elsif($arg =~ /^--target=(.+)$/){
      $$opts{distanceNamedTarget} = lc $1;
      if(not defined $NAMED_TARGETS{$$opts{distanceNamedTarget}}){
        die "$USAGE\nERROR: unknown DISTANCE_TARGET $$opts{distanceNamedTarget}\n";
      }
    }elsif($arg =~ /^($OK_NAMED_TARGET_REGEX)$/i){
      $$opts{distanceNamedTarget} = lc $arg;
    }elsif($arg =~ /^(--start-time|--print-start-time)$/){
      $$opts{printStartTime} = 1;
    }elsif($arg =~ /^(--no-start-time|--no-print-start-time)$/){
      $$opts{printStartTime} = 0;
    }elsif($arg =~ /^(--ids|--print-ids)$/){
      $$opts{printIds} = 1;
    }elsif($arg =~ /^(--no-ids|--no-print-ids)$/){
      $$opts{printIds} = 0;
    }elsif($arg =~ /^(-s|--segments|--print-segments)$/){
      $$opts{printSpeedSegments} = 1;
    }elsif($arg =~ /^(--no-segments|--no-print-segments)$/){
      $$opts{printSpeedSegments} = 0;
    }elsif($arg =~ /^(--targets|--print-targets)$/){
      $$opts{printDistanceTargets} = 1;
    }elsif($arg =~ /^(--no-targets|--no-print-targets)$/){
      $$opts{printDistanceTargets} = 0;
    }elsif($arg =~ /^(--intervals|--print-intervals)$/){
      $$opts{printIntervals} = 1;
    }elsif($arg =~ /^(--no-intervals|--no-print-intervals)$/){
      $$opts{printIntervals} = 0;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($cmd eq $COMMAND_GET){
    my @workouts = readCachedWorkouts();
    my $extraInfo = readExtraInfo();
    my $workoutsCombineInfo = readWorkoutsCombine();

    @workouts = insertExtraInfo($extraInfo, @workouts);
    @workouts = applyAndFilterCombinedWorkouts($workoutsCombineInfo, @workouts);

    if(defined $$opts{workoutIdFilter}){
      @workouts = grep {$$_{workout_id} =~ /$$opts{workoutIdFilter}/} @workouts;
    }
    if(@{$$opts{dateFilter}} > 0){
      my %okDtmYMD = map {$_ => 1} @{$$opts{dateFilter}};
      @workouts = grep {defined $okDtmYMD{$$_{dtmYMD}}} @workouts;
    }
    if(defined $$opts{minDateFilter}){
      @workouts = grep {$$_{dtmYMD} ge $$opts{minDateFilter}} @workouts;
    }
    if(defined $$opts{maxDateFilter}){
      @workouts = grep {$$_{dtmYMD} le $$opts{maxDateFilter}} @workouts;
    }
    if(defined $$opts{minDistanceFilter}){
      @workouts = grep {$$_{distance} >= $$opts{minDistanceFilter}} @workouts;
    }

    #skip short workouts under 20s or 100m
    @workouts = grep {$$_{duration} >= 20 && $$_{distance} >= 100} @workouts;

    @workouts = sort {
      $$a{dtmEpoch} <=> $$b{dtmEpoch}
    } @workouts;

    if(not -d $WORKOUTS_INTERVAL_CACHE_DIR){
      system "mkdir", "-p", $WORKOUTS_INTERVAL_CACHE_DIR;
    }

    #calculate+cache intervals
    for my $w(@workouts){
      my $cacheFile = "$WORKOUTS_INTERVAL_CACHE_DIR/$$w{workout_id}";

      if(-f $cacheFile){
        $$w{intervals} = Cpanel::JSON::XS->new->utf8->decode(readFile($cacheFile));
      }else{
        calculateIntervals($w);
        writeFile($cacheFile, Cpanel::JSON::XS->new->utf8->canonical->encode($$w{intervals}));
      }
    }

    for my $w(@workouts){
      if(not defined $$w{max_heart_rate} or $$w{max_heart_rate} <= 0){
        my @hrs = grep {defined $_ and $_ >= 0} map {$$_{heart_rate}} @{$$w{intervals}};
        my $maxHR = max(@hrs);
        $$w{max_heart_rate} = $maxHR if defined $maxHR and $maxHR >= 0;
      }
    }

    for my $w(@workouts){
      calculateDistanceTargets($w);
    }

    if(defined $$opts{bestDistanceFilter}){
      my %isRecordByWorkoutId;
      my $curRecord = undef;
      for my $workout(@workouts){
        my $time = getBestTimeForDistance($workout, $$opts{bestDistanceFilter});
        if(defined $time and (not defined $curRecord or $time < $curRecord)){
          $curRecord = $time;
          $isRecordByWorkoutId{$$workout{workout_id}} = 1;
        }else{
          $isRecordByWorkoutId{$$workout{workout_id}} = 0;
        }
      }
      @workouts = grep {$isRecordByWorkoutId{$$_{workout_id}}} @workouts;
    }

    if(defined $$opts{trimIntervalsDistance}){
      for my $workout(@workouts){
        my $intervals = $$workout{intervals};
        my $curDist = 0;
        my $i=0;
        while($i < @$intervals && $curDist < $$opts{trimIntervalsDistance}){
          $curDist += ${$$intervals[$i]}{calculatedDistance};
          $i++;
        }
        if($i < @$intervals){
          splice @$intervals, $i;
        }
      }
    }

    if($$opts{intervalsRemoveLargeHeartrateErrors}){
      for my $w(@workouts){
        removeHeartrateErrors($w, 60, 0.9);
      }
    }

    if($$opts{format} eq $FORMAT_DETAILS){
      for my $w(@workouts){
        print formatWorkoutDetails($opts, $w);
      }
    }elsif($$opts{format} eq $FORMAT_WEEKLY){
      my @periods = groupWorkoutsIntoPeriods(
        $DATE_BOUNDARY_WEEK_START, $DATE_BOUNDARY_WEEK_END, @workouts);
      for my $period(@periods){
        print formatWorkoutsSummary($opts, $$period{start}, @{$$period{workouts}});
      }
    }elsif($$opts{format} eq $FORMAT_MONTHLY){
      my @periods = groupWorkoutsIntoPeriods(
        $DATE_BOUNDARY_MONTH_START, $DATE_BOUNDARY_MONTH_END, @workouts);
      for my $period(@periods){
        print formatWorkoutsSummary($opts, $$period{start}, @{$$period{workouts}});
      }
    }elsif($$opts{format} eq $FORMAT_GNUPLOT){
      my $plotType = $$opts{plotType};
      $plotType = "" if not defined $plotType;

      my $nowMillis = nowMillis();
      my $nowEpoch = $nowMillis / 1000.0;
      my $nowFmt = dateFmt("%Y-%m-%d_%H%M%S", $nowEpoch);
      if(not -d $GNUPLOT_OUTPUT_DIR){
        system "mkdir", "-p", $GNUPLOT_OUTPUT_DIR;
      }
      my $outputFile = "$GNUPLOT_OUTPUT_DIR/${nowFmt}_$plotType.png";

      if($plotType =~ /^($OK_NAMED_TARGET_REGEX)$/i){
        my $targetName = lc $plotType;
        my @points;
        for my $w(@workouts){
          my $targetDurS = $$w{targets}{$targetName};
          if(defined $targetDurS){
            push @points, [$$w{dtmEpoch}, $targetDurS];
          }
        }

        gnuplotDurations($opts, $targetName, $outputFile, @points);
        system "feh", $outputFile;
      }elsif($plotType =~ /^(d|distance)$/i){
        my $targetName = lc $plotType;
        my @points;
        for my $w(@workouts){
          my $distM = $$w{distance};
          push @points, [$$w{dtmEpoch}, $distM];
        }

        gnuplotDistances($opts, $targetName, $outputFile, @points);
        system "feh", $outputFile;
      }elsif($plotType =~ /^(mph|speed)$/i){
        my $pointsByPlotName = {};
        for my $w(@workouts){
          my $points = [];
          for my $interval(@{$$w{intervals}}){
            my $mph = $$interval{speed} * $MILES_PER_KM;
            if(defined $mph and $mph > 0){
              push @$points, [$$interval{calculatedElapsed}, $mph];
            }
          }
          if(@$points == 0){
            #skip workouts with no heartrate data
            next;
          }

          my $plotName = $$w{dtmYMDHMS};
          $$pointsByPlotName{$plotName} = $points;
        }

        gnuplotSpeeds($opts, $outputFile, $pointsByPlotName);
        system "feh", $outputFile;
      }elsif($plotType =~ /^(hr|heartrate)$/i){
        my $pointsByPlotName = {};
        for my $w(@workouts){
          my $points = [];
          for my $interval(@{$$w{intervals}}){
            my $hr = $$interval{heart_rate};
            if(defined $hr and $hr > 0){
              push @$points, [$$interval{calculatedElapsed}, $hr];
            }
          }
          if(@$points == 0){
            #skip workouts with no heartrate data
            next;
          }

          my $plotName = $$w{dtmYMDHMS};
          $$pointsByPlotName{$plotName} = $points;
        }

        gnuplotHeartrates($opts, $outputFile, $pointsByPlotName);
        system "feh", $outputFile;
      }else{
        die "ERROR: missing/invalid PLOT_TYPE \"$plotType\"\n";
      }
    }else{
      die "ERROR: unknown format $$opts{format}\n";
    }
  }elsif($cmd eq $COMMAND_FETCH){
    if(not fetchViewfitWorkouts()){
      die "ERROR: fetch viewfit workouts failed\n";
    }


    my $w = readCachedWorkoutLatest();
    die "ERROR: no workouts found\n" if not defined $w;
    my $distanceMiles = sprintf "%.2f", $$w{distance}/1000.0*$MILES_PER_KM;
    my $durS = $$w{duration};
    my $durFmt = formatTimeMinSec($durS);
    my $elapsedS = time - $$w{dtmEpoch};
    my $elapsedFmt = formatTimeRelative($elapsedS) . " ago";
    print "\nlatest workout: ($elapsedFmt) $$w{dtmYMDHMS}   ${distanceMiles}mi  $durFmt\n";
  }elsif($cmd eq $COMMAND_FETCH_LOOP){
    my $pid = fork();
    if($pid == 0){
      while(1){
        print "\n\n=====\n";
        system "date";
        if(not fetchViewfitWorkouts()){
          print "WARNING: fetch viewfit workouts failed\n";
        }
        my $w = readCachedWorkoutLatest();
        if(defined $w){
          my $distanceMiles = sprintf "%.2f", $$w{distance}/1000.0*$MILES_PER_KM;
          my $durS = $$w{duration};
          my $durFmt = formatTimeMinSec($durS);
          my $elapsedS = time - $$w{dtmEpoch};
          my $elapsedFmt = formatTimeRelative($elapsedS) . " ago";
          print "\nlatest workout: ($elapsedFmt) $$w{dtmYMDHMS}   ${distanceMiles}mi  $durFmt\n";
        }else{
          print "\nno workouts\n";
        }
      }
    }else{
      my $input = <STDIN>;
      print "\nEXITING\n";
      kill 1, $pid;
      waitpid $pid, 0;
    }
  }elsif($cmd eq $COMMAND_CLEAR_CACHE){
    my @intervalCacheFiles = grep {-f $_} glob "$WORKOUTS_INTERVAL_CACHE_DIR/*";
    if(@intervalCacheFiles > 0){
      print "# deleting " . (0+@intervalCacheFiles) . " interval cache file(s)\n";
      run "rm", "-r", $WORKOUTS_INTERVAL_CACHE_DIR;
    }else{
      print "# no interval cache files to remove\n";
    }
  }else{
    die $USAGE;
  }
}

sub parseDistanceFmt($){
  my ($distanceFmt) = @_;
  if($distanceFmt =~ /^(\d+|\d*\.\d+)(k|km|mi)$/i){
    my ($distVal, $distUnit) = ($1, $2);
    my $distKM = $distUnit =~ /mi/i ? $distVal / $MILES_PER_KM : $distVal;
    return $distKM * 1000.0;
  }else{
    die "ERROR: invalid distance '$distanceFmt'\n";
  }
}

sub formatWorkoutDetails($$){
  my ($opts, $w) = @_;
  my $fmt = "";

  my $maxHR = defined $$w{max_heart_rate} ? $$w{max_heart_rate} : 0;
  my $durS = $$w{duration};
  my $durFmt = formatTimeMinSec($durS);
  my $distanceMiles = $$w{distance}/1000.0*$MILES_PER_KM;
  my $optionalTargetFmt;
  if($$opts{printDistanceTargets}){
    $optionalTargetFmt = sprintf "%12s|", "";
    for my $targetName(@SORTED_TARGET_NAMES){
      if(defined $$opts{distanceNamedTarget}){
        next if lc $targetName ne lc $$opts{distanceNamedTarget};
      }
      if(defined $$w{targets}{$targetName}){
        my $targetDurS = $$w{targets}{$targetName};
        my $targetDurFmt = formatTimeMinSec($targetDurS);
        $optionalTargetFmt = sprintf "%6s=%5s|", $targetName, $targetDurFmt;
        last;
      }
    }
  }else{
    $optionalTargetFmt = "";
  }

  my $idPrefix = $$opts{printIds} ? sprintf("%-24s   ", $$w{workout_id}) : "";

  my $dtmFmt = $$opts{printStartTime} ? $$w{dtmYMDHMS} : $$w{dtmYMD};

  $fmt .= sprintf "%s%s | %5.2fkm %4.1fmi | %6s | %3d |%s\n",
    $idPrefix,
    $dtmFmt,
    $$w{distance}/1000.0,
    $distanceMiles,
    $durFmt,
    $maxHR,
    $optionalTargetFmt,
  ;

  if($$opts{printSpeedSegments}){
    my @segments = groupIntervalsIntoSpeedSegments($w);
    for my $segment(@segments){
      $fmt .= formatSpeedSegment($segment);
    }
  }

  if($$opts{printIntervals}){
    for my $i(@{$$w{intervals}}){
      $fmt .= "{" . join(",", map {"\"$_\":$$i{$_}"} sort keys %$i) . "}\n";
    }
  }

  return $fmt;
}

sub formatWorkoutsSummary($$@){
  my ($opts, $name, @workouts) = @_;

  my %targets;
  my $totalDur = 0;
  my $totalDist = 0;
  my $sumMaxHR = 0;
  for my $w(@workouts){
    $totalDur += $$w{duration};
    $totalDist += $$w{distance};
    $sumMaxHR += defined $$w{max_heart_rate} ? $$w{max_heart_rate} : 0;

    for my $targetName(@SORTED_TARGET_NAMES){
      if(defined $$w{targets}{$targetName}){
        $targets{$targetName} = [] if not defined $targets{$targetName};
        my $targetDurS = $$w{targets}{$targetName};
        push @{$targets{$targetName}}, $targetDurS;
        last;
      }
    }
  }

  my $avgMaxHR = @workouts > 0 ? sprintf "%d", ($sumMaxHR / @workouts) : 0;

  my $distanceKM = $totalDist/1000.0;
  my $distanceMiles = $totalDist/1000.0*$MILES_PER_KM;

  my @targetFmts;
  for my $targetName(@SORTED_TARGET_NAMES){
    if(defined $targets{$targetName}){
      my @targetWorkoutDurs = @{$targets{$targetName}};
      my $count = @targetWorkoutDurs;
      my $sumTime = 0;
      my $minTime = undef;
      for my $durS(@targetWorkoutDurs){
        $sumTime += $durS;
        $minTime = $durS if not defined $minTime or $durS < $minTime;
      }
      my $avgTime = @targetWorkoutDurs > 0 ? $sumTime / @targetWorkoutDurs : 0;
      push @targetFmts, sprintf("%2dx%s=%s(%s)",
        $count,
        $targetName,
        formatTimeMinSec($minTime),
        formatTimeMinSec($avgTime),
      );
    }
  }

  return sprintf "%-10s | %3dkm %3dmi | %8s | %s\n",
    $name,
    $distanceKM,
    $distanceMiles,
    formatTimeHrMinSec($totalDur),
    join(" ", map {sprintf "%-14s", $_} @targetFmts),
  ;
}

sub gnuplotDurations($$$@){
  my ($opts, $plotName, $outputFile, @points) = @_;

  my $scriptFile = "/tmp/workout-viewfit-gnuplot-script";
  my $dataFile = "/tmp/workout-viewfit-gnuplot-data";

  my $dataFmt = "$plotName\n";

  for(my $i=0; $i<@points; $i++){
    my $point = $points[$i];
    my ($dtmEpoch, $durS) = @$point;

    #show point label if the point is the min or max of the 5 points before and after
    my $useLabel = 0;
    my @localIdxs = grep {$_ != $i} ($i-5 .. $i+5);
    my @localDurVals = map {$points[$_][1]} grep {0 <= $_ && $_ <= $#points} @localIdxs;
    my @smallerLocalDurVals = grep {$_ < $durS} @localDurVals;
    my @largerLocalDurVals = grep {$_ > $durS} @localDurVals;
    if(@smallerLocalDurVals == 0 or @largerLocalDurVals == 0){
      $useLabel = 1;
    }

    my $label = $useLabel ? formatTimeMinSec($durS) : "";

    $dataFmt .= sprintf "%d,%d,%s\n",
      $dtmEpoch,
      $durS,
      $label,
    ;
  }
  writeFile($dataFile, $dataFmt);

  my $minDur = min(map {$$_[1]} @points);
  my $maxDur = max(map {$$_[1]} @points);

  my $minMinute = floor( ($minDur-30)/60 ); #largest minute at least 30s before minDur
  my $maxMinute = ceil(  ($maxDur+30)/60 ); #smallest minute at least 30s after maxDur

  my ($yRangeMin, $yRangeMax) = ($minMinute*60, $maxMinute*60);

  #y-axis tics at 60-second intervals labeled as '<MIN>:00'
  my $yticsCsv = join(", ", map {"\"$_:00\" " . $_*60} $minMinute..$maxMinute);

  my $scriptContents = ""
    . "set datafile separator comma\n"
    . "set key autotitle columnheader horizontal\n"
    . "set term pngcairo size 1920,1080\n"
    . "set output \"$outputFile\"\n"
    . "\n"
    . "set xdata time\n"
    . "set timefmt \"%Y-%m-%d\"\n"
    . "set format x \"%Y-%m-%d\"\n"
    . "\n"
    . "set yrange [$yRangeMin:$yRangeMax]\n"
    . "set ytics ($yticsCsv)\n"
    . "\n"
    . "plot"
        . " \"$dataFile\" using (timecolumn(1,\"%s\")):2"
        . " with linespoints pointtype 5"
        . ", "
        . " \"$dataFile\" using (timecolumn(1,\"%s\")):2"
        . " smooth bezier"
        . ", "
        . "\"$dataFile\" using (timecolumn(1,\"%s\")):2:3"
        . " with labels offset 0,-1 notitle"
        . "\n"
  ;
  writeFile($scriptFile, $scriptContents);
  system "rm", $outputFile;
  system "gnuplot", "-p", $scriptFile;
}

sub gnuplotDistances($$$@){
  my ($opts, $plotName, $outputFile, @points) = @_;

  my $scriptFile = "/tmp/workout-viewfit-gnuplot-script";
  my $dataFile = "/tmp/workout-viewfit-gnuplot-data";

  my $dataFmt = "$plotName\n";

  for(my $i=0; $i<@points; $i++){
    my $point = $points[$i];
    my ($dtmEpoch, $distM) = @$point;

    #show point label if the point is the min or max of the 5 points before and after
    my $useLabel = 0;
    my @localIdxs = grep {$_ != $i} ($i-25 .. $i+25);
    my @localDistVals = map {$points[$_][1]} grep {0 <= $_ && $_ <= $#points} @localIdxs;
    my @smallerlocalDistVals = grep {$_ < $distM} @localDistVals;
    my @largerlocalDistVals = grep {$_ > $distM} @localDistVals;
    if(@smallerlocalDistVals == 0 or @largerlocalDistVals == 0){
      $useLabel = 1;
    }

    my $label = $useLabel ? sprintf("%.1fkm", $distM/1000.0) : "";

    $dataFmt .= sprintf "%d,%d,%s\n",
      $dtmEpoch,
      $distM,
      $label,
    ;
  }
  writeFile($dataFile, $dataFmt);

  my $minDist = min(map {$$_[1]} @points);
  my $maxDist = max(map {$$_[1]} @points);

  my ($yRangeMin, $yRangeMax) = ($minDist, $maxDist);

  my $scriptContents = ""
    . "set datafile separator comma\n"
    . "set key autotitle columnheader horizontal\n"
    . "set term pngcairo size 1920,1080\n"
    . "set output \"$outputFile\"\n"
    . "\n"
    . "set xdata time\n"
    . "set timefmt \"%Y-%m-%d\"\n"
    . "set format x \"%Y-%m-%d\"\n"
    . "\n"
    . "set yrange [$yRangeMin:$yRangeMax]\n"
    . "\n"
    . "plot"
        . " \"$dataFile\" using (timecolumn(1,\"%s\")):2"
        . " with linespoints pointtype 4"
        . ", "
        . " \"$dataFile\" using (timecolumn(1,\"%s\")):2"
        . " smooth bezier"
        . ", "
        . "\"$dataFile\" using (timecolumn(1,\"%s\")):2:3"
        . " with labels offset 0,-1 notitle"
        . "\n"
  ;
  writeFile($scriptFile, $scriptContents);
  system "rm", $outputFile;
  system "gnuplot", "-p", $scriptFile;
}

sub gnuplotSpeeds($$@){
  my ($opts, $outputFile, $pointsByPlotName) = @_;

  my $scriptFile = "/tmp/workout-viewfit-gnuplot-script";
  my $dataFile = "/tmp/workout-viewfit-gnuplot-data";

  my $minDur = undef;
  my $maxDur = undef;
  my $minSpeed = undef;
  my $maxSpeed = undef;

  my $dataFmt = "";
  for my $plotName(sort keys %$pointsByPlotName){
    my @points = @{$$pointsByPlotName{$plotName}};
    $dataFmt .= "\"$plotName\"\n";

    my $lastLabel = undef;
    for(my $i=0; $i<@points; $i++){
      my $point = $points[$i];
      my ($durS, $speed) = @$point;

      if(not defined $minDur or $durS < $minDur){
        $minDur = $durS;
      }
      if(not defined $maxDur or $durS > $maxDur){
        $maxDur = $durS;
      }
      if(not defined $minSpeed or $speed < $minSpeed){
        $minSpeed = $speed;
      }
      if(not defined $maxSpeed or $speed > $maxSpeed){
        $maxSpeed = $speed;
      }

      my $maybeLabel = sprintf("%.1fmph", $speed);

      my $useLabel = 0;
      if(not defined $lastLabel or $maybeLabel ne $lastLabel){
        my @localIdxs = grep {$_ != $i} ($i-25 .. $i+25);
        my @localSpeedVals = map {$points[$_][1]} grep {0 <= $_ && $_ <= $#points} @localIdxs;
        my @smallerlocalSpeedVals = grep {$_ < $speed} @localSpeedVals;
        my @largerlocalSpeedVals = grep {$_ > $speed} @localSpeedVals;
        if(@smallerlocalSpeedVals == 0 or @largerlocalSpeedVals == 0){
          $useLabel = 1;
          $lastLabel = $maybeLabel;
        }
      }

      $dataFmt .= sprintf "%d,%.2f,%s\n",
        $durS,
        $speed,
        ($useLabel ? $maybeLabel : ""),
      ;
    }
    $dataFmt .= "\n\n";
  }
  writeFile($dataFile, $dataFmt);

  my $workoutCount = 0 + keys %$pointsByPlotName;
  my $workoutLastIdx = $workoutCount - 1;

  my $minMinute = 0; #all workouts start at 0s
  my $maxMinute = ceil(  ($maxDur+30)/60 ); #smallest minute at least 30s after maxDur

  my ($xRangeMin, $xRangeMax) = ($minMinute*60, $maxMinute*60);
  my ($yRangeMin, $yRangeMax) = (int($minSpeed)-1, int($maxSpeed)+1);

  #x-axis tics at 3min intervals labeled '<MIN>:00'
  my $xticsCsv = join(", ", map {"\"${_}:00\" " . $_*60} grep {$_ % 3 == 0} $minMinute..$maxMinute);

  my $scriptContents = ""
    . "set datafile separator comma\n"
    . "set key autotitle columnheader horizontal\n"
    . "set term pngcairo size 1920,1080\n"
    . "set output \"$outputFile\"\n"
    . "\n"
    . "set yrange [$yRangeMin:$yRangeMax]\n"
    . "set ytics 1\n"
    . "\n"
    . "set xrange [$xRangeMin:$xRangeMax]\n"
    . "set xtics ($xticsCsv)\n"
    . "\n"
    . "plot"
        . " for [WORKOUT=0:$workoutLastIdx]"
        . " \"$dataFile\" index WORKOUT using (timecolumn(1,\"%s\")):2"
        . " with lines, "
        . " for [WORKOUT=0:$workoutLastIdx]"
        . " \"$dataFile\" index WORKOUT using (timecolumn(1,\"%s\")):2:3"
        . " with labels offset 0,-1 notitle"
        . "\n"
  ;
  writeFile($scriptFile, $scriptContents);
  system "rm", "-f", $outputFile;
  system "gnuplot", "-p", $scriptFile;
}

sub gnuplotHeartrates($$@){
  my ($opts, $outputFile, $pointsByPlotName) = @_;

  my $scriptFile = "/tmp/workout-viewfit-gnuplot-script";
  my $dataFile = "/tmp/workout-viewfit-gnuplot-data";

  my $minDur = undef;
  my $maxDur = undef;
  my $minHR = undef;
  my $maxHR = undef;

  my $dataFmt = "";
  for my $plotName(sort keys %$pointsByPlotName){
    my @points = @{$$pointsByPlotName{$plotName}};
    $dataFmt .= "\"$plotName\"\n";

    for(my $i=0; $i<@points; $i++){
      my $point = $points[$i];
      my ($durS, $hr) = @$point;

      if(not defined $minDur or $durS < $minDur){
        $minDur = $durS;
      }
      if(not defined $maxDur or $durS > $maxDur){
        $maxDur = $durS;
      }
      if(not defined $minHR or $hr < $minHR){
        $minHR = $hr;
      }
      if(not defined $maxHR or $hr > $maxHR){
        $maxHR = $hr;
      }

      $dataFmt .= sprintf "%d,%d\n",
        $durS,
        $hr,
      ;
    }
    $dataFmt .= "\n\n";
  }
  writeFile($dataFile, $dataFmt);

  my $workoutCount = 0 + keys %$pointsByPlotName;
  my $workoutLastIdx = $workoutCount - 1;

  $minHR = $$opts{minHeartratePlot} if $minHR < $$opts{minHeartratePlot};
  $maxHR += 3;

  my $minMinute = 0; #all workouts start at 0s
  my $maxMinute = ceil(  ($maxDur+30)/60 ); #smallest minute at least 30s after maxDur

  my ($xRangeMin, $xRangeMax) = ($minMinute*60, $maxMinute*60);

  #x-axis tics at 3min intervals labeled '<MIN>:00'
  my $xticsCsv = join(", ", map {"\"${_}:00\" " . $_*60} grep {$_ % 3 == 0} $minMinute..$maxMinute);

  my $scriptContents = ""
    . "set datafile separator comma\n"
    . "set key autotitle columnheader horizontal\n"
    . "set term pngcairo size 1920,1080\n"
    . "set output \"$outputFile\"\n"
    . "\n"
    . "set yrange [$minHR:$maxHR]\n"
    . "set ytics 4\n"
    . "\n"
    . "set xrange [$xRangeMin:$xRangeMax]\n"
    . "set xtics ($xticsCsv)\n"
    . "\n"
    . "plot"
        . " for [WORKOUT=0:$workoutLastIdx]"
        . " \"$dataFile\" index WORKOUT using (timecolumn(1,\"%s\")):2"
        . " with lines"
        . "\n"
  ;
  writeFile($scriptFile, $scriptContents);
  system "rm", "-f", $outputFile;
  system "gnuplot", "-p", $scriptFile;
}

sub readCachedWorkouts(){
  if(not -f $WORKOUTS_MERGED_JSON_FILE){
    print STDERR "\nmerging all fetched JSON files into $WORKOUTS_MERGED_JSON_FILE\n";
    mergeCachedJsonFiles();
  }
  if(not -f $WORKOUTS_MERGED_JSON_FILE){
    die "ERROR: missing $WORKOUTS_MERGED_JSON_FILE\n";
  }

  my $json = readFile($WORKOUTS_MERGED_JSON_FILE);
  my $jsonObj = Cpanel::JSON::XS->new->utf8->decode($json);
  my @workouts = @{$$jsonObj{workouts}};

  for my $workout(@workouts){
    my $epoch = dtmStrToEpoch($$workout{workout_time});
    if(not defined $epoch or $epoch !~ /^-?\d+\.\d+$/){
      die "ERROR: invalid workout_time for $$workout{workout_id}\n";
    }
    $$workout{dtmEpoch} = $epoch; #fractional seconds since epoch
    $$workout{dtmYMD} = dateFmt("%Y-%m-%d", $epoch);
    $$workout{dtmYMDHMS} = dateFmt("%Y-%m-%d %H:%M:%S", $epoch);
  }

  return @workouts;
}

sub readCachedWorkoutLatest(){
  my @workouts = readCachedWorkouts();
  @workouts = sort {
    $$a{dtmEpoch} <=> $$b{dtmEpoch}
  } @workouts;
  if(@workouts == 0){
    return undef;
  }else{
    return $workouts[-1];
  }
}

sub readExtraInfo(){
  my @lines = `cat $WORKOUTS_EXTRA_INFO_FILE 2>/dev/null`;
  my $extraInfo = {};
  for my $line(@lines){
    $line =~ s/#.*//;
    next if $line =~ /^\s*$/;
    if($line =~ /^(\w+)\.(\w+)\s*=\s*(.*)$/){
      my ($id, $key, $val) = ($1, $2, $3);
      $$extraInfo{$id} = {} if not defined $$extraInfo{$id};
      $$extraInfo{$id}{$key} = $val;
    }else{
      die "ERROR: invalid line in $WORKOUTS_EXTRA_INFO_FILE\n$line\n";
    }
  }
  return $extraInfo;
}
sub insertExtraInfo($@){
  my ($extraInfo, @workouts) = @_;
  for my $workoutID(sort keys %$extraInfo){
    my $info = $$extraInfo{$workoutID};

    my $workout = undef;
    for my $w(@workouts){
      if($workoutID eq $$w{workout_id}){
        $workout = $w;
        last;
      }
    }

    if(not defined $workout){
      my ($epoch, $duration, $distance) = ($$info{epoch}, $$info{duration}, $$info{distance});
      if(not defined $epoch or not defined $duration or not defined $distance){
        my $msg = ""
          . "ERROR: extra info for $workoutID could not be inserted\n"
          . "  (epoch+duration+distance are required for adding missing workouts)\n"
        ;
        die $msg;
      }elsif($epoch !~ /^-?\d+(\.\d+)?$/){
        die "ERROR: invalid epoch=$epoch for extra info $workoutID\n";
      }elsif($duration !~ /^\d+(\.\d+)?$/){
        die "ERROR: invalid duration=$duration for extra info $workoutID\n";
      }elsif($distance !~ /^\d+(\.\d+)?$/){
        die "ERROR: invalid distance=$distance for extra info $workoutID\n";
      }

      $workout = {
        workout_id     => $workoutID,
        duration       => $duration,
        distance       => $distance,
        dtmEpoch       => $epoch,
        dtmYMD         => dateFmt("%Y-%m-%d", $epoch),
        dtmYMDHMS      => dateFmt("%Y-%m-%d %H:%M:%S", $epoch),
        intervals      => [],
      };

      push @workouts, $workout;
    }

    for my $key(sort keys %$info){
      my $val = $$info{$key};
      if($key eq "intervals"){
        my $intervals = $$workout{intervals};

        my @extraIntervals = split /,/, $val;
        for my $extraInterval(@extraIntervals){
          if($extraInterval !~ /^(\d+|\d*\.\d+)s:(\d+|\d*\.\d+)m$/){
            die "ERROR: malformed $workoutID.$key=$val\n";
          }
          my ($duration, $distance) = ($1, $2);
          if($duration == 0){
            die "ERROR: duration cannot be 0 in $workoutID.$key=$val\n";
          }
          my $speed = ($distance/$duration)*60*60/1000;

          my $prevAvgDistance = 0;
          if(@$intervals > 0){
            $prevAvgDistance = ${$$intervals[-1]}{average_distance};
          }

          push @$intervals, {
            duration => $duration,
            distance => $distance,
            average_distance => $prevAvgDistance + $distance,
            speed => $speed,
            heart_rate => 0,
            power => 0,
          };
        }
      }else{
        $$workout{$key} = $val;
      }
    }
  }

  return @workouts;
}

# split large intervals into 10s intervals,
#    keeping at least 2s in the new smaller intervals
# i.e.:
#   -ensure that all intervals are <= 12s
#   -prefer creating 10s intervals where possible
#   -ensure that all newly created intervals are > 2s
#   -pre-existing intervals <= 2s are preserved
sub splitUpLargeIntervals($){
  my ($workout) = @_;
  my $newIntervals = [];
  for my $interval(@{$$workout{intervals}}){
    my $curAvgDistance = $$interval{average_distance} - $$interval{distance};
    $curAvgDistance = 0 if $curAvgDistance < 0;

    while($$interval{duration} > 12.0){
      #remove 10s from interval and prepend as new interval
      my $newDuration = 10.0;
      my $newDistance = $$interval{distance} * ($newDuration / $$interval{duration});
      $curAvgDistance += $newDistance;

      $$interval{duration} -= $newDuration;
      $$interval{distance} -= $newDistance;

      my $newInterval = {
        %$interval,
        duration         => $newDuration,
        distance         => $newDistance,
        average_distance => $curAvgDistance,
      };
      push @$newIntervals, $newInterval;
    }

    push @$newIntervals, $interval;
  }

  $$workout{intervals} = $newIntervals;
}

sub groupIntervalsIntoSpeedSegments($){
  my ($workout) = @_;
  my @intervals = @{$$workout{intervals}};
  my @segments;
  my $curSegment = undef;
  for(my $i=0; $i<@intervals; $i++){
    my $cur = $intervals[$i];
    my $prev = $i-1 > 0          ? $intervals[$i-1] : undef;
    my $next = $i+1 < @intervals ? $intervals[$i+1] : undef;
    my $curChanged = defined $prev && $$cur{speed} != $$prev{speed};
    my $nextChanged = defined $next && $$cur{speed} != $$next{speed};
    if($curChanged and not $nextChanged){
      #new segment if cur is new speed, AND the next segment is the same speed
      $curSegment = undef;
    }

    if(not defined $curSegment){
      $curSegment = [];
      push @segments, $curSegment;
    }
    push @$curSegment, $cur;
  }

  return @segments;
}

sub formatSpeedSegment($){
  my ($segment) = @_;
  my $segmentSpeedSeconds = 0;
  my $segmentHrSeconds = 0;
  my $segmentMaxHr = 0;
  my $segmentDur = 0;
  my $segmentDistance = 0;
  for my $interval(@$segment){
    $segmentSpeedSeconds += $$interval{speed} * $$interval{calculatedDuration};
    if(defined $$interval{heart_rate}){
      $segmentHrSeconds += $$interval{heart_rate} * $$interval{calculatedDuration};
      $segmentMaxHr = $$interval{heart_rate} if $$interval{heart_rate} > $segmentMaxHr;
    }
    $segmentDur += $$interval{calculatedDuration};
    $segmentDistance += $$interval{calculatedDistance};
  }
  my $avgSpeed = $segmentDur > 0 ? $segmentSpeedSeconds / $segmentDur : 0;
  my $avgHr = $segmentDur > 0 ? $segmentHrSeconds / $segmentDur : 0;
  my $maxHr = $segmentMaxHr;
  if($avgHr < 60){
    # exclude max and avg heart rate if average is nonsense (or bradycardia)
    #  (sometimes max will look sane because of a random single reading)
    $avgHr = 0;
    $maxHr = 0;
  }
  my $mph = $avgSpeed * $MILES_PER_KM;
  my $durFmt = formatTimeMinSec($segmentDur);
  my $kmFmt = $segmentDistance/1000.0;

  return sprintf "  %4.1fmph %s   %3dhr    %.1fkm\n",
    $mph,
    $durFmt,
    $maxHr,
    $kmFmt,
  ;
}

sub getHrmonHrByEpoch($){
  my ($dateYMD) = @_;

  my $hrByEpoch = readHrCache($HR_CACHE_DIR_HRMON, $dateYMD);

  if(not defined $hrByEpoch){
    #hrmon log start time must be strictly after 00:00:00 on the date
    #also ignore hrmon logs more than two days later
    my $minEpochMillis = int(dtmStrToEpoch($dateYMD) * 1000.0 + 0.5);
    my $maxEpochMillis = $minEpochMillis + 2*24*60*60*1000.0; #two days later

    my @files = grep {-f $_} glob "$HRMON_LOG_DIR/hrmon*.log*";
    my @okFiles;
    for my $file(@files){
      if($file !~ /hrmon-(\d+)\D/){
        die "ERROR: hrmon log file missing start millis \"$file\"\n";
      }
      my $epochMillis = $1;
      if($minEpochMillis <= $epochMillis && $epochMillis <= $maxEpochMillis){
        push @okFiles, $file;
      }
    }
    for my $file(@okFiles){
      my $grepCmd = "grep";
      if($file =~ /\.bz2$/){
        $grepCmd = "bzgrep";
      }elsif($file =~ /\.gzip$/){
        $grepCmd = "zgrep";
      }
      my @lines = `$grepCmd '$dateYMD .* Heart rate: *[0-9]\\+' $file`;
      for my $line(@lines){
        if($line =~ /^-*(\d+-\d+-\d+ \d+:\d+:\d+,\d+)\s*Heart rate:\s*(\d+)$/){
          my ($dtm, $hr) = ($1, $2);
          my $epochFracS = dtmStrToEpoch($dtm);
          $$hrByEpoch{$epochFracS} = $hr;
        }
      }
    }
    writeHrCache($HR_CACHE_DIR_HRMON, $dateYMD, $hrByEpoch);
  }

  return $hrByEpoch;
}

sub getAmazfishHrByEpoch($){
  my ($dateYMD) = @_;

  my $hrByEpoch = readHrCache($HR_CACHE_DIR_AMAZFISH, $dateYMD);

  if(not defined $hrByEpoch){
    $hrByEpoch = {};
    my @amazfishHrLines = `workout-amazfish --date=$dateYMD --skip-empty-dates --heartrates`;
    for my $line(@amazfishHrLines){
      if($line =~ /^\s*(\d+)\s*=\s*(\d+)\s*$/){
        my ($epoch, $hr) = ($1, $2);
        $$hrByEpoch{$epoch} = $hr;
      }else{
        die "ERROR: malformed line in workout-amazfish output\n$line\n";
      }
    }
    writeHrCache($HR_CACHE_DIR_AMAZFISH, $dateYMD, $hrByEpoch);
  }

  return $hrByEpoch;
}

sub readHrCache($$){
  my ($hrCacheDir, $dateYMD) = @_;
  my $cacheFile = "$hrCacheDir/$dateYMD";
  if(-f $cacheFile){
    my $hrByEpoch = {};
    my @lines = readFile $cacheFile;
    for my $line(@lines){
      if($line =~ /^\s*(\d+|\d*\.\d+)\s*=\s*(\d+)\s*$/){
        $$hrByEpoch{$1} = $2;
      }else{
        die "ERROR: malformed line in hr cache file $cacheFile\n$line\n";
      }
    }

    #ignore empty cache files if there are no newer non-empty cache files
    if(keys %$hrByEpoch == 0){
      my @nonEmptyCacheFiles = sort grep {-f $_ && not -z $_} glob "$hrCacheDir/*";
      my $latestCacheFile = @nonEmptyCacheFiles > 0 ? $nonEmptyCacheFiles[-1] : undef;
      my $latestCacheYMD = undef;
      if(defined $latestCacheFile){
        $latestCacheYMD = $1 if $latestCacheFile =~ /^(?:.*\/)?(\d+-\d+-\d+)$/;
      }
      if(not defined $latestCacheYMD or $dateYMD gt $latestCacheYMD){
        #skip cache - this empty cache file is later than the latest non-empty cache file
        return undef;
      }
    }

    return $hrByEpoch;
  }else{
    return undef;
  }
}
sub writeHrCache($$$){
  my ($hrCacheDir, $dateYMD, $hrByEpoch) = @_;
  my $cacheFile = "$hrCacheDir/$dateYMD";
  system "mkdir", "-p", $hrCacheDir;
  open my $fh, "> $cacheFile" or die "ERROR: could not write $cacheFile\n";
  my $maxEpoch = dtmStrToEpoch($dateYMD);
  for my $epoch(sort keys %$hrByEpoch){
    $maxEpoch = $epoch if $epoch > $maxEpoch;
    print $fh "$epoch=$$hrByEpoch{$epoch}\n";
  }
  close $fh;
  system "touch", $cacheFile, "--date=\@$maxEpoch";
}

sub isWorkoutNeedsExternalHeartrate($){
  my ($workout) = @_;

  my @intervals = @{$$workout{intervals}};
  my $totalHrSeconds = 0;
  my $totalDur = 0;
  for my $interval(@intervals){
    $totalHrSeconds += $$interval{heart_rate} * $$interval{calculatedDuration};
    $totalDur += $$interval{calculatedDuration};
  }

  if($totalDur <= 0){
    #dont add external hr to empty-interval workouts
    return 0;
  }

  my $avgHr = $totalHrSeconds/$totalDur;

  if($avgHr > 100){
    #dont add external hr if hr looks reasonable already
    return 0;
  }else{
    return 1;
  }
}

sub insertExternalHeartrates($$){
  my ($workout, $hrByEpoch) = @_;

  my @intervals = @{$$workout{intervals}};

  my @hrEpochs = sort keys %$hrByEpoch;

  for my $interval(@intervals){
    my $intervalEpoch = $$interval{calculatedEpoch};
    my $hrEpochIdx = binarySearchIdx sub{$_[0] <= $_[1]}, $intervalEpoch, \@hrEpochs;

    #NOTE:
    #  only fill in hr for intervals between
    #  two separate external measurements < 30s apart
    #    -viewfit intervals are ~10s apart
    #    -amazfish trackpoints are ~5s apart
    #    -hrmon intervals are ~1s apart
    next if $hrEpochIdx-1 < 0 or $hrEpochIdx > $#hrEpochs;
    my $startHrEpoch = $hrEpochs[$hrEpochIdx-1];
    my $endHrEpoch = $hrEpochs[$hrEpochIdx];
    my $intervalEpochBetweenHrEpochs =
      $startHrEpoch <= $intervalEpoch && $intervalEpoch <= $endHrEpoch;
    my $hrEpochsClose = ($endHrEpoch-$startHrEpoch) < 30;

    if($intervalEpochBetweenHrEpochs and $hrEpochsClose){
      my $startHr = $$hrByEpoch{$startHrEpoch};
      my $endHr = $$hrByEpoch{$endHrEpoch};

      #linear interpolation of interval
      my $elapsedRatio = ($intervalEpoch - $startHrEpoch) / ($endHrEpoch - $startHrEpoch);
      my $hr = $startHr + (($endHr - $startHr)*$elapsedRatio);

      $$interval{heart_rate} = $hr;
    }
  }
}

# zero-out heartrate for intervals that drop to a ratio for at most a number intervals
#   e.g.: removeHeartrateErrors(workout, 3, 0.90)
#     => remove intervals that drop by 10% for up to 3 intervals
sub removeHeartrateErrors($$$){
  my ($workout, $nearbyIdxCount, $threshold) = @_;
  my @intervals = @{$$workout{intervals}};

  for(my $i=0; $i<@intervals; $i++){
    my $hr = ${$intervals[$i]}{heart_rate};
    my $leftDropped = 0;
    for my $leftIdx($i-$nearbyIdxCount..$i-1){
      if($leftIdx >= 0){
        my $leftHr = ${$intervals[$leftIdx]}{heart_rate};
        if($leftHr * $threshold > $hr){
          $leftDropped = 1;
          last;
        }
      }
    }
    my $rightDropped = 0;
    for my $rightIdx($i+1..$i+$nearbyIdxCount){
      if($rightIdx <= $#intervals){
        my $rightHr = ${$intervals[$rightIdx]}{heart_rate};
        if($rightHr * $threshold > $hr){
          $rightDropped = 1;
          last;
        }
      }
    }
    if($leftDropped and $rightDropped){
      ${$intervals[$i]}{heart_rate} = 0;
    }
  }
}

sub calculateIntervals($){
  my ($w) = @_;

  #if workout has no intervals, add one with the whole workout
  if(@{$$w{intervals}} == 0){
    my $duration = $$w{duration};
    my $distance = $$w{distance};
    my $speed = $duration > 0 ? ($distance/1000.0) / ($duration/60.0/60.0) : 0;
    push @{$$w{intervals}}, {
      duration         => $duration,
      distance         => $distance,
      average_distance => $distance,
      speed            => $speed,
      heart_rate       => 0,
    };
  }

  #split the following intervals into multiple smaller intervals:
  #  long intervals added by extra info
  #  long intervals added in between combined workouts
  #  long intervals added for workouts without intervals
  #  any other intervals larger than 12s (should never be any)
  splitUpLargeIntervals($w);

  calculateScaledTimeAndDistance($w);

  if(isWorkoutNeedsExternalHeartrate($w)){
    my $hrByEpoch = getHrmonHrByEpoch($$w{dtmYMD});
    insertExternalHeartrates($w, $hrByEpoch);
  }
  if(isWorkoutNeedsExternalHeartrate($w)){
    my $hrByEpoch = getAmazfishHrByEpoch($$w{dtmYMD});
    insertExternalHeartrates($w, $hrByEpoch);
  }

  removeHeartrateErrors($w, 3, 0.90);
}

sub calculateScaledTimeAndDistance($){
  my ($workout) = @_;
  my @intervals = @{$$workout{intervals}};

  #the 'distance' value in interval does not correlate well to average_distance,
  #  and average_distance correlates much better with workout total distance,
  #  so: re-calculate distance from average_distance
  my $curElapsedS = 0;
  my $prevAvgDistance = 0;
  for my $interval(@intervals){
    $$interval{calculatedDistance} = $$interval{average_distance} - $prevAvgDistance;
    $prevAvgDistance = $$interval{average_distance};
  }

  #copy duration => calculated duration, in preparation for scaling
  for my $interval(@intervals){
    $$interval{calculatedDuration} = $$interval{duration};
  }

  #scale interval duration+distance to match overall workout duration+distance
  my $totalIntervalDuration = 0;
  my $totalIntervalDistance = 0;
  for my $interval(@intervals){
    $totalIntervalDuration += $$interval{calculatedDuration};
    $totalIntervalDistance += $$interval{calculatedDistance};
  }

  my $scalingDuration = $totalIntervalDuration > 0 ?
    $$workout{duration} / $totalIntervalDuration : 0;
  my $scalingDistance = $totalIntervalDistance > 0 ?
    $$workout{distance} / $totalIntervalDistance : 0;
  for my $interval(@intervals){
    $$interval{calculatedDuration} *= $scalingDuration;
    $$interval{calculatedDistance} *= $scalingDistance;
  }

  #calculate totals up-to-the-point for each interval
  my $elapsed = 0;
  my $totalDistance = 0;
  my $startEpoch = $$workout{dtmEpoch};
  for my $interval(@intervals){
    $elapsed += $$interval{calculatedDuration};
    $totalDistance += $$interval{calculatedDistance};

    $$interval{calculatedElapsed} = $elapsed;
    $$interval{calculatedEpoch} = $elapsed + $startEpoch;
    $$interval{calculatedTotalDistance} = $totalDistance;
  }
}

sub calculateDistanceTargets($){
  my ($workout) = @_;
  $$workout{targets} = {};
  for my $targetName(@SORTED_TARGET_NAMES){
    my $targetDist = $NAMED_TARGETS{$targetName};
    my $bestDur = getBestTimeForDistance($workout, $targetDist);
    $$workout{targets}{$targetName} = $bestDur;
  }
}

sub getBestTimeForDistance($$){
  my ($workout, $distance) = @_;
  my @intervals = @{$$workout{intervals}};

  my $startIdx = -1;
  my $endIdx = -1;
  my $curDist = 0;
  my $curDur = 0;
  my $bestDur = undef;
  while($startIdx <= $endIdx){
    #shift start to the right exactly one interval, and subtract the removed interval (if any)
    $startIdx++;
    if($startIdx-1 >= 0){
      $curDist -= ${$intervals[$startIdx-1]}{calculatedDistance};
      $curDur -= ${$intervals[$startIdx-1]}{calculatedDuration};
    }

    #shift end to the right until target min distance is reached, and add each added interval
    while($curDist < $distance and $endIdx+1 < @intervals){
      $endIdx++;
      $curDist += ${$intervals[$endIdx]}{calculatedDistance};
      $curDur += ${$intervals[$endIdx]}{calculatedDuration};
    }

    #if target distance is reached, check if it is the best duration set for target
    my $curDistM = int($curDist + 0.1);
    if($curDistM >= $distance and (not defined $bestDur or $curDur < $bestDur)){
      $bestDur = $curDur;
    }
  }
  return $bestDur;
}

sub readWorkoutsCombine(){
  my @lines = `cat $WORKOUTS_COMBINE_FILE 2>/dev/null`;
  my $workoutsCombineInfo = {};
  for my $line(@lines){
    $line =~ s/#.*//;
    next if $line =~ /^\s*$/;
    if($line =~ /^(\w+)\s*=\s*((?:\w+\s*,\s*)*\w+)\s*$/){
      my ($mainID, $combinedIDsCsv) = ($1, $2);
      my @combinedIDs = split /,/, $combinedIDsCsv;
      s/^\s*// foreach @combinedIDs;
      s/\s*$// foreach @combinedIDs;
      for my $id(@combinedIDs){
        if($id !~ /^\w+$/){
          die "ERROR: invalid ID in $WORKOUTS_COMBINE_FILE\n$line\n";
        }
      }
      $$workoutsCombineInfo{$mainID} = [@combinedIDs];
    }else{
      die "ERROR: invalid line in $WORKOUTS_COMBINE_FILE\n$line\n";
    }
  }
  return $workoutsCombineInfo;
}
sub applyAndFilterCombinedWorkouts($@){
  my ($workoutsCombineInfo, @workouts) = @_;
  my %workoutsByID = map {$$_{workout_id} => $_} @workouts;
  my %workoutIDsToExclude = map {$_ => 1} (map {@$_} values %$workoutsCombineInfo);

  my @combinedWorkouts;
  for my $workout(@workouts){
    my $workoutID = $$workout{workout_id};
    if(defined $$workoutsCombineInfo{$workoutID}){
      my @addtlWorkoutIDs = @{$$workoutsCombineInfo{$workoutID}};
      my @workoutsToCombine = ($workout, map {$workoutsByID{$_}} @addtlWorkoutIDs);
      @workoutsToCombine = sort {
        $$a{dtmEpoch} <=> $$b{dtmEpoch}
      } @workoutsToCombine;

      #foldl
      while(@workoutsToCombine > 1){
        my $w1 = shift @workoutsToCombine;
        my $w2 = shift @workoutsToCombine;
        @workoutsToCombine = (getCombinedWorkout($w1, $w2), @workoutsToCombine);
      }
      die "ERROR: combine workouts failed\n" if @workoutsToCombine != 1;
      push @combinedWorkouts, $workoutsToCombine[0];
    }elsif(not defined $workoutIDsToExclude{$workoutID}){
      push @combinedWorkouts, $workout;
    }else{
      #omit workout
    }
  }
  return @combinedWorkouts;
}

sub getCombinedWorkout($$){
  my ($w1, $w2) = @_;

  my $id1 = $$w1{workout_id};
  my $id2 = $$w2{workout_id};
  my $distance1 = $$w1{distance};
  my $distance2 = $$w2{distance};
  my $dur1 = $$w1{duration};
  my $dur2 = $$w2{duration};
  my $start1 = $$w1{dtmEpoch};
  my $start2 = $$w2{dtmEpoch};
  my $end1 = $start1 + $dur1;
  my $end2 = $start2 + $dur2;
  my $cal1 = nvl($$w1{calories}, 0);
  my $cal2 = nvl($$w2{calories}, 0);
  my $maxhr1 = nvl($$w1{max_heart_rate}, 0);
  my $maxhr2 = nvl($$w2{max_heart_rate}, 0);
  my $minhr1 = nvl($$w1{min_heart_rate}, 0);
  my $minhr2 = nvl($$w2{min_heart_rate}, 0);
  my $avghr1 = nvl($$w1{average_heart_rate}, 0);
  my $avghr2 = nvl($$w2{average_heart_rate}, 0);
  my @intervals1 = @{$$w1{intervals}};
  my @intervals2 = @{$$w2{intervals}};

  my $elapsedS = $start2 - $end1;

  #weighted by duration
  my $avghr = ($avghr1 * ($dur1/($dur1+$dur2))) + ($avghr2 * ($dur2/($dur1+$dur2)));

  if($id1 eq $id2){
    die "ERROR: duplicate combined workouts $id1 + $id2\n";
  }elsif($elapsedS > 180){
    die "ERROR: workouts to combine more than 3min apart (${elapsedS}s) $id1 + $id2\n";
  }

  my $lastIntervalW1 = $intervals1[-1];

  my $emptyInterval = {%$lastIntervalW1,
    duration => $elapsedS,
    distance => 0,
    speed => 0,
    power => 0,
  };

  #extend intervals in w2 by the last interval in w1
  for my $interval(@intervals2){
    $$interval{average_distance} += $$lastIntervalW1{average_distance};
  }

  $$w1{distance} = $distance1 + $distance2 + 0;
  $$w1{duration} = $dur1 + $dur2 + $elapsedS;
  $$w1{calories} = $cal1 + $cal2;
  $$w1{max_heart_rate} = $maxhr1 > $maxhr2 ? $maxhr1 : $maxhr2;
  $$w1{min_heart_rate} = $minhr1 < $minhr2 ? $minhr1 : $minhr2;
  $$w1{average_heart_rate} = int($avghr + 0.5);
  $$w1{intervals} = [@intervals1, $emptyInterval, @intervals2];

  return $w1;
}

sub fetchViewfitWorkouts(){
  my $exerciserUUID = getExerciserUUID();

  my $nowMillis = nowMillis();
  my $nowEpoch = $nowMillis / 1000.0;
  my $nowFmt = dateFmt("%Y-%m-%d_%H%M%S", $nowEpoch);
  my $tmpFile = "/tmp/workout-viewfit-$nowMillis.json";

  my $firstDayOfMonthEpoch = dtmStrToEpoch(dateFmt("%Y-%m-01", $nowEpoch));

  #start: 30 days before the first day of the current month
  #  (start date changes only when month changes to prevent refetching old data)
  my $startEpoch = int($firstDayOfMonthEpoch - 30*24*60*60);

  my $w = readCachedWorkoutLatest();
  if(defined $w){
    #attempt to go back before last workout if older than start date
    my $dayBeforeLastEpoch = int($$w{dtmEpoch} - 1*24*60*60);
    $startEpoch = $dayBeforeLastEpoch if $dayBeforeLastEpoch < $startEpoch;
  }

  my $endEpoch = int($nowEpoch + 1*24*60*60);

  if($endEpoch - $startEpoch > 120*24*60*60){
    die "ERROR: workout fetch date/time range too large: $startEpoch - $endEpoch\n";
  }

  my $url = "$VIEWFIT_EXERCISER_BASE_URL/$exerciserUUID/workouts"
    . "?startdate=$startEpoch&enddate=$endEpoch";

  my @cmd = ("curl",
    "--silent",
    "--max-time", $CURL_FETCH_MAX_TIME_S,
    $url,
    "--output", $tmpFile,
  );
  run @cmd;
  my $exitCode = $? >> 8;
  if($exitCode != 0){
    if($exitCode == 28){
      print STDERR "\nWARNING: curl timeout (60s)\n";
    }else{
      print STDERR "\nWARNING: curl failed with exit code $exitCode\n";
    }
    return 0;
  }

  my $md5 = md5sumFile($tmpFile);

  my $cacheFile = "$WORKOUTS_JSON_CACHE_DIR/workouts_${nowFmt}_${md5}_${nowMillis}.json";

  my @matchingFiles = grep {-f $_} glob "$WORKOUTS_JSON_CACHE_DIR/workouts_*_${md5}_*.json*";
  if(@matchingFiles > 0){
    print "\nskipping cache, JSON same as: $matchingFiles[0]\n";
    system "rm", $tmpFile;
  }else{
    print "\ncaching JSON in: $cacheFile\n";

    system "mkdir", "-p", $WORKOUTS_JSON_CACHE_DIR;
    system "mv", "--no-clobber", $tmpFile, $cacheFile;

    if(not -f $cacheFile){
      die "ERROR: failed to created $cacheFile\n";
    }

    run "gzip", $cacheFile;
  }

  my $maxJsonMtime = undef;
  for my $jsonFile(grep {-f $_} glob "$WORKOUTS_JSON_CACHE_DIR/workouts_*.json*"){
    my $mtime = mtime($jsonFile);
    $maxJsonMtime = $mtime if not defined $maxJsonMtime or $mtime > $maxJsonMtime;
  }

  if(-e $WORKOUTS_MERGED_JSON_FILE){
    my $mergedMtime = mtime($WORKOUTS_MERGED_JSON_FILE);
    if(not defined $maxJsonMtime or $mergedMtime < $maxJsonMtime){
      print "\nremoving out-of-date merged JSON\n";
      run "rm", $WORKOUTS_MERGED_JSON_FILE;
    }
  }

  if(not -f $WORKOUTS_MERGED_JSON_FILE){
    print "\nmerging all fetched JSON files into $WORKOUTS_MERGED_JSON_FILE\n";
    mergeCachedJsonFiles();
  }

  return 1;
}

sub mergeCachedJsonFiles(){
  my @downloadJsonFiles = (
    glob("$WORKOUTS_JSON_CACHE_DIR/workouts_*.json"),
    glob("$WORKOUTS_JSON_CACHE_DIR/workouts_*.json.gz"),
  );
  @downloadJsonFiles = sort @downloadJsonFiles;

  my $workoutsById = {};
  for my $file(@downloadJsonFiles){
    my $contents = $file =~ /\.gz$/i ? readFileGZ($file) : readFile($file);
    my @workoutStrs = $contents =~ /({"workout_id"(?:[^{}]|{[^}]*})*})/g;
    for my $workoutStr(@workoutStrs){
      my $workoutID = $1 if $workoutStr =~ /"workout_id":"([^"]*)"/;
      die "ERROR: missing workout_id in $file\n" if not defined $workoutID;
      $$workoutsById{$workoutID} = $workoutStr;
    }
  }

  my @workoutStrs = sort values %$workoutsById;

  writeFile($WORKOUTS_MERGED_JSON_FILE,
    "{\"workouts\":[\n  " . join(",\n  ", @workoutStrs) . "\n]}");
}

sub groupWorkoutsIntoPeriods($$@){
  my ($dateBoundaryTypeStart, $dateBoundaryTypeEnd, @workouts) = @_;
  my @periods;
  my $curPeriod = undef;
  for my $workout(@workouts){
    my $date = $$workout{dtmYMD};
    if(not defined $curPeriod or $date lt $$curPeriod{start} or $date gt $$curPeriod{end}){
      $curPeriod = {
        start    => getDateBoundary($date, $dateBoundaryTypeStart),
        end      => getDateBoundary($date, $dateBoundaryTypeEnd),
        workouts => [],
      };
      push @periods, $curPeriod;
    }
    push @{$$curPeriod{workouts}}, $workout;
  }
  return @periods;
}

sub readFile($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n$!\n";
  my @lines = <FH>;
  close FH;
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;;
  }
}
sub readFileGZ($){
  my ($file) = @_;
  open FH, "-|", "gzip -d --stdout $file"
    or die "ERROR: could not gunzip $file\n$!\n";
  my @lines = <FH>;
  close FH;
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;
  }
}

sub writeFile($$){
  my ($file, $content) = @_;
  open FH, "> $file" or die "ERROR: could not write $file\n$!\n";
  print FH $content;
  close FH;
}

sub getExerciserUUID(){
  my $secrets = readSecrets();
  if(not defined $$secrets{exerciser}){
    die "ERROR: could not read $SECRETS_PREFIX.excerciser in secrets\n"
  }
  return $$secrets{exerciser};
}

sub readSecrets(){
  my @lines = `cat $SECRETS_FILE 2>/dev/null`;
  my $secrets = {};
  for my $line(@lines){
    if($line =~ /^$SECRETS_PREFIX\.($SECRETS_KEYS_REGEX)\s*=\s*(.+)$/){
      $$secrets{$1} = $2;
    }
  }
  for my $key(sort keys %$secrets){
    $$secrets{$key} = decrypt $$secrets{$key} if defined $SECRETS_ENC_KEYS{$key};
  }
  return $secrets;
}

sub decrypt($){
  my ($s) = @_;
  open GPG, "-|", "gpg-sym", $s or die "could not run gpg-sym\n";
  my @contents = <GPG>;
  close GPG;
  die "error running gpg-sym\n$!\n" if $? != 0;
  my $value = join '', @contents;
  chomp $value;
  return $value;
}

sub formatTimeMinSec($){
  my ($s) = @_;
  return sprintf "%02d:%02d", int($s/60), int($s) % 60;
}
sub formatTimeHrMinSec($){
  my ($s) = @_;
  return sprintf "%02d:%02d:%02d", int($s/60/60), int($s/60) % 60, int($s) % 60;
}
sub formatTimeRelative($){
  my ($s) = @_;
  my ($day, $hr, $min, $sec) = (
    int($s/60/60/24), int($s/60/60) % 24, int($s/60) % 60, int($s) % 60
  );
  if($day > 0){
    return sprintf "%dd%02dh%02dm%02ds", $day, $hr, $min, $sec;
  }elsif($hr > 0){
    return sprintf "%dh%02dm%02ds", $hr, $min, $sec;
  }elsif($min > 0){
    return sprintf "%dm%02ds", $min, $sec;
  }else{
    return sprintf "%ds", $sec;
  }
}

sub dtmStrToEpoch($){
  my ($dtm) = @_;

  my $epochFracS;
  #timegm_posix/timelocal_posix is much faster than str2time
  if($dtm =~ /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d\d\d)Z$/){
    my ($y, $m, $d, $hour, $min, $sec, $millis) = ($1, $2, $3, $4, $5, $6, $7);
    my $isUTC = 1;
    $epochFracS = getEpochFracS($y, $m, $d, $hour, $min, $sec, $millis, $isUTC);
  }elsif($dtm =~ /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2}),(\d\d\d)$/){
    my ($y, $m, $d, $hour, $min, $sec, $millis) = ($1, $2, $3, $4, $5, $6, $7);
    my $isUTC = 0;
    $epochFracS = getEpochFracS($y, $m, $d, $hour, $min, $sec, $millis, $isUTC);
  }elsif($dtm =~ /^(\d{4})-(\d{2})-(\d{2})$/){
    my ($y, $m, $d) = ($1, $2, $3);
    my $isUTC = 0;
    $epochFracS = getEpochFracS($y, $m, $d, 0, 0, 0, 0, $isUTC);
  }else{
    $epochFracS = `date --date='$dtm' +%s.%3N`;
    chomp $epochFracS;
  }

  if(not defined $epochFracS or $epochFracS !~ /^-?(\d+\.\d+)$/){
    die "ERROR: failed to convert $dtm to epoch\n";
  }

  return $epochFracS;
}

sub getEpochFracS($$$$$$$$){
  my ($y, $m, $d, $hour, $min, $sec, $millis, $isUTC) = @_;
  my $epochS;
  if($isUTC){
    $epochS = timegm_posix($sec, $min, $hour, $d, $m-1, $y-1900);
  }else{
    $epochS = timelocal_posix($sec, $min, $hour, $d, $m-1, $y-1900);
  }

  if($epochS > 0){
    #faster
    return "$epochS.$millis";
  }else{
    #e.g.:
    #  1970-01-01T00:00:00.001Z ==  0.001 == (0  + 001/1000)
    #  1969-12-31T23:59:59.999Z == -0.001 == (-1 + 999/1000)
    return sprintf "%.3f", ($epochS + ($millis/1000.0));
  }
}

sub dateFmt($$){
  my ($fmtSpec, $epoch) = @_;
  die "ERROR: missing epoch\n" if not defined $epoch;
  die "ERROR: invalid epoch $epoch\n" if $epoch !~ /^-?(\d+|\d*\.\d+)$/;
  return time2str($fmtSpec, $epoch);
}

sub getDateBoundary($$){
  my ($dateYMD, $dateBoundaryType) = @_;
  my ($y, $m, $d) = ($1, $2, $3) if $dateYMD =~ /^(\d\d\d\d)-(\d\d)-(\d\d)$/;

  my $date = DateTime->new(year => $y, month => $m, day => $d);
  my $dayOfWeek = $date->day_of_week;
  my $daysToAdd;
  if($dateBoundaryType eq $DATE_BOUNDARY_WEEK_START){
    my $targetDOW = 1; #monday
    my $targetDaysAgo = (7 + ($dayOfWeek - $targetDOW)) % 7;
    $daysToAdd = 0 - ($targetDaysAgo);
  }elsif($dateBoundaryType eq $DATE_BOUNDARY_WEEK_END){
    my $targetDOW = 7; #sunday
    my $targetDaysUntil = (7 + ($targetDOW - $dayOfWeek)) % 7;
    $daysToAdd = $targetDaysUntil;
  }elsif($dateBoundaryType eq $DATE_BOUNDARY_MONTH_START){
    $daysToAdd = 0 - ($d - 1);
  }elsif($dateBoundaryType eq $DATE_BOUNDARY_MONTH_END){
    my $lastDayOfMonth = DateTime->last_day_of_month(year => $y, month => $m)->day_of_month;
    $daysToAdd = $lastDayOfMonth - $d;
  }else{
    die "ERROR: unknown date boundary type $dateBoundaryType\n";
  }

  $date->add(days => $daysToAdd);
  return $date->strftime("%Y-%m-%d");
}

#return the smallest index of the element
#  in the sorted list 'list' that is greater than or equal to 'targetItem',
#  or -1 if no element in 'list' is greater than or equal to 'targetItem'
#
#cmpLTESub is a comparator that returns true if the first arg
#  is less than or equal to the second, in the same sense as the list is sorted
#
#e.g.:
#  binarySearchIdx(sub{$_[0] <= $_[1]}, -1,  [0, 1, 2, 3, 4, 5]) == 0
#  binarySearchIdx(sub{$_[0] <= $_[1]}, 0,   [0, 1, 2, 3, 4, 5]) == 0
#  binarySearchIdx(sub{$_[0] <= $_[1]}, 0.9, [0, 1, 2, 3, 4, 5]) == 1
#  binarySearchIdx(sub{$_[0] <= $_[1]}, 1,   [0, 1, 2, 3, 4, 5]) == 1
#  binarySearchIdx(sub{$_[0] <= $_[1]}, 1.1, [0, 1, 2, 3, 4, 5]) == 2
#  binarySearchIdx(sub{$_[0] <= $_[1]}, 2,   [0, 1, 2, 3, 4, 5]) == 2
#  binarySearchIdx(sub{$_[0] <= $_[1]}, 6,   [0, 1, 2, 3, 4, 5]) == -1
sub binarySearchIdx($$$){
  my ($cmpLTESub, $targetItem, $list) = @_;

  if(@$list == 0){
    return -1;
  }elsif($targetItem > $$list[-1]){
    return -1;
  }

  my $min = 0;
  my $max = $#$list;
  while(1){
    my $mid = int(($max+$min) / 2);
    if($mid < 0 or $mid > $#$list){
      last;
    }

    if(&$cmpLTESub($targetItem, $$list[$mid])){
      #if target <= list[mid]
      $max = $mid;
    }else{
      $min = $mid + 1;
    }

    if($min == $max){
      return $min;
    }
  }

  return -1;
}

sub nvl($$){
  return defined $_[0] ? $_[0] : $_[1];
}

sub md5sumFile($){
  my ($file) = @_;
  my $d = Digest::MD5->new();
  open my $fh, "<", $file or die "ERROR: could not read $file\n$!\n";
  $d->addfile($fh);
  my $digest = $d->hexdigest();
  close $fh;
  return $digest;
}

sub mtime($){
  my ($file) = @_;
  my @stat = stat $file;
  return $stat[9];
}

sub nowMillis(){
  return int(time*1000.0 + 0.5)
}

sub run(@){
  print "@_\n";
  runQuiet(@_);
}

sub runQuiet(@){
  system @_;
}

&main(@ARGV);
