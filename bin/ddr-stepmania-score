#!/usr/bin/perl
use strict;
use warnings;

my $XML_FILE_PATTERN = "$ENV{HOME}/.stepmania-*/Save/Upload/*.xml";
my $SONGS_PARENT_DIR = "$ENV{HOME}/.stepmania-5.0";

sub parseXmlFile($);
sub parseSMFile($);
sub getOldestXmlFileAfterMtime($);

sub readFile($);
sub listDirFiles($);
sub mtime($);

sub main(@){
  my $targetFile = shift;

  my $targetMtime = mtime $targetFile;
  my $closestXmlFile = getOldestXmlFileAfterMtime $targetMtime;

  my $mtimeDiff = $targetMtime - mtime($closestXmlFile);
  $mtimeDiff = 0-$mtimeDiff if $mtimeDiff < 0;
  if($mtimeDiff > 60){
    print "\n\nWARNING: img mtime is more than 10s (${mtimeDiff}s) away from xml mtime\n";
  }

  my $xmlInfo = parseXmlFile $closestXmlFile;
  my $songDir = "$SONGS_PARENT_DIR/$$xmlInfo{songDir}";
  $songDir =~ s/\/$//;
  if(not -d $songDir){
    die "ERROR: \"$songDir\" is not a dir\n";
  }

  my @smFiles = grep {$_ =~ /\.(ssc|sm)$/} listDirFiles $songDir;
  die "ERROR: could not find SSC or SM file in $songDir\n" if @smFiles == 0;
  my $smFile = $smFiles[0];

  my $songInfo = parseSMFile $smFile;
}

sub parseXmlFile($){
  my ($xmlFile) = @_;
  my $xml = readFile $xmlFile;

  my $num = '(?:\d+|\d*\.\d+)';
  my $int = '\d+';

  my $info = {};
  $$info{songDir} = $1        if $xml =~ /<Song Dir=['"]([^'"]+)['"]\/>/;
  $$info{difficulty} = $1     if $xml =~ /<Steps.* Difficulty=['"]([^'"]+).*\/>/;
  $$info{game} = $1           if $xml =~ /<Steps.* StepsType=['"]([^'"]+).*\/>/;
  $$info{mods} = $1           if $xml =~ /<Modifiers>(.*)<\/Modifiers>/;

  $$info{grade} = $1          if $xml =~ /<Grade>(.*)<\/Grade>/;
  $$info{percentDP} = $1      if $xml =~ /<PercentDP>($num)<\/PercentDP>/;
  $$info{surviveSeconds} = $1 if $xml =~ /<SurviveSeconds>($num)<\/SurviveSeconds>/;
  $$info{maxCombo} = $1       if $xml =~ /<MaxCombo>($int)<\/MaxCombo>/;

  $$info{mineOk} = $1         if $xml =~ /<AvoidMine>($int)<\/AvoidMine>/;
  $$info{mineHit} = $1        if $xml =~ /<HitMine>($int)<\/HitMine>/;

  $$info{holdOk} = $1         if $xml =~ /<Held>($int)<\/Held>/;
  $$info{holdLetGo} = $1      if $xml =~ /<LetGo>($int)<\/LetGo>/;
  $$info{holdMissed} = $1     if $xml =~ /<MissedHold>($int)<\/MissedHold>/;

  $$info{flawless} = $1       if $xml =~ /<W1>($int)<\/W1>/;
  $$info{perfect} = $1        if $xml =~ /<W2>($int)<\/W2>/;
  $$info{great} = $1          if $xml =~ /<W3>($int)<\/W3>/;
  $$info{good} = $1           if $xml =~ /<W4>($int)<\/W4>/;
  $$info{bad} = $1            if $xml =~ /<W5>($int)<\/W5>/;
  $$info{miss} = $1           if $xml =~ /<Miss>($int)<\/Miss>/;

  for my $key(sort keys %$info){
    my ($val) = $$info{$key};
    $val =~ s/&lt;/</g;
    $val =~ s/&apos;/'/g;
    $val =~ s/&amp;/&/g;
    $$info{$key} = $val;
  }

  $$info{failed} = $$info{grade} =~ /failed/i ? "FAILED" : "passed";

  return $info;
}

sub parseSMFile($){
  my ($smFile) = @_;
  my $sm = readFile $smFile;
  my $noteSets = {};

  my @games = qw(
    dance-single dance-double dance-solo
    pump-single pump-double
  );
  my @diffs = qw(Beginner Easy Medium Hard Expert Challenge);
  my $reGames = join "|", @games;
  my $reDiffs = join "|", @diffs;

  #SM files
  while($sm =~ /
    \#NOTES                  \s*:\s*
    (?<game>$reGames)        \s*:\s*
    [^:]*?                   \s*:\s*
    (?<difficulty>$reDiffs)  \s*:\s*
    (?<feet>\d+)             \s*:\s*
    (?<radar>[^;]*?)         \s*:\s*
    (?<notes>[^;]+?)         ;
  /gsxi){
    my $key = lc "$+{game}-$+{difficulty}";
    $$noteSets{$key} = {%+};
  }

  #SSC files
  my @sscNoteSets = $sm =~ /\#NOTEDATA\s*:.*?#NOTES\s*:[^;]*;/gsi;
  for my $noteSet(@sscNoteSets){
    my $info = {};
    $$info{game} = $1       if $noteSet =~ /\#STEPSTYPE    \s*:\s*   ($reGames)   \s*;\s*/sxi;
    $$info{difficulty} = $1 if $noteSet =~ /\#DIFFICULTY   \s*:\s*   ($reDiffs)   \s*;\s*/sxi;
    $$info{feet} = $1       if $noteSet =~ /\#METER        \s*:\s*   (\d+)        \s*;\s*/sxi;
    $$info{radar} = $1      if $noteSet =~ /\#RADARVALUES  \s*:\s*   ([^;]+)      \s*;\s*/sxi;
    $$info{notes} = $1      if $noteSet =~ /\#NOTES        \s*:\s*   ([^;]+)      \s*;\s*/sxi;

    die "ERROR: missing STEPSTYPE from $smFile $noteSet\n" if not defined $$info{game};
    die "ERROR: missing DIFFICULTY from $smFile\n" if not defined $$info{difficulty};
    die "ERROR: missing NOTES from $smFile\n" if not defined $$info{notes};

    my $key = lc "$$info{game}-$$info{difficulty}";
    $$noteSets{$key} = $info;
  }

  my $numKeys = keys %$noteSets;
  if($numKeys == 0){
    die "ERROR: could not parse any note sets in $smFile\n";
  }

  return $noteSets;
}

sub getOldestXmlFileAfterMtime($){
  my ($targetMtime) = @_;

  my @xmlFiles = glob $XML_FILE_PATTERN;
  my %mtimes = map {$_ => mtime $_} @xmlFiles;
  @xmlFiles = sort {$mtimes{$a} <=> $mtimes{$b}} @xmlFiles;

  my $closestXmlFile;
  for my $xmlFile(@xmlFiles){
    my $xmlMtime = $mtimes{$xmlFile};
    if($targetMtime < $xmlMtime){
      last;
    }
    $closestXmlFile = $xmlFile;
  }

  return $closestXmlFile;
}

sub readFile($){
  my ($file) = @_;
  open FH, "< $file" or die "ERROR: could not read $file\n";
  my $contents = join '', <FH>;
  close FH;
  return $contents;
}

sub listDirFiles($){
  my ($dir) = @_;
  opendir(my $dh, $dir) or die "ERROR: could not read dir $dir\n$!\n";
  my @files = readdir($dh);
  closedir($dh);
  $dir =~ s/\/?$//;
  @files = map {"$dir/$_"} @files;
  @files = grep {-f $_} @files;
  return @files;
}

sub mtime($){
  my @stat = stat $_[0];
  return $stat[9];
}

&main(@ARGV);
