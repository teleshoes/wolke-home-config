#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use AI::FANN qw(:all);

my $SCALE = {
  S    => {low=>0, high=>200},
  V    => {low=>0, high=>200},
  A    => {low=>0, high=>200},
  F    => {low=>0, high=>200},
  C    => {low=>0, high=>200},
  FEET => {low=>0, high=>20},
};

my $DESIRED_ERROR = 0.00033;
my $MAX_EPOCHS = 50000;
my $HIDDEN_NODES = 8;
my $SHUFFLE_DATA = 1;
my $ACTIVATION_FUNCTION = FANN_SIGMOID_SYMMETRIC;

my $CACHE_DIR = "$ENV{HOME}/.cache/ddr-radar-feet";
my $RADAR_CACHE = "$ENV{HOME}/.cache/ddr-radar-feet/radar-training-data";

my $SONGS_BASE_DIR = "$ENV{HOME}/.stepmania/Songs";
my $DDRNAME_SONGLIST = "$ENV{HOME}/.config/ddrname-songlist";
my $TRAINING_SIMFILES_PATTERN = "$SONGS_BASE_DIR/DDR_*/*/*.sm";

sub ensureRadarCache();
sub generateRadarCache();
sub addSimfileToRadarCache($);
sub readRadarCache();
sub readZeniusFeetFromSongList();

sub ensureNeuralNet($$);
sub createNeuralNet($$);
sub loadNeuralNet($$);
sub loadNeuralNetTrainingData($$);
sub getScaledValue($$);

sub run(@);
sub readProcLine(@);

my $EXEC = basename $0;

my $usage = "Usage:
  Creates a neural network with groove radar values as input nodes,
    and DDR \"feet\" difficulty as the output node.
  A different neuralnet is created for each game-type and difficulty-type.
  Training input data (radar) is read from simfile-radar, using simfiles that match:
    $TRAINING_SIMFILES_PATTERN
  Training output data (feet) from zenius is read from $DDRNAME_SONGLIST
  Only radar-values that have a matching feet-value (by SONG_NAME_ID, GAME, and DIFF) are used.

  $EXEC -h|--help
    show this message

  $EXEC --calculate-training-radar-data
    -remove cached radar training data
      $RADAR_CACHE
    -extract input radar training data with simfile-radar for simfiles that match this pattern:
      $TRAINING_SIMFILES_PATTERN
    -format each training input data set as:
      <GAME> | <DIFF> | S<STREAM> | V<VOLTAGE> | A<AIR> | F<FREEZE> | C<CHAOS> | <SONG_NAME_ID>
    -store the values in $RADAR_CACHE
    NOTE: this is computationally and i/o intensive, and is by far the slowest part
          currently takes about 780s without simfile-radar cached
          (about 90s with simfile-radar cached)

  $EXEC --ensure-training-radar-data
    if cache file $RADAR_CACHE exists:
      do nothing
    otherwise:
      same as: $EXEC --calculate-training-radar-data
";

my $CMD_CALCULATE_TRAINING_RADAR_DATA = "calculate-training-radar-data";
my $CMD_ENSURE_TRAINING_RADAR_DATA = "ensure-training-radar-data";
my $OK_CMDS = join "|", (
  $CMD_CALCULATE_TRAINING_RADAR_DATA,
  $CMD_ENSURE_TRAINING_RADAR_DATA,
);

sub main(@){
  my $cmd = undef;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^--($OK_CMDS)$/){
      $cmd = $1
    }else{
      die $usage;
    }
  }

  if($cmd eq $CMD_CALCULATE_TRAINING_RADAR_DATA){
    generateRadarCache();
  }elsif($cmd eq $CMD_ENSURE_TRAINING_RADAR_DATA){
    ensureRadarCache();
  }else{
    die "ERROR: unknown cmd \"$cmd\"\n";
  }
}

sub ensureRadarCache(){
  generateRadarCache() if not -f $RADAR_CACHE;
}
sub generateRadarCache(){
  run "rm", "-f", $RADAR_CACHE;
  my @simfiles = glob $TRAINING_SIMFILES_PATTERN;
  for my $simfile(@simfiles){
    addSimfileToRadarCache($simfile);
  }
}
sub addSimfileToRadarCache($){
  my ($simfile) = @_;
  my @lines = readProcLines(
    "simfile-radar",
    "--format="
      . "%-7s-GAME"
      . " | %-10s-DIFF"
      . " | S%-3d-STREAM | V%-3d-VOLTAGE | A%-3d-AIR | F%-3d-FREEZE | C%-3d-CHAOS"
      . " | %SONG_NAME_ID"
      . "%n",
    $simfile,
  );
  open FH, ">> $RADAR_CACHE" or die "ERROR: could not append to $RADAR_CACHE\n$!\n";
  print FH $_ foreach @lines;
  close FH;
}
sub readRadarCache(){
  open FH, "< $RADAR_CACHE" or die "ERROR: could not read $RADAR_CACHE\n$!\n";
  my @lines = <FH>;
  close FH;

  my $radar = {};
  for my $line(@lines){
    if($line =~ /^
                (?<game>       [a-zA-Z0-9\-]+)
       \s*\|\s* (?<diff>       \w+)
       \s*\|\s* S(?<S>         \d+)
       \s*\|\s* V(?<V>         \d+)
       \s*\|\s* A(?<A>         \d+)
       \s*\|\s* F(?<F>         \d+)
       \s*\|\s* C(?<C>         \d+)
       \s*\|\s* (?<songNameId> [a-z0-9\-]+)
    $/x){
      my $gameDiffKey = $+{game} . "-" . $+{diff};
      $$radar{$+{songNameId}} = {} if not defined $$radar{$+{songNameId}};
      $$radar{$+{songNameId}}{$gameDiffKey} = {
        GAME => $+{game},
        DIFF => $+{diff},
        S    => $+{S},
        V    => $+{V},
        A    => $+{A},
        F    => $+{F},
        C    => $+{C},
      };
    }else{
      die "ERROR: malformed line in $RADAR_CACHE\n$line";
    }
  }
  return $radar;
}

sub readZeniusFeetFromSongList(){
  open FH, "<", $DDRNAME_SONGLIST or die "ERROR: could not read $DDRNAME_SONGLIST\n$!\n";
  my @lines = <FH>;
  close FH;

  my $zeniusFeet = {};
  for my $line(@lines){
    $line =~ s/#.*//;
    next if $line =~ /^\s*$/;
    if($line =~ /^
                (?<songNameId>           [a-z0-9\-]+)
       \s*\|\s* (?<abbrev>               \w+)
       \s*\|\s* (?<feetSinglesBeginner>  \d+|-+)
       \s*\|\s* (?<feetSinglesBasic>     \d+|-+)
       \s*\|\s* (?<feetSinglesDifficult> \d+|-+)
       \s*\|\s* (?<feetSinglesExpert>    \d+|-+)
       \s*\|\s* (?<feetSinglesChallenge> \d+|-+)
       \s*\|\s* \s*
       \s*\|\s* (?<feetDoublesBasic>     \d+|-+)
       \s*\|\s* (?<feetDoublesDifficult> \d+|-+)
       \s*\|\s* (?<feetDoublesExpert>    \d+|-+)
       \s*\|\s* (?<feetDoublesChallenge> \d+|-+)
       \s*\|\s*
    $/x){
      $$zeniusFeet{$+{songNameId}} = {
        "singles-beginner"   =>  $+{feetSinglesBeginner},
        "singles-basic"      =>  $+{feetSinglesBasic},
        "singles-difficult"  =>  $+{feetSinglesDifficult},
        "singles-expert"     =>  $+{feetSinglesExpert},
        "singles-challenge"  =>  $+{feetSinglesChallenge},
        "doubles-basic"      =>  $+{feetDoublesBasic},
        "doubles-difficult"  =>  $+{feetDoublesDifficult},
        "doubles-expert"     =>  $+{feetDoublesExpert},
        "doubles-challenge"  =>  $+{feetDoublesChallenge},
      };
    }else{
      die "ERROR: malformed line in $DDRNAME_SONGLIST\n$line";
    }
  }
  return $zeniusFeet;
}

sub ensureNeuralNet($$){
  my ($game, $diff) = @_;
  my $neuralNetCacheFile = "$CACHE_DIR/neuralnet-$game-$diff.ann";
  if(not -f $neuralNetCacheFile){
    createNeuralNet($game, $diff);
  }
}

sub createNeuralNet($$){
  my ($game, $diff) = @_;
  my $neuralNetCacheFile = "$CACHE_DIR/neuralnet-$game-$diff.ann";
  run "rm", "-f", $neuralNetCacheFile;
  my $ann = AI::FANN->new_standard(5, $HIDDEN_NODES, 1);

  $ann->hidden_activation_function($ACTIVATION_FUNCTION);
  $ann->output_activation_function($ACTIVATION_FUNCTION);

  my $data = loadNeuralNetTrainingData($game, $diff);

  my $trainData = AI::FANN::TrainData->new(@$data);
  $trainData->shuffle() if $SHUFFLE_DATA;

  $ann->train_on_data($trainData, $MAX_EPOCHS, 1000, $DESIRED_ERROR);

  $ann->save($neuralNetCacheFile);
}

sub loadNeuralNet($$){
  my ($game, $diff) = @_;
  my $neuralNetCacheFile = "$CACHE_DIR/neuralnet-$game-$diff.ann";
  ensureNeuralNet($game, $diff);
  return AI::FANN->new_from_file($neuralNetCacheFile);
}

sub loadNeuralNetTrainingData($$){
  my ($game, $diff) = @_;
  my $data = [];

  ensureRadarCache();
  my $radar = readRadarCache();
  my $zeniusFeet = readZeniusFeetFromSongList();

  for my $songNameId(sort keys %$radar){
    for my $gameDiffKey(sort keys %{$$radar{$songNameId}}){
      my $r = $$radar{$songNameId}{$gameDiffKey};
      next if not defined $$zeniusFeet{$songNameId};
      next if not defined $$zeniusFeet{$songNameId}{$gameDiffKey};

      next if $$r{GAME} !~ /^$game$/i;
      next if $$r{DIFF} !~ /^$diff$/i;

      my $feet = $$zeniusFeet{$songNameId}{$gameDiffKey};
      next if $feet !~ /^\d+$/;

      my $input = [
        getScaledValue($$r{S}, $$SCALE{S}),
        getScaledValue($$r{V}, $$SCALE{V}),
        getScaledValue($$r{A}, $$SCALE{A}),
        getScaledValue($$r{F}, $$SCALE{F}),
        getScaledValue($$r{C}, $$SCALE{C}),
      ];
      my $output = [
        getScaledValue($feet,      $$SCALE{FEET}),
      ];
      push @$data, $input;
      push @$data, $output;
    }
  }

  if(@$data == 0){
    die "ERROR: no data found for $game-$diff\n";
  }
  return $data;
}

sub getScaledValue($$){
  my ($val, $valScale) = @_;
  my $low = $$valScale{low};
  my $high = $$valScale{high};

  return ($val-$low) / ($high - $low);
}

sub run(@){
  print "@_\n";
  system @_;
  if($? != 0){
    die "error running \"@_\"\n";
  }
}

sub readProcLines(@){
  my @cmd = @_;
  open CMD, "-|", @cmd or die "ERROR: \"@cmd\" failed\n$!\n";
  my @lines = <CMD>;
  close CMD;
  return @lines;
}

&main(@ARGV);
