#!/usr/bin/perl
use strict;
use warnings;

my $defaultFadeLen = "2.00";

my $usage = "Usage:
  take a bunch of videos and concatenate them with ffmpeg,
    overlapping them by ${defaultFadeLen}s with a fade transition
  input videos must all have the exact same codecs,
    filetypes, and bitrates (and maybe other things)

  $0 -h|--help
    show this message

  $0 [OPTS] INPUT_VID [INPUT_VID INPUT_VID ..]
    -generate video-only crossfade of ${defaultFadeLen}s between each input
       <OUTPUT_VIDEO>-tmp-video.<EXT>
    -genearte audio-only crossfade of ${defaultFadeLen}-0.2s (???) between each input
       <OUTPUT_VIDEO>-tmp-audio.<EXT>
    -combine the files with -c copy

  OPTS
    -o OUTPUT_VIDEO
    --output OUTPUT_VIDEO
    --output=OUTPUT_VIDEO
      default is out.<EXT>
    --fade-len=DURATION_SECONDS
      make the duration of the crossfade DURATION_SECONDS (default is 2.00)
    --resolution=WIDTHxHEIGHT
      add scale=WIDTHxHEIGHT to filter_complex chain
";

sub crossfadeVideo($$@);
sub dur($);
sub shellEscape($);

sub main(@){
  my @inputVideos;
  my $outputVideo;
  my $opts = {
    fadeLen         => $defaultFadeLen,
    forceResolution => undef,
  };
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^--output=(.+)$/){
      $outputVideo = $1;
    }elsif($arg =~ /^(-o|--output)$/ and @_ > 0){
      $outputVideo = shift;
    }elsif($arg =~ /^--fade-len=(\d+|\d*\.\d+)$/){
      $$opts{fadeLen} = $1;
    }elsif($arg =~ /^--resolution=(\d+x\d+)$/){
      $$opts{forceResolution} = $1;
    }else{
      push @inputVideos, $arg;
    }
  }
  die "ERROR: output video $outputVideo exists\n" if defined $outputVideo and -e $outputVideo;
  for my $inputVideo(@inputVideos){
    die "ERROR: input video $inputVideo is not a file\n" if not -f $inputVideo;
  }

  my $ext = ".mp4";
  $ext = $1 if $inputVideos[0] =~ /\.([a-z0-9]+)$/;

  $outputVideo = "out.$ext" if not defined $outputVideo;

  crossfadeVideo($opts, $outputVideo, @inputVideos);
}

sub crossfadeVideo($$@){
  my ($opts, $output, @inputs) = @_;

  my $fadeLen = $$opts{fadeLen};

  my @durs = map {dur $_} @inputs;

  my @filters;

  #apply xfade to each subsequent video overlay
  my $idVidPrev = undef;
  my $nextFadeOffset = 0;
  for(my $i=0; $i<@inputs; $i++){
    my $idVidCur = "$i:v";

    if(defined $$opts{forceResolution}){
      my $idVidScale = "scaleVid$i";
      push @filters, ''
        . "[$idVidCur]"
        . "scale=$$opts{forceResolution}"
        . "[$idVidScale]"
        ;
      $idVidCur = $idVidScale;
    }

    if(defined $idVidPrev){
      #smoosh the previous smooshed inputs into this input
      my $idVidFade = "fadeVid$i";
      push @filters, ""
        . "[$idVidPrev][$idVidCur]"
        . "xfade=transition=fade:duration=$fadeLen:offset=$nextFadeOffset"
        . "[$idVidFade]"
        ;
      $idVidCur = $idVidFade;
    }

    $idVidPrev = $idVidCur;
    $nextFadeOffset += $durs[$i] - $fadeLen;
  }
  my $idVidFinal = $idVidPrev;



  #apply acrossfade to each subsequent audio overlay
  my $idAudPrev = undef;
  for(my $i=0; $i<@inputs; $i++){
    my $idAudCur = "$i:a";

    if(defined $idAudPrev){
      #smoosh the previous smooshed inputs into this input
      my $idAudFade = "fadeAud$i";
      push @filters, ""
        . "[$idAudPrev][$idAudCur]"
        . "acrossfade=d=$fadeLen"
        . "[$idAudFade]"
        ;
      $idAudCur = $idAudFade;
    }

    $idAudPrev = $idAudCur;
  }
  my $idAudFinal = $idAudPrev;



  my @cmd = ();
  @cmd = (@cmd, "ffmpeg");
  @cmd = (@cmd, map {("-i", $_)} @inputs);
  @cmd = (@cmd, "-filter_complex", join(";", @filters));
  @cmd = (@cmd, "-map", "[$idVidFinal]");
  @cmd = (@cmd, "-map", "[$idAudFinal]");
  @cmd = (@cmd, $output);

  my $msg = ""
    . "\n\n\n"
    . "===== COMMAND (shell-escaped):\n"
    . (join " ", map {shellEscape($_)} @cmd) . "\n"
    . "===== FILTERS (one per line):\n"
    . (join "", map {"$_\n"} @filters)
    . "=====\n"
    . "\n\n\n"
  ;

  print $msg;
  system @cmd;
  print $msg;
}

sub dur($){
  my ($file) = @_;
  my @durCmd = ("duration", "-n", "-s", $file);
  open CMD, "-|", @durCmd or die "could not run @durCmd\n$!\n";
  my $duration = join '', <CMD>;
  close CMD;
  chomp $duration;
  if($duration !~ /^(\d+|\d*\.\d+)$/){
    die "invalid duration for $file: $duration\n";
  }
  return $duration;
}

sub shellEscape($){
  my $s = shift;
  my $allowedChars = join '', qw(
    a-z   A-Z   0-9
    :    =   @   _   %
    \+   \-   \.   \/
    ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ
  );
  my $specialChars = "[^$allowedChars]";

  if($s =~ /$specialChars/){
    $s =~ s/'/'\\''/g;
    $s = "'$s'";
  }
  return $s;
}

&main(@ARGV);
