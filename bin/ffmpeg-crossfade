#!/usr/bin/perl
use strict;
use warnings;

use File::Basename qw(basename);
use List::Util qw(sum);

my $EXEC = basename $0;

my $DEFAULT_FADE_LEN = "2.00";

my $USAGE = "Usage:
  take a bunch of videos and concatenate them with ffmpeg,
    overlapping them by ${DEFAULT_FADE_LEN}s with a fade transition
  input videos must all have the exact same codecs,
    filetypes, and bitrates (and maybe other things)

  $EXEC -h|--help
    show this message

  $EXEC [OPTS] INPUT_VID INPUT_VID [INPUT_VID ..]
    -generate video-only crossfade of ${DEFAULT_FADE_LEN}s between each input
       <OUTPUT_VIDEO>-tmp-video.<EXT>
    -genearte audio-only crossfade of ${DEFAULT_FADE_LEN}-0.2s (???) between each input
       <OUTPUT_VIDEO>-tmp-audio.<EXT>
    -combine the files with -c copy

  OPTS
    -o OUTPUT_VIDEO | --output OUTPUT_VIDEO | --output=OUTPUT_VIDEO
      default is out.<EXT>

    --len DURATION_SECONDS | --fade-len DURATION_SECONDS
    --len=DURATION_SECONDS | --fade-len=DURATION_SECONDS
      make the duration of the crossfade DURATION_SECONDS (default is 2.00)

    --resolution WIDTHxHEIGHT | --res WIDTHxHEIGHT | --scale WIDTHxHEIGHT
    --resolution=WIDTHxHEIGHT | --res=WIDTHxHEIGHT | --scale=WIDTHxHEIGHT
      add scale=WIDTHxHEIGHT to filter_complex chain

    -an | --an | --no-audio | --audio-null
      remove audio channel (do not map any audio)
";

sub crossfadeVideo($$@);
sub dur($);
sub shellEscape($);

sub main(@){
  my @inputVideos;
  my $outputVideo;
  my $opts = {
    fadeLen         => $DEFAULT_FADE_LEN,
    forceResolution => undef,
    audioNull       => 0,
  };
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^--output=(.+)$/){
      $outputVideo = $1;
    }elsif($arg =~ /^(-o|--output)$/ and @_ > 0){
      $outputVideo = shift;
    }elsif($arg =~ /^(--len|--fade-len)=(\d+|\d*\.\d+)$/){
      $$opts{fadeLen} = $2;
    }elsif($arg =~ /^(--len|--fade-len)$/ and @_ > 0 and $_[0] =~ /^(\d+|\d*\.\d+)$/){
      $$opts{fadeLen} = shift;
    }elsif($arg =~ /^(--resolution|--res|--scale)=(\d+x\d+)$/){
      $$opts{forceResolution} = $2;
    }elsif($arg =~ /^(--resolution|--res|--scale)$/ and @_ > 0 and $_[0] =~ /^(\d+x\d+)$/){
      $$opts{forceResolution} = shift;
    }elsif($arg =~ /^(-an|--an|--no-audio|--audio-null)$/){
      $$opts{audioNull} = 1;
    }else{
      push @inputVideos, $arg;
    }
  }
  die "$USAGE\nERROR: must specify at least two INPUT_VID_FILEs\n" if @inputVideos < 2;

  my $ext = ".mp4";
  $ext = $1 if $inputVideos[0] =~ /\.([a-z0-9]+)$/;

  $outputVideo = "out.$ext" if not defined $outputVideo;

  die "ERROR: output video $outputVideo exists\n" if defined $outputVideo and -e $outputVideo;
  for my $inputVideo(@inputVideos){
    die "ERROR: input video $inputVideo is not a file\n" if not -f $inputVideo;
  }

  crossfadeVideo($opts, $outputVideo, @inputVideos);
}

sub crossfadeVideo($$@){
  my ($opts, $output, @inputs) = @_;

  my $fadeLen = $$opts{fadeLen};

  my @durs = map {dur $_} @inputs;

  my @filters;

  #apply xfade to each subsequent video overlay
  my $idVidPrev = undef;
  for(my $i=0; $i<@inputs; $i++){
    my $idVidCur = "$i:v";

    if(defined $$opts{forceResolution}){
      my $idVidScale = "scaleVid$i";
      push @filters, ''
        . "[$idVidCur]"
        . "scale=$$opts{forceResolution}"
        . "[$idVidScale]"
        ;
      $idVidCur = $idVidScale;
    }

    if(defined $idVidPrev){
      #smoosh the previous smooshed inputs into this input
      my $idVidFade = "fadeVid$i";

      my $previousTotalDuration = $i == 0 ? 0 : sum(@durs[0..$i-1]);
      my $previousCount = $i;
      my $fadeOffset = $previousTotalDuration - ($fadeLen * $previousCount);

      push @filters, ""
        . "[$idVidPrev][$idVidCur]"
        . "xfade=transition=fade:duration=$fadeLen:offset=$fadeOffset"
        . "[$idVidFade]"
        ;
      $idVidCur = $idVidFade;
    }

    $idVidPrev = $idVidCur;
  }
  my $idVidFinal = $idVidPrev;



  #apply acrossfade to each subsequent audio overlay
  my $idAudPrev = undef;
  for(my $i=0; $i<@inputs; $i++){
    next if $$opts{audioNull};
    my $idAudCur = "$i:a";

    if(defined $idAudPrev){
      #smoosh the previous smooshed inputs into this input
      my $idAudFade = "fadeAud$i";
      push @filters, ""
        . "[$idAudPrev][$idAudCur]"
        . "acrossfade=d=$fadeLen"
        . "[$idAudFade]"
        ;
      $idAudCur = $idAudFade;
    }

    $idAudPrev = $idAudCur;
  }
  my $idAudFinal = $idAudPrev;



  my @cmd = ();
  @cmd = (@cmd, "ffmpeg");
  @cmd = (@cmd, map {("-i", $_)} @inputs);
  @cmd = (@cmd, "-filter_complex", join(";", @filters));
  @cmd = (@cmd, "-map", "[$idVidFinal]");
  @cmd = (@cmd, "-map", "[$idAudFinal]") unless $$opts{audioNull};
  @cmd = (@cmd, $output);

  my $msg = ""
    . "\n\n\n"
    . "===== COMMAND (shell-escaped):\n"
    . (join " ", map {shellEscape($_)} @cmd) . "\n"
    . "===== FILTERS (one per line):\n"
    . (join "", map {"$_\n"} @filters)
    . "=====\n"
    . "\n\n\n"
  ;

  print $msg;
  system @cmd;
  print $msg;
}

sub dur($){
  my ($file) = @_;
  my @durCmd = ("duration", "-n", "-s", $file);
  open CMD, "-|", @durCmd or die "could not run @durCmd\n$!\n";
  my $duration = join '', <CMD>;
  close CMD;
  chomp $duration;
  if($duration !~ /^(\d+|\d*\.\d+)$/){
    die "invalid duration for $file: $duration\n";
  }
  return $duration;
}

sub shellEscape($){
  my $s = shift;
  my $allowedChars = join '', qw(
    a-z   A-Z   0-9
    :    =   @   _   %
    \+   \-   \.   \/
    ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ
  );
  my $specialChars = "[^$allowedChars]";

  if($s =~ /$specialChars/){
    $s =~ s/'/'\\''/g;
    $s = "'$s'";
  }
  return $s;
}

&main(@ARGV);
