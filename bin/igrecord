#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);

my $igclientExec = "/usr/bin/igclient";
my $delayMillis = 2000;

sub igclientRecord();
sub parseEntries(@);
sub squashEntries(@);
sub trimEntries(@);
sub formatEntries(@);
sub run(@);

my $usage = "Usage:
  $0 -h|--help
    show this message

  $0 [OPTIONS] IR_CODE_FILE
    run igclient, turn receiver on, sleep for $delayMillis
    record IR pulses and spaces received to a temp file
    combine adjacent pulses or spaces, and remove leading/trailed space
    write resulsting list of pulses and spaces to IR_CODE_FILE

  OPTIONS:
    -d | --delete
      remove IR_CODE_FILE before attempting to record

    -e | --echo | -r | --repeat
      run 'igclient --send=IR_CODE_FILE' after recording
";

sub main(@){
  my $delete = 0;
  my $echo = 0;
  while(@_ > 0 and $_[0] =~ /^-/){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $usage;
      exit 0;
    }elsif($arg =~ /^(-d|--delete)$/){
      $delete = 1;
    }elsif($arg =~ /^(-e|--echo|-r|--repeat)$/){
      $echo = 1;
    }else{
      die $usage;
    }
  }

  my $file = shift;
  die $usage if @_ > 0 or not defined $file;

  run "rm", "-f", $file if defined $delete and -f $file;

  die "file \"$file\" already exists\n" if -f $file;

  my @lines = igclientRecord();

  my @entries = parseEntries @lines;
  @entries = squashEntries @entries;
  @entries = trimEntries @entries;

  if(@entries == 0){
    print "no pulse/space entries recorded\n";
    exit 0;
  }

  my $format = formatEntries @entries;

  print "\n\nwriting to $file:\n$format";

  open FH, "> $file" or die "Could not write $file\n";
  print FH $format;
  close FH;

  if($echo){
    print "\n";
    run $igclientExec, "--send=$file";
  }
}

sub igclientRecord(){
  my $nowMillis = int(time() * 1000);
  my $tmpFile = "/tmp/igclient-record-$nowMillis.txt";

  my $sleepFmt = sprintf "%.3f", $delayMillis/1000;

  run "$igclientExec --receiver-on --sleep $sleepFmt | tee $tmpFile";

  open FH, "< $tmpFile" or die "Could not read $tmpFile\n";
  my @lines = <FH>;
  close FH;

  run "rm", $tmpFile;

  return @lines;
}

sub parseEntries(@){
  my @lines = @_;

  my @entries;
  for my $line(@lines){
    if($line =~ /^(receiver on|received \d+ signal\(s\))/){
      next;
    }elsif($line =~ /^\s*(pulse|space)\s*:\s*(\d+)\s*$/){
      my ($type, $value) = ($1, $2);
      push @entries, {type=>$type, value=>$value};
    }else{
      die "malformed igclient output line: $line";
    }
  }

  return @entries;
}

sub squashEntries(@){
  my @entries = @_;

  my @newEntries;
  my $prevEntry = undef;
  for my $entry(@entries){
    if(defined $prevEntry and $$prevEntry{type} eq $$entry{type}){
      $$prevEntry{value} += $$entry{value};
    }else{
      push @newEntries, $entry;
      $prevEntry = $entry;
    }
  }

  return @newEntries;
}

sub trimEntries(@){
  my @entries = @_;

  while(@entries > 0 and ${$entries[0]}{type} eq "space"){
    shift @entries;
  }
  while(@entries > 0 and ${$entries[-1]}{type} eq "space"){
    pop @entries;
  }

  return @entries;
}

sub formatEntries(@){
  my @entries = @_;
  my $fmt = "";
  for my $entry(@entries){
    $fmt .= "$$entry{type} $$entry{value}\n";
  }
  return $fmt;
}

sub run(@){
  print "@_\n";
  system @_;
  die "Error running \"@_\"\n" if $? != 0;
}

&main(@ARGV);
