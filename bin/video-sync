#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(time);
use Digest::MD5 qw();
my $USE_LIB_TEXT_CSV = eval {require Text::CSV};

sub syncRemote($);
sub parseCsvRow($);
sub readIncludeFile();
sub buildLocalSyncDir($$$);
sub findAllFiles();
sub readStatCache();
sub readMd5sumCache();
sub readDurationCache();
sub handleUpdateCache($$@);
sub gitCommitFile($$$);
sub isGitFileUnstaged($$);
sub getSizeMtime($$);
sub getDuration($);
sub formatDurationHMS($);
sub md5sumFile($);
sub readFile($);
sub run(@);
sub runQuiet(@);
sub readProc(@);
sub nowMillis();

my $BASE_DIR = "/media/videos";
my $INFO_DIR = "$BASE_DIR/zzz_info";

my $FILE_INCLUDE_SYNC = "$INFO_DIR/include-sync";
my $FILE_REMOTE_MIRROR_IPMAGIC_NAME = "$BASE_DIR/videos_mirror_ipmagic_name";
my $TMP_SYNC_SYMLINKS_DIR_PREFIX = "/tmp/video-sync-tmp-symlinks-dir";

my $FILE_CACHE_STAT = "$INFO_DIR/cache-stat";
my $FILE_CACHE_MD5SUM = "$INFO_DIR/cache-md5sum";
my $FILE_CACHE_DURATION = "$INFO_DIR/cache-duration";

my $TMP_PREFIX_CACHE_STAT = "/tmp/video-sync-cache-stat";
my $TMP_PREFIX_CACHE_MD5SUM = "/tmp/video-sync-cache-md5sum";
my $TMP_PREFIX_CACHE_DURATION = "/tmp/video-sync-cache-duration";

my $DURATION_EXEC = "duration";

my @DEFAULT_SYNC_EXCLUDE_ARGS = qw(extras/ highres/);

my @SYNC_CATEGORIES = qw(
  anime
  clips_shorts_trailers
  concerts
  courses
  movies
  operas
  series
  specials
);
my @NONSYNC_CATEGORIES = qw(
  camera
  events
);
my @ALL_CATEGORIES = sort(@SYNC_CATEGORIES, @NONSYNC_CATEGORIES);
my $OK_CATS = join "|", @ALL_CATEGORIES;

my @DURATION_EXTS = qw(
  mkv avi mp4 mpg webm
  3gp flv divx mov m4v smv wmv
  iso m2ts vob
  flac m4a m4b mp3 ogg opus wav
);
my $DURATION_EXT_REGEX = join "|", @DURATION_EXTS;

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h|--help
    show this message

  $EXEC [OPTS] --sync
  $EXEC [OPTS] --sync-remote
    -read IPMAGIC_NAME from $FILE_REMOTE_MIRROR_IPMAGIC_NAME
      -if none exists, fail
    -use SYNC_NAME=sync-<IPMAGIC_NAME>-<NOW_MILLIS>
    -use TMP_SYMLINKS_DIR=$TMP_SYNC_SYMLINKS_DIR_PREFIX-<SYNC_NAME>
    -build IPMAGIC_NAME:TMP_SYNC_DIR remotely
      -run: ipmagic IPMAGIC_NAME -s $EXEC --quiet --build-sync-dir SYNC_NAME_ARG
    -get list of CATEGORY entries to sync
      -default is: @SYNC_CATEGORIES
      -see: --sync-category
    -rsync each CATEGORY from remote TMP_SYMLINKS_DIR to $BASE_DIR
      -follow remote symlinks with '-L', copying actual files, not links
      -run: ipmagic IPMAGIC_NAME --rsync -L -avP \\
              :TMP_SYMLINKS_DIR/CATEGORY/ \\
              $BASE_DIR/CATEGORY/ \\
              EXCLUDE_ARGS \\
              MAYBE_DELETE_ARG \\
              MAYBE_SIMULATE_ARG \\
            ;
    EXCLUDE_ARGS
      default is: " . join(" ", map{"--exclude $_"} @DEFAULT_SYNC_EXCLUDE_ARGS) . "
      see: --sync-excludes
    MAYBE_DELETE_ARG
      '--del' if --sync-del is given, otherwise empty
      does not override --simulate (nothing will be deleted with --simulate)
    MAYBE_SIMULATE_ARG
      if --simulate is given '--dry-run', otherwise ''
      (append '--dry-run' to rsync commands on --simulate)

  $EXEC [OPTS] --sync-simulate
    same as: $EXEC --sync-remote --simulate

  $EXEC [OPTS] --build-sync-dir SYNC_NAME
  $EXEC [OPTS] --build-local-sync-dir SYNC_NAME
    -use TMP_SYMLINKS_DIR=$TMP_SYNC_SYMLINKS_DIR_PREFIX-<SYNC_NAME>
    -delete TMP_SYMLINKS_DIR if it exists
      -run: rm -rf TMP_SYMLINKS_DIR
    -read list of <CATEGORY>/<MEDIA_NAME> pairs, one per line, from:
      $FILE_INCLUDE_SYNC
    -for each <CATEGORY>/<MEDIA_NAME> pair in $FILE_INCLUDE_SYNC:
      -create symlink for each <MEDIA_NAME> in category subdir of sync dir:
        -run: mkdir -p TMP_SYNC_DIR/CATEGORY/
        -run: ln -s $BASE_DIR/CATEGORY/MEDIA_NAME/ TMP_SYNC_DIR/CATEGORY/MEDIA_NAME

    SYNC_NAME
      must start with 'sync' and contain only:
        lowercase letters, numbers, underscores, and dashes

  $EXEC [OPTS] --cache
    same as: $EXEC --cache-stat && $EXEC --cache-md5sum && $EXEC --cache-duration

  $EXEC [OPTS] --cache-stat
    cache mtime and filesize for all regular files
    as in: find -L $BASE_DIR/!(<CATEGORY>|<CATEGORY>..) \\
             -type f -exec stat -c %Y:%s:%n {} \\;
    -get ALL_FILES as in: $EXEC --list-files
    -for each FILE in ALL_FILES, get MTIME_EPOCH and FILESIZE_BYTES with stat()
    -write stat entries to $FILE_CACHE_STAT
      -format as: \"<MTIME_EPOCH> , <FILESIZE_BYTES>b , <FILE>\"
      -if --simulate is given, write only to $TMP_PREFIX_CACHE_STAT-<NOW_MILLIS>
    -git commit $FILE_CACHE_STAT unless --simulate or --no-git is given

  $EXEC [OPTS] --cache-md5sum
    calculate and cache MD5SUM for all regular files
    as in: find -L $BASE_DIR/!(<CATEGORY>|<CATEGORY>..) \\
             -type f -exec md5sum {} \\;
    -get ALL_FILES as in: $EXEC --list-files
    -read (CACHE_MD5SUM, CACHE_FILE) entries from $FILE_CACHE_MD5SUM
    -for each FILE in ALL_FILES, get MTIME_EPOCH and FILESIZE_BYTES with stat()
    -for each FILE in ALL_FILES, get MD5SUM
      -use CACHE_MD5SUM if FILE matches CACHE_FILE
      -otherwise, calculate with `md5sum <FILE>`
    -write md5sum entries to $FILE_CACHE_MD5SUM
      -format as: \"<MD5SUM> , <FILE>\", one per line
      -if --simulate is given, write only to $TMP_PREFIX_CACHE_MD5SUM-<NOW_MILLIS>
    -git commit $FILE_CACHE_MD5SUM unless --simulate or --no-git is given

  $EXEC [OPTS] --cache-duration
    calculate and cache MD5SUM for all regular files
    as in: find -L $BASE_DIR/!(<CATEGORY>|<CATEGORY>..) \\
             -type f -exec md5sum {} \\;
    -get ALL_FILES as in: $EXEC --list-files
    -read (CACHE_DURATION_FRAC_S, CACHE_FILE) entries from $FILE_CACHE_DURATION
    -for each FILE in ALL_FILES, get DURATION_FRAC_S
      -use CACHE_DURATION if FILE matches CACHE_FILE
      -use '-' if FILE does not end in one of the following extensions:
        @DURATION_EXTS
      -otherwise, calculate with `duration <FILE>`
        -use '-' if duration is unknown
    -convert DURATION_FRAC_S to DURATION_FMT as 'HH:MM:SS' (or '-')
    -write duration entries to $FILE_CACHE_DURATION
      -convert DURATION to DURATION_HMS as 'HH:MM:SS'
      -convert DURATION to DURATION_FRAC_S as 'S.FFFFFF'
      -format as: \"<DURATION_HMS> , <DURATION_FRAC_S> , <FILE>\", one per line
      -if --simulate is given, write only to $TMP_PREFIX_CACHE_DURATION-<NOW_MILLIS>
    -git commit $FILE_CACHE_DURATION unless --simulate or --no-git is given

  $EXEC [OPTS] --list-files
    list all regular files in all categories, following symlinks
      as in: find -L $BASE_DIR/!(<CATEGORY>|<CATEGORY>..) \\
               -type f
    -get ALL_FILES:
      -for each CATEGORY:
        -find every file in $BASE_DIR/<CATEGORY>
        -follow and dereference symlinks
        -omit non-regular files like directories and broken symlinks
    -print each file in ALL_FILES, one per line

  CATEGORY
    one of: $OK_CATS

  OPTS
    -q | --quiet
      do no print each symlink command in --build-local-sync-dir

    -s | --simulate | -n | --no-act | --dry-run | --dryrun
      do not update media files or info cache files, locally or remotely
      implies --no-git
        -run rsync commands with --dry-run in --sync-remote
        -do not write cache files in $INFO_DIR
          -instead, skip deleting the tmp files in /tmp
        -do not run git add && git commit

    --no-git | --skip-git
      do not automatically git commit info cache files in --info

    -c CATEGORY_CSV
    --sync-categories=CATEGORY_CSV
      in sync-remote, only sync the indicated CATEGORY entries
        -parse CATEGORY_CSV into CATEGORY entries
        -skip any CATEGORY not given in --sync-remote
      CATEGORY_CSV
        comma-separated list of CATEGORY entries
          separator=','    quote_char='\"'    escape_char='\\'    quote_literal='\"\"'
          e.g.: -c movies,series,operas
        NOTE: simple csv parsing without quotes/escapes is used if Text::CSV is not found
        the default is:
          " . join(",", @SYNC_CATEGORIES) . "

    -x EXCLUDE_CSV
    --sync-excludes=EXCLUDE_CSV
      in sync-remote, override the default rsync EXCLUDE args
        -parse EXCLUDE_CSV into EXCLUDE args
        -pass '--exclude EXCLUDE' to each rsync command in --sync-remote
      EXCLUDE_CSV
        comma-separated list of EXCLUDE args
          separator=','    quote_char='\"'    escape_char='\\'    quote_literal='\"\"'
          e.g.: -x 'bigFiles1/,\"really,reallyBigFiles2/\",\"a\"\"good\"\"dirName3/'
        NOTE: simple csv parsing without quotes/escapes is used if Text::CSV is not found
        the default is:
          " . join(",", @DEFAULT_SYNC_EXCLUDE_ARGS) . "

    --del | --delete | --sync-del | --sync-delete
      pass '--del' to rsync commands in --sync-remote
";

my $CMD_SYNC_REMOTE = "sync-remote";
my $CMD_BUILD_LOCAL_SYNC_DIR = "build-local-sync-dir";
my $CMD_CACHE = "cache";
my $CMD_LIST_FILES = "list-files";

my $CACHE_TYPE_STAT = "stat";
my $CACHE_TYPE_MD5SUM = "md5sum";
my $CACHE_TYPE_DURATION = "duration";

sub main(@){
  my $cmd = $CMD_SYNC_REMOTE;
  my $syncName = undef;
  my @cacheTypes;
  my $opts = {
    quiet           => 0,
    simulate        => 0,
    skipGit         => 0,
    syncCategories  => [@SYNC_CATEGORIES],
    syncExcludeArgs => [@DEFAULT_SYNC_EXCLUDE_ARGS],
    syncDelete      => 0,
  };

  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--sync|--sync-remote)$/){
      $cmd = $CMD_SYNC_REMOTE;
    }elsif($arg =~ /^(--sync-simulate)$/){
      $cmd = $CMD_SYNC_REMOTE;
      $$opts{simulate} = 1;
    }elsif($arg =~ /^(--build-sync-dir|--build-local-sync-dir)$/){
      $cmd = $CMD_BUILD_LOCAL_SYNC_DIR;
    }elsif($arg =~ /^(--cache)$/){
      $cmd = $CMD_CACHE;
      @cacheTypes = ($CACHE_TYPE_STAT, $CACHE_TYPE_MD5SUM, $CACHE_TYPE_DURATION);
    }elsif($arg =~ /^(--cache-stat)$/){
      $cmd = $CMD_CACHE;
      @cacheTypes = ($CACHE_TYPE_STAT);
    }elsif($arg =~ /^(--cache-md5sum)$/){
      $cmd = $CMD_CACHE;
      @cacheTypes = ($CACHE_TYPE_MD5SUM);
    }elsif($arg =~ /^(--cache-duration)$/){
      $cmd = $CMD_CACHE;
      @cacheTypes = ($CACHE_TYPE_DURATION);
    }elsif($arg =~ /^(--list-files)$/){
      $cmd = $CMD_LIST_FILES;
    }elsif($arg =~ /^(-q|--quiet)$/){
      $$opts{quiet} = 1;
    }elsif($arg =~ /^(-s|--simulate|-n|--no-act|--dry-run|--dryrun)$/){
      $$opts{simulate} = 1;
      $$opts{skipGit} = 1;
    }elsif($arg =~ /^(--no-git|--skip-git)$/){
      $$opts{skipGit} = 1;
    }elsif($arg =~ /^(-c)$/ and @_ > 0){
      my $csv = shift @_;
      $$opts{syncCategories} = [parseCsvRow($csv)],
    }elsif($arg =~ /^--sync-categories=(.+)$/){
      my $csv = $1;
      $$opts{syncCategories} = [parseCsvRow($csv)],
    }elsif($arg =~ /^(-x)$/ and @_ > 0){
      my $csv = shift @_;
      $$opts{syncExcludeArgs} = [parseCsvRow($csv)],
    }elsif($arg =~ /^--sync-excludes=(.+)$/){
      my $csv = $1;
      $$opts{syncExcludeArgs} = [parseCsvRow($csv)],
    }elsif($arg =~ /^(--del|--delete|--sync-del|--sync-delete)$/){
      $$opts{syncDelete} = 1;
    }elsif($cmd eq $CMD_BUILD_LOCAL_SYNC_DIR
             and not defined $syncName and $arg =~ /^(sync[a-z0-9_\-]*)$/){
      $syncName = $arg
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($cmd eq $CMD_SYNC_REMOTE){
    syncRemote($opts);
  }elsif($cmd eq $CMD_BUILD_LOCAL_SYNC_DIR){
    die "ERROR: missing SYNC_NAME\n" if not defined $syncName;
    my $mediaNamesByCategory = readIncludeFile();
    buildLocalSyncDir($opts, $syncName, $mediaNamesByCategory);
  }elsif($cmd eq $CMD_CACHE){
    print "getting file information with find\n";
    my @allFiles = findAllFiles();
    @allFiles = sort @allFiles;

    for my $cacheType(@cacheTypes){
      handleUpdateCache($opts, $cacheType, @allFiles);
    }
  }elsif($cmd eq $CMD_LIST_FILES){
    my @allFiles = findAllFiles();
    @allFiles = sort @allFiles;
    print "$_\n" foreach @allFiles;
  }else{
    die "ERROR: unknown command $cmd\n";
  }
}

sub syncRemote($){
  my ($opts) = @_;
  my $ipmagicName = readFile $FILE_REMOTE_MIRROR_IPMAGIC_NAME;
  chomp $ipmagicName;
  if($ipmagicName !~ /^(\w+)$/){
    die "ERROR: invalid/missing IPMAGIC_NAME\n";
  }

  my $syncName = "sync-$ipmagicName-" . nowMillis();

  my $tmpSymlinksDir = "$TMP_SYNC_SYMLINKS_DIR_PREFIX-$syncName";

  run "ipmagic", $ipmagicName, "-s", $EXEC, "--quiet", "--build-sync-dir", $syncName;
  print "built symlinks remotely at $ipmagicName:$tmpSymlinksDir\n";

  my @maybeSimulateArg = $$opts{simulate} ? ("-n") : ();
  my @excludeArgs = map {("--exclude", $_)} @{$$opts{syncExcludeArgs}};
  my @maybeDeleteArg = $$opts{syncDelete} ? ("--del") : ();

  for my $cat(@{$$opts{syncCategories}}){
    print "\n\n$cat:\n";
    run "ipmagic", $ipmagicName, "--rsync",
      "-L",
      "-avP",
      ":$tmpSymlinksDir/$cat/",
      "$BASE_DIR/$cat/",
      @excludeArgs,
      @maybeDeleteArg,
      @maybeSimulateArg,
    ;
  }
}

sub parseCsvRow($){
  my ($csvRow) = @_;

  my @vals;
  if($USE_LIB_TEXT_CSV){
    require Text::CSV;
    Text::CSV->import;

    my $csv = Text::CSV->new({
      sep_char => ",",
    });
    $csv->parse($csvRow);

    @vals = $csv->fields();
  }else{
    @vals = split /,/, $csvRow;
  }

  return @vals;
}

sub readIncludeFile(){
  my $mediaNamesByCategory = {};
  my @lines = readFile($FILE_INCLUDE_SYNC);
  for my $line(@lines){
    chomp $line;
    next if $line =~ /^\s*$/;

    my $namePtrnRegex = '[a-zA-Z0-9_\-\*]+';
    if($line !~ /^(\w+)\/($namePtrnRegex)\s*$/){
      die "ERROR: malformed include-sync line $line\n";
    }
    my ($cat, $namePtrn) = ($1, $2);

    my @dirs = grep {-d $_} glob "/media/videos/$cat/$namePtrn/";
    if(@dirs == 0){
      die "ERROR: unknown include dir $line\n";
    }
    for my $dir(@dirs){
      if($dir !~ /^\/media\/videos\/$cat\/([a-z0-9_\-]+)\/?$/){
        die "ERROR: malformed media dir $dir\n";
      }
      my $name = $1;

      $$mediaNamesByCategory{$cat} = [] if not defined $$mediaNamesByCategory{$cat};
      push @{$$mediaNamesByCategory{$cat}}, $name;
    }
  }

  return $mediaNamesByCategory;
}

sub buildLocalSyncDir($$$){
  my ($opts, $syncName, $mediaNamesByCategory) = @_;

  my $syncDir = "$TMP_SYNC_SYMLINKS_DIR_PREFIX-$syncName";
  if(-e $syncDir){
    die "ERROR: $syncDir already exists\n";
  }

  my @cmds;
  push @cmds, ["mkdir", "-p", "$syncDir/"];
  for my $cat(sort keys %$mediaNamesByCategory){
    my @names = @{$$mediaNamesByCategory{$cat}};
    push @cmds, ["mkdir", "-p", "$syncDir/$cat"];
    for my $name(@names){
      push @cmds, ["ln", "-s",          "/media/videos/$cat/$name/", "$syncDir/$cat/$name"];
      push @cmds, ["touch", "-h", "-r", "/media/videos/$cat/$name/", "$syncDir/$cat/$name"];
    }
    push @cmds, ["touch", "$syncDir/$cat", "-r", "/media/videos/$cat/"];
  }

  for my $cmdArr(@cmds){
    my @cmd = @$cmdArr;
    if($$opts{simulate}){
      print "#@cmd\n";
    }else{
      if($$opts{quiet}){
        runQuiet(@cmd);
      }else{
        run @cmd;
      }
    }
  }
}

sub findAllFiles(){
  my @findCmd = ("find",
    "-L",
    $BASE_DIR,
    "-type", "f",
    "-not", "-path", "*/zzz_info/*",
  );

  my @files = readProc @findCmd;
  chomp foreach @files;

  s/^$BASE_DIR\/+// foreach @files;
  return @files;
}

sub readStatCache(){
  my $cacheStat = {};
  if(-f $FILE_CACHE_STAT){
    for my $line(readFile($FILE_CACHE_STAT)){
      if($line !~ /^\s*(\d+)\s*,\s*(\d+)b\s*,\s*(\S.*)$/){
        die "ERROR: malformed line in $FILE_CACHE_STAT\n$line";
      }
      my ($mtime, $size, $file) = ($1, $2, $3);
      if(defined $$cacheStat{$file}){
        die "ERROR: dupe file in $FILE_CACHE_STAT \"$file\"\n";
      }
      $$cacheStat{$file} = {
        mtime => $mtime,
        size  => $size,
      };
    }
  }
  return $cacheStat;
}
sub readMd5sumCache(){
  my $cacheMd5sum = {};
  if(-f $FILE_CACHE_MD5SUM){
    for my $line(readFile($FILE_CACHE_MD5SUM)){
      if($line !~ /^\s*([0-9a-f]{32})\s*,\s*(\d+)\s*,\s*(\d+)b\s*,\s*(\S.*)$/){
        die "ERROR: malformed line in $FILE_CACHE_MD5SUM\n$line";
      }
      my ($md5sum, $mtime, $size, $file) = ($1, $2, $3, $4);
      if(defined $$cacheMd5sum{$file}){
        die "ERROR: dupe file in $FILE_CACHE_MD5SUM \"$file\"\n";
      }
      $$cacheMd5sum{$file} = {
        md5sum => $md5sum,
        mtime  => $mtime,
        size   => $size,
      };
    }
  }
  return $cacheMd5sum;
}
sub readDurationCache(){
  my $cacheDuration = {};
  if(-f $FILE_CACHE_DURATION){
    for my $line(readFile($FILE_CACHE_DURATION)){
      if($line !~ /^\s*(\d\d:\d\d:\d\d|-|\?)\s*,\s*(\d+|\d*\.\d+|-|\?)\s*,\s*(\S.*)$/){
        die "ERROR: malformed line in $FILE_CACHE_DURATION\n$line";
      }
      my ($durHMS, $durS, $file) = ($1, $2, $3);
      if(defined $$cacheDuration{$file}){
        die "ERROR: dupe file in $FILE_CACHE_DURATION \"$file\"\n";
      }
      $$cacheDuration{$file} = {
        duration => $durS,
      };
    }
  }
  return $cacheDuration;
}

sub handleUpdateCache($$@){
  my ($opts, $cacheType, @files) = @_;

  my ($cacheStat, $cacheMd5sum, $cacheDuration) = (undef, undef, undef);
  my ($destCacheFile, $tmpFilePrefix) = (undef, undef);
  if($cacheType eq $CACHE_TYPE_STAT){
    $cacheStat = readStatCache();
    ($destCacheFile, $tmpFilePrefix) = ($FILE_CACHE_STAT, $TMP_PREFIX_CACHE_STAT);
  }elsif($cacheType eq $CACHE_TYPE_MD5SUM){
    $cacheMd5sum = readMd5sumCache();
    ($destCacheFile, $tmpFilePrefix) = ($FILE_CACHE_MD5SUM, $TMP_PREFIX_CACHE_MD5SUM);
  }elsif($cacheType eq $CACHE_TYPE_DURATION){
    $cacheDuration = readDurationCache();
    ($destCacheFile, $tmpFilePrefix) = ($FILE_CACHE_DURATION, $TMP_PREFIX_CACHE_DURATION);
  }else{
    die "ERROR: unknown cache type $cacheType\n";
  }

  print "updating cache $destCacheFile" . ($$opts{simulate} ? " (simulate)" : "") . "\n";
  my $tmpFile = $tmpFilePrefix . "-" . nowMillis();
  system "rm", "-f", "$tmpFilePrefix-latest";
  system "ln", "-s", $tmpFile, "$tmpFilePrefix-latest";
  print "writing $tmpFile\n";

  STDOUT->autoflush(1);

  my $chunkSize = int(@files / 20) + 1;
  my $seenCount = 0;

  my $needsNewline = 0;
  open my $fh, "> $tmpFile" or die "ERROR: could not write $tmpFile\n$!\n";
  $fh->autoflush(1);
  for my $file(@files){
    my $cacheLine;
    if($cacheType eq $CACHE_TYPE_STAT){
      if(not defined $$cacheStat{$file}){
        print "\n" if $needsNewline;
        print "  new file: $file\n";
        $needsNewline = 0;
      }
      my ($fsBytes, $mtime) = getSizeMtime("$BASE_DIR/$file", 1);
      $cacheLine = sprintf("%d , %12db , %s\n", $mtime, $fsBytes, $file);
    }elsif($cacheType eq $CACHE_TYPE_MD5SUM){
      my ($fsBytes, $mtime, $md5sum) = (undef, undef, undef);
      if(defined $$cacheMd5sum{$file}){
        $fsBytes = $$cacheMd5sum{$file}{size};
        $mtime = $$cacheMd5sum{$file}{mtime};
        $md5sum = $$cacheMd5sum{$file}{md5sum};
      }else{
        print "\n" if $needsNewline;
        print "  new file: $file\n";
        $needsNewline = 0;
        ($fsBytes, $mtime) = getSizeMtime("$BASE_DIR/$file", 1);
        $md5sum = md5sumFile("$BASE_DIR/$file");
      }
      die "ERROR: invalid md5sum for $file\n" if $md5sum !~ /^[0-9a-f]{32}$/;
      $cacheLine = sprintf("%s , %d , %12db , %s\n", $md5sum, $mtime, $fsBytes, $file);
    }elsif($cacheType eq $CACHE_TYPE_DURATION){
      my ($durS, $durHMS) = (undef, undef);

      if(defined $$cacheDuration{$file}){
        $durS = $$cacheDuration{$file}{duration};
      }elsif($file =~ /\.($DURATION_EXT_REGEX)$/i){
        print "\n" if $needsNewline;
        print "  new file: $file\n";
        $needsNewline = 0;
        $durS = getDuration("$BASE_DIR/$file");
      }

      if(defined $durS and $durS =~ /^(\d+|\d*\.\d+)$/){
        $durHMS = formatDurationHMS($durS);
        $durS = sprintf "%13.6f", $durS;
      }else{
        $durHMS = "-";
        $durS = "-";
      }
      $cacheLine = sprintf("%8s , %13s , %s\n", $durHMS, $durS, $file);
    }else{
      die "ERROR: unknown cache type $cacheType\n";
    }

    print $fh $cacheLine;
    if($seenCount % $chunkSize == 0){
      printf " %d%%", (100.0 * $seenCount / @files);
      $needsNewline = 1;
    }
    $seenCount++;
  }
  close $fh;
  print " done\n";

  if($$opts{simulate}){
    print "simulate: not updating $destCacheFile\n";
    print "simulate: keeping $tmpFile\n";
  }else{
    run "mv", $tmpFile, $destCacheFile;
    system "rm", "-f", "$tmpFilePrefix-latest";
  }

  if(isGitFileUnstaged($INFO_DIR, $destCacheFile)){
    if($$opts{simulate} or $$opts{skipGit}){
      print "#SKIPPING GIT COMMIT FOR $destCacheFile\n";
    }else{
      gitCommitFile($INFO_DIR, $destCacheFile, "cache-$cacheType: automatic commit");
    }
  }

  print "\n";
}

sub gitCommitFile($$$){
  my ($repo, $file, $msg) = @_;
  run "git", "-C", $repo, "add", $file;
  run "git", "-C", $repo, "commit", "-m", $msg;
}
sub isGitFileUnstaged($$){
  my ($repo, $file) = @_;

  my @gitDiffCmd = ("git", "-C", $repo, "diff", "--quiet", "--exit-code", $file);
  system @gitDiffCmd;
  my $exitCode = $? >> 8;

  if($exitCode == 1){
    #file has differences
    return 1;
  }elsif($exitCode == 0){
    #file has no differences
    return 0;
  }else{
    die "ERROR: @gitDiffCmd failed with exitCode=$exitCode\n$!\n";
  }
}

sub getSizeMtime($$){
  my ($file, $isFollowSymlinks) = @_;
  my @stat = $isFollowSymlinks ? stat($file) : lstat($file);
  my $fsBytes = $stat[7];
  my $mtime = $stat[9];
  return ($fsBytes, $mtime);
}

sub getDuration($){
  my ($file) = @_;
  my $duration = readProc $DURATION_EXEC, "--seconds", "--nofilename", $file;
  chomp $duration;
  if($duration =~ /^(\d+|\d*\.\d+)$/){
    return $1;
  }else{
    return undef;
  }
}

sub formatDurationHMS($){
  my ($duration) = @_;
  my $durS = int($duration + 0.5);
  return sprintf "%02d:%02d:%02d",
    int($durS / 60 / 60),
    int($durS / 60 % 60),
    int($durS % 60),
  ;
}

sub md5sumFile($){
  my ($file) = @_;
  my $d = Digest::MD5->new();
  open my $fh, "<", $file or die "ERROR: could not read $file\n$!\n";
  $d->addfile($fh);
  my $digest = $d->hexdigest();
  close $fh;
  return $digest;
}

sub readFile($){
  my ($file) = @_;
  open my $fh, "<", $file or die "ERROR: could not read $file\n$!\n";
  my @lines = <$fh>;
  close $fh;
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;
  }
}

sub run(@){
  print "@_\n";
  runQuiet(@_);
}
sub runQuiet(@){
  system @_;
  if($? != 0){
    die "ERROR: command \"@_\" failed\n$!\n";
  }
}

sub readProc(@){
  my @cmd = @_;
  open my $cmdH, "-|", @cmd or die "ERROR: could not run @_\n$!\n";
  my @lines = <$cmdH>;
  close $cmdH;
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;
  }
}

sub nowMillis(){
  return int(time() * 1000.0 + 0.5);
}

&main(@ARGV);
