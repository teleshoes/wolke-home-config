#!/usr/bin/perl
use strict;
use warnings;

sub reloadFcron();
sub getDefaultAlarmLine($$);
sub parseAlarmTime($);
sub appendAlarmLine($);
sub removeAlarmName($);
sub readFcronLines();
sub writeFcronLines($);
sub run(@);
sub wrap($);

my $FCRONTAB_ALARM = "$ENV{HOME}/.fcrontab-alarm";
my $DEFAULT_ALARM_NAME = 'XX';

my $REGEX_ALARM_NAME = "^[a-zA-Z][a-zA-Z0-9]\$";

my $h12Re = "(?:0?[0-9]|1[0-2])";
my $h24Re = "(?:0?[0-9]|1[0-9]|2[0-4])";
my $minRe = "(?:[0-5][0-9])";
my $amRe = "(?:[aApP][mM])";

my $absTimeRe = "^(?:$h24Re:$minRe|$h12Re:$minRe$amRe|$h12Re$amRe)\$";
my $relTimeRe = "^(?:[0-9]+[dhmsDHMS])+\$";
my $minTimeRe = "^(?:[0-9]+)\$";

my $usage = "Usage:
  Update $FCRONTAB_ALARM, and reload as current user's fcrontab.

  $0 -h|--help
    print this message

  $0 --run [ALARM_NAME]
    first deletes the alarm, as in '$0 --remove ALARM_NAME'
    then runs: 'alarm -g ALARM_NAME'

  $0 --remove [ALARM_NAME]
    delete any existing fcrontab lines ending in #ALARM_NAME

  $0 [ALARM_NAME] TIME
  $0 --add [ALARM_NAME] TIME
    first deletes the alarm, as in '$0 --remove ALARM_NAME'
    then adds a new fcrontab line: '<alarm_time> <alarm_cmd> #ALARM_NAME'
      alarm_time: calculated from TIME, either relative or absolute
      alarm_cmd: '$0 --run ALARM_NAME'

    e.g.:   '$0 14:45'   => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '14:45') . "'
            '$0 5pm'     => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '5pm') . "'
            '$0 12:30am' => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '12:30am') . "'

            '$0 30s'     => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '30s') . "'
            '$0 5'       => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '5') . "'
            '$0 1m30s'   => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '1m30s') . "'
            '$0 2d12h3m  => '" . getDefaultAlarmLine($DEFAULT_ALARM_NAME, '2d12h3m') . "'

    ALARM_NAME
      exactly 2 characters, first must be alpha, second must be alphanumeric
      default='$DEFAULT_ALARM_NAME'

    TIME
      either absolute (hours and minutes), relative time-units, or relative minutes
      absolute: next wall clock time, added as 'MM HH * * *'
        HH24:MM       00-23hr 00-59min            e.g.: 15:30  => '30 15 * * *'
        HH12:MMa      1-12hr  00-59min  AM or PM  e.g.: 3:30pm => '30 15 * * *'
        HH12a         1-12hr            AM or PM  e.g.: 3pm    => '0 15 * * *'

      relative time-units: elapsed time, re-formatted to an fcron relative time:
        '@ <DAYS>d<HOURS>h<SECONDS>s<MINUTES>'

      time is a list of numbers followed by units (e.g.: 2d4h30m20s)
      all values are added together, and reformatted as day-hr-sec-min

      units are case insensitive. allowed units:
        d:    days    (24 hours)
        h:    hours   (60 minutes)
        m:    minutes (60 seconds) !NOT MONTHS!
        s:    seconds

      e.g.:
        5m             =>  5m             => '@ 5'
        10s            =>  10s            => '@ 10s'
        1m30s          =>  1m 30s         => '@ 30s1'
        1d6h30m20s     =>  1d 6h 30m 20s  => '@ 1d6h20s30'
        5m1h1h1h20s    =>  3h 5m 20s      => '@ 3h20s5'

      relative minutes: just a single integer for minutes
        5              =>  5m             => '@ 5'
";

sub main(@){
  die $usage if @_ > 0 and $_[0] =~ /^(-h|--help)$/;

  if(`whoami` =~ /^root$/){
    die "ERROR: cannot run $0 as root\n";
  }

  my $action = "add";
  if(@_ == 0){
    die $usage;
  }elsif($_[0] =~ /^(--run)$/){
    shift @_;
    $action = "run";
  }elsif($_[0] =~ /^(--add)$/){
    shift @_;
    $action = "add";
  }elsif($_[0] =~ /^(--remove)$/){
    shift @_;
    $action = "remove";
  }

  my $alarmName;
  if(@_ > 0 and $_[0] =~ /$REGEX_ALARM_NAME/){
    $alarmName = shift @_;
  }else{
    $alarmName = $DEFAULT_ALARM_NAME;
  }

  my $time;
  if(@_ > 0 and $_[0] =~ /$absTimeRe|$relTimeRe|$minTimeRe/){
    $time = shift @_;
  }

  die $usage if @_ > 0;

  if($action eq "run"){
    removeAlarmName $alarmName;
    reloadFcron();
    exec "alarm", "-g", $alarmName;
  }elsif($action eq "remove"){
    if(not removeAlarmName $alarmName){
      die "Alarm $alarmName not found\n";
    }
    reloadFcron();
  }elsif($action eq "add" and defined $time){
    removeAlarmName $alarmName;
    reloadFcron();
    appendAlarmLine getDefaultAlarmLine($alarmName, $time);
    reloadFcron();
  }else{
    die $usage;
  }
}

sub reloadFcron(){
  system "fcrontab", $FCRONTAB_ALARM;
}

sub getDefaultAlarmLine($$){
  my ($alarmName, $time) = @_;
  my $alarmTime = parseAlarmTime $time;
  my $cmd = "$0 --run $alarmName";
  return "$alarmTime $cmd #$alarmName";
}
sub parseAlarmTime($){
  my $time = shift;
  if($time =~ /$absTimeRe/){
    my ($h, $m, $am);
    if($time =~ /^($h24Re):($minRe)$/){
      ($h, $m, $am) = ($1, $2, undef);
    }elsif($time =~ /^($h12Re):($minRe)($amRe)$/){
      ($h, $m, $am) = ($1, $2, $3);
    }elsif($time =~ /^($h12Re)($amRe)$/){
      ($h, $m, $am) = ($1, 0, $2);
    }
    if(defined $am){
      $h %= 12;
      $h += 12 if lc $am eq "pm";
    }
    return "$m $h * * *";
  }elsif($time =~ /$relTimeRe/){
    my $seconds = 0;
    while($time =~ s/^(\d+)([dhmsDHMS])//){
      my ($val, $unit) = ($1, $2);
      $seconds += $val if $unit =~ /[sS]/;
      $seconds += $val * 60 if $unit =~ /[mM]/;
      $seconds += $val * 60 * 60 if $unit =~ /[hH]/;
      $seconds += $val * 60 * 60 * 24 if $unit =~ /[dD]/;
    }
    die "error parsing RELTIME: $time\n" if length($time) != 0;
    my $s = int($seconds)       % 60;
    my $m = int($seconds/60)    % 60;
    my $h = int($seconds/60/60) % 24;
    my $d = int($seconds/60/60/24);
    my $fmt = "";
    $fmt .= "${d}d" if $d > 0;
    $fmt .= "${h}h" if $h > 0;
    $fmt .= "${s}s" if $s > 0;
    $fmt .= "${m}" if $m > 0;

    return "@ $fmt";
  }elsif($time =~ /$minTimeRe/){
    return "@ $time";
  }else{
    die "malformed time: $time\n";
  }
}
sub appendAlarmLine($){
  my $line = shift;
  chomp $line;
  $line .= "\n";
  print "appending:\n$line";
  my @lines = (readFcronLines(), $line);
  writeFcronLines \@lines;
}

sub removeAlarmName($){
  my $alarmName = shift;

  my $modified = 0;
  my @lines = readFcronLines();
  for my $line(@lines){
    if($line =~ /#$alarmName\s*$/){
      $line = "";
      $modified = 1;
    }
  }
  if($modified){
    writeFcronLines(\@lines);
  }
  return $modified;
}

sub readFcronLines(){
  if(not -e $FCRONTAB_ALARM){
    return ();
  }
  open FH, "< $FCRONTAB_ALARM" or die "Could not read $FCRONTAB_ALARM\n";
  my @lines = <FH>;
  close FH;
  return @lines;
}
sub writeFcronLines($){
  my @lines = @{shift()};
  open FH, "> $FCRONTAB_ALARM" or die "Could not write $FCRONTAB_ALARM\n";
  print FH @lines;
  close FH;
}

sub run(@){
  print "@_\n";
  system @_;
  die "Error running @_\n" if $? != 0;
}
sub wrap($){
  my $s = shift;
  $s =~ s/"/\\"/g;
  return $s;
}

&main(@ARGV);
