#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);

my $mntDir = "/media";

my $backups = {
  "home" => ["/home" => "BACKUP_HOME"],
  "stuff" => ["/media/stuff" => "BACKUP_STUFF"],
};
my $firstName = (sort keys %$backups)[0];
my ($firstSrc, $firstMnt) = @{$$backups{$firstName}};
my $okNames = join "|", sort keys %$backups;
my @mntPoints = map {$$_[0]} values %$backups;
my @backupMntNames = map {$$_[1]} values %$backups;

sub mountAndBackup($$);
sub backup($$);
sub backupSymlink($$);
sub sendReceive($$$$);
sub test(@);
sub getSyncedSnapshot($$);
sub makeSnapshot($$);
sub getSubvolumes($);
sub getSubvolumePaths($);
sub getSubvolumeQuotaInfo($);
sub formatSubvolumeQuotaInfo($$$);
sub isQuotaEnabled($);
sub getSnapshots($$);
sub getLastSnapshot($$);
sub cleanupSnapshots($$$);
sub deleteSnapshots($@);
sub getBtrfsMountDev($);
sub monitorPvLog();
sub latestPvLogFile();
sub guessPrefixes($);
sub guessSubvolNames($);
sub bashComplete($$);

sub sync();
sub run(@);
sub tryrun(@);
sub ensureRoot();

my $okSortBy = join "|", qw(id path size);
my $defaultSortBy = 'size';

my $usage = "Usage:
  $0 -h|--help
    Print this message

  $0 [$okNames]
    Perform backup specified {default is to perform all}
    -use specified SRC {e.g.: '$firstSrc' for '$firstName'}
    -use specified DEST {e.g.: '$mntDir/$firstMnt' for '$firstName'}
    -use mnt to (re)mount DEST
    -find the last sync-ed snapshot in SRC and DEST
    -make a new snapshot in SRC
    -send the difference between the old SRC and new SRC to DEST
    -use mnt to unmount DEST

  $0 SRC DEST
    Perform an incremental backup between two btrfs filesystems
    -find the last agreed upon snapshot in SRC and DEST
    -make a new snapshot in SRC
    -send the difference between the old SRC and new SRC to DEST

  $0 --sendreceive SRC DEST SNAPSHOT [PARENT_SNAPSHOT]
    Call send/receive to send a btrfs image.
    Roughly equivalent to:
      btrfs send -p SRC/PARENT_SNAPSHOT SRC/SNAPSHOT | btrfs receive DEST
    If PARENT_SNAPSHOT is omitted, no -p argument is given

  $0 --lastsnapshot MOUNT_POINT [PREFIX]
    Print the last snapshot of the given prefix

  $0 --snapshot MOUNT_POINT [PREFIX]
    make a read-only snapshot of MOUNT_POINT named PREFIX-YYYY-MM-DD_MILLIS
    PREFIX defaults to \"SNAPSHOT\", and cannot be \"BACKUP\"

  $0 --cleanup=INSTANCES MOUNT_POINT PREFIX
    remove snapshots named PREFIX-*, leaving the last INSTANCES.
    INSTANCES is a positive integer or 'all'

  $0 --remove
    for each MOUNT_POINT in (" . join(", ", @mntPoints) . "), run:
      $0 --cleanup=1 /media/MOUNT_POINT \"BACKUP\"
    for each MOUNTNAME in (" . join(", ", @backupMntNames) . "), run:
      mnt -m MOUNTNAME
      $0 --cleanup=1 /media/MOUNTNAME \"BACKUP\"

  $0 --delete MOUNT_POINT SUBVOLUME_NAME [SUBVOLUME_NAME...]
    similar to:
    'cd MOUNT_POINT; btrfs subvol delete SUBVOLUME_NAME SUBVOLUME_NAME ..'
    also cleans up qgroups if quota is enabled

  $0 --monitor
    tail the latest pv log, switching to the latest when a new one is created

  $0 --info [--quick] [--sort-by=[$okSortBy] MOUNT_POINT
    show all subvolumes and data usage
    if --quick is not specified, (re-)enable quotas and rescan first
    --sort-by is the sort order of the subvols (default is $defaultSortBy)
      id:   subvol id, smallest first
      path: subvol path, lexicographically
      size: bytes used exclusively by subvol, largest first

   $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline
";

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print join ' ', bashComplete($_[1], $_[2]);
    exit 0;
  }

  die $usage if @_ > 0 and $_[0] =~ /^(-h|--help)$/;
  ensureRoot();

  if(@_ == 0 or (@_ == 1 and $_[0] =~ /^($okNames)$/)){
    my $name = shift;
    for my $backupName(sort keys $backups){
      next unless not defined $name or $name eq $backupName;
      my ($srcDir, $mntName) = @{$$backups{$backupName}};
      mountAndBackup $srcDir, $mntName;
      print "\n\n";
    }
  }elsif((@_ == 4 or @_ == 5) and $_[0] =~ /^--sendreceive$/){
    shift;
    my ($srcDir, $destDir, $snapshot, $parentSnapshot) = @_;
    sendReceive $srcDir, $destDir, $snapshot, $parentSnapshot;
  }elsif((@_ == 2 or @_ == 3) and $_[0] =~ /^--snapshot$/){
    shift;
    my ($mountPoint, $prefix) = @_;
    $prefix = "SNAPSHOT" if not defined $prefix;
    $mountPoint =~ s/\/$//;
    die "not a dir: $mountPoint\n" if not -d $mountPoint;

    die "prefix must be a word i.e.: /\\w+/: $prefix\n" if $prefix !~ /^\w+$/;
    die "PREFIX cannot be 'BACKUP'\n" if $prefix eq "BACKUP";

    die $usage if not defined $mountPoint or @_ > 2;
    makeSnapshot $mountPoint, $prefix;
    sync();
  }elsif((@_ == 2 or @_ == 3) and $_[0] =~ /^--lastsnapshot$/){
    shift;
    my ($mountPoint, $prefix) = @_;
    $prefix = "SNAPSHOT" if not defined $prefix;
    $mountPoint =~ s/\/$//;
    die "not a dir: $mountPoint\n" if not -d $mountPoint;

    die "prefix must be a word i.e.: /\\w+/: $prefix\n" if $prefix !~ /^\w+$/;

    die $usage if not defined $mountPoint or @_ > 2;
    my $snapshot = getLastSnapshot $mountPoint, $prefix;
    print "$snapshot\n";
  }elsif(@_ == 3 and $_[0] =~ /^--cleanup=(\d+|all)$/){
    my ($mountPoint, $prefix, $instances) = ($_[1], $_[2], $1);
    die "INSTANCES must be > 0\n" if $instances ne 'all' and $instances <= 0;
    cleanupSnapshots $mountPoint, $prefix, $instances;
  }elsif(@_ >= 3 and $_[0] =~ /^--delete$/){
    my $mountPoint = $_[1];
    my @toDelete = @_[2..$#_];
    deleteSnapshots $mountPoint, @toDelete;
  }elsif(@_ == 1 and $_[0] =~ /^--remove$/){
    for my $name(sort keys %$backups){
      my ($srcMntPoint, $destMntName) = @{$$backups{$name}};
      my $destMntPoint = "/media/$destMntName";
      tryrun "mnt", "-m", $destMntName;

      my $oldBackup = getSyncedSnapshot($srcMntPoint, $destMntPoint);
      cleanupSnapshots $srcMntPoint, "BACKUP", 1;
      cleanupSnapshots $destMntPoint, "BACKUP", 1;
      my $newBackup = getSyncedSnapshot($srcMntPoint, $destMntPoint);
      if($oldBackup ne $newBackup){
        die "FATAL ERROR: latest backup is missing- $oldBackup\n";
      }
      run "mnt", "-u", $destMntName;
    }
  }elsif(@_ == 1 and $_[0] =~ /^--monitor$/){
    monitorPvLog();
  }elsif(@_ >= 2 and $_[0] =~ /^--info$/){
    shift;
    my $quick = 0;
    if($_[0] =~ /^(--quick)$/){
      $quick = 1;
      shift;
    }

    my $sortBy = $defaultSortBy;
    if($_[0] =~ /^--sort-by=($okSortBy)$/){
      $sortBy = $1;
      shift;
    }

    my $mnt = shift;
    die $usage if not defined $mnt or @_ > 0;

    my $fsSize = `df -B1 --output=size "$mnt" | tail -1`;
    chomp $fsSize;
    die "could not df $mnt\n" if $fsSize !~ /^\d+$/ or $fsSize == 0;

    if(not $quick){
      print "(re-)enabling quota and rescanning:\n";
      run "btrfs quota disable \"$mnt\"";
      run "btrfs quota enable \"$mnt\"";
      run "btrfs quota rescan -w \"$mnt\"";
    }
    if(not isQuotaEnabled($mnt)){
      die "quota is not enabled\n";
    }

    my $info = getSubvolumeQuotaInfo $mnt;

    print formatSubvolumeQuotaInfo($fsSize, $info, $sortBy);
  }elsif(@_ == 2){
    my ($srcDir, $destDir) = @_;
    backup $srcDir, $destDir;
  }else{
    die $usage;
  }
}

sub mountAndBackup($$){
  my ($srcDir, $mntName) = @_;
  my $destDir = "$mntDir/$mntName";

  die "dir not found: $srcDir\n" if not -d $srcDir;

  run "mnt", "-u", $mntName if -e $destDir;
  die "$destDir exists already\n" if -e $destDir;

  run "mnt", "-l", $mntName;

  backup $srcDir, $destDir;

  run "mnt", "-u", $mntName;
}

sub backup($$){
  my ($srcDir, $destDir) = @_;
  $srcDir =~ s/\/$//;
  $destDir =~ s/\/$//;

  die "$srcDir is not btrfs\n" if not defined getBtrfsMountDev $srcDir;
  die "$destDir is not btrfs\n" if not defined getBtrfsMountDev $destDir;

  my $syncedSnapshot = getSyncedSnapshot $srcDir, $destDir;

  my $newSnapshot = makeSnapshot $srcDir, "BACKUP";

  sync();

  sendReceive $srcDir, $destDir, $newSnapshot, $syncedSnapshot;

  backupSymlink $destDir, $newSnapshot;
}

sub backupSymlink($$){
  my ($dir, $snapshotName) = @_;

  if(test "-h", "$dir/backup"){
    run "rm", "$dir/backup";
  }

  if(not test "-e", "$dir/backup"){
    run "ln", "-s", $snapshotName, "$dir/backup";
  }else{
    print STDERR "$dir/backup exists, not creating symlink\n";
  }
}

sub sendReceive($$$$){
  my ($sendDir, $receiveDir, $snapshotName, $parentSnapshotName) = @_;

  my $parent = '';
  if(defined $parentSnapshotName){
    $parent = "-p \"$sendDir/$parentSnapshotName\"";
  }

  if(test "-e", "$receiveDir/$snapshotName"){
    die "snapshot exists on dest already: $receiveDir/$snapshotName\n";
  }

  my $pvLog = "/tmp/$snapshotName-pv.log";
  my $rcvLog = "/tmp/$snapshotName-btrfs-rcv.log";
  print "\nLOGS: $pvLog $rcvLog\n";

  print "\n";
  run "bash", "-c", "time ( "
    . " btrfs send $parent \"$sendDir/$snapshotName\""
    . " | "
    . " pv -r -a -t -b -f 2> >(tee $pvLog 1>&2)"
    . " | "
    . " btrfs receive -v -v \"$receiveDir\" 2> >(tee $rcvLog 1>&2)"
    . " )"
    ;

  print "\nLOGS: $pvLog $rcvLog\n";
  print "\n";
  run "cat", $pvLog;
  print "\n";

  if(not test "-d", "$receiveDir/$snapshotName"){
    die "snapshot send/receive failed: $receiveDir/$snapshotName\n";
  }
}

sub test(@){
  my @test = ("test", @_);
  tryrun @test;
  return $? == 0;
}

sub getSyncedSnapshot($$){
  my ($srcDir, $destDir) = @_;
  $srcDir =~ s/\/$//;
  $destDir =~ s/\/$//;

  my $lastSrc = getLastSnapshot $srcDir, "BACKUP";
  my $lastDest = getLastSnapshot $destDir, "BACKUP";
  if($lastSrc ne $lastDest){
    die "Mismatched last snapshot:\n$srcDir/$lastSrc\n$destDir/$lastDest\n";
  }
  return $lastSrc;
}

sub makeSnapshot($$){
  my ($mountPoint, $prefix) = @_;
  my $millis = int(time * 1000);
  my $date = `date +%F`;
  chomp $date;

  my $snapshot = "$prefix-${date}_${millis}";
  my $snapshotDir = "$mountPoint/$snapshot";

  die "$snapshotDir already exists!\n" if -e $snapshotDir;
  run "btrfs", "subvolume", "snapshot", "-r", $mountPoint, $snapshotDir;

  if($snapshot ne getLastSnapshot $mountPoint, $prefix){
    die "snapshot failed\n";
  }

  return $snapshot;
}

sub getSubvolumes($){
  my $mnt = shift;
  my @subLines = `btrfs subvolume list "$mnt"`;
  my $subs = {};
  for my $subLine(@subLines){
    if($subLine =~ /ID (\d+) gen (\d+) top level (\d+) path (.*)$/){
      my ($id, $gen, $level, $path) = ($1, $2, $3, $4);
      $$subs{$id} = $path;
    }else{
      die "misformatted subvolume line: $subLine\n";
    }
  }
  return $subs;
}
sub getSubvolumePaths($){
  my $mnt = shift;
  my $subs = getSubvolumes($mnt);
  my $paths = [];
  for my $id(sort {$a <=> $b} keys %$subs){
    push @$paths, $$subs{$id};
  }
  return $paths;
}

sub getSubvolumeQuotaInfo($){
  my $mnt = shift;
  my @qgroupLines = `btrfs qgroup show \"$mnt\"`;
  die "invalid output from qgroup show on $mnt" if 0
    or @qgroupLines < 3
    or $qgroupLines[0] !~ /^\s*qgroupid\s*rfer\s*excl\s*$/
    or $qgroupLines[1] !~ /^\s*-+\s*-+\s*-+\s*$/
    ;
  shift @qgroupLines;
  shift @qgroupLines;

  my $subs = getSubvolumes($mnt);
  my $root = undef;

  my $info = {};
  for my $qgroup(@qgroupLines){
    if($qgroup !~ /^\s*0\/(\d+)\s*(-?\d+)\s*(\d+)/){
      die "Malformed qgroup: $qgroup\n";
    }
    my($subId, $total, $excl) = ($1, $2, $3);
    if(not defined $root and not defined $$subs{$subId}){
      $root = $subId;
      $$subs{$subId} = "root";
    }

    if(not defined $$subs{$subId}){
      print STDERR "WARNING: unknown subvolume $subId\n";
      next;
    }
    die "duplicated subvolume: $subId\n" if defined $$info{$subId};

    $$info{$subId} = {
      path  => $$subs{$subId},
      total => $total,
      excl  => $excl,
    };
  }

  for my $subId(sort keys %$subs){
    if(not defined $$info{$subId}){
      print STDERR "WARNING: missing qgroup for $subId {maybe deleted?)\n";
    }
  }

  return $info;
}

sub formatSubvolumeQuotaInfo($$$){
  my ($fsSize, $info, $sortBy) = @_;
  my $s = '';

  my $sortFcts = {
    id   => sub($$){$_[0] <=> $_[1]},
    size => sub($$){$$info{$_[1]}{excl} <=> $$info{$_[0]}{excl}},
    path => sub($$){$$info{$_[0]}{path} cmp $$info{$_[1]}{path}},
  };

  my $sortFct = $$sortFcts{$sortBy};
  die "unknown sort function: $sortBy\n" if not defined $sortFct;

  for my $subId(sort $sortFct (keys %$info)){
    my $path = $$info{$subId}{path};
    $path = sprintf '%-32s', $path;

    my $size = $$info{$subId}{excl};
    $size /= 1024;
    $size = sprintf '%10d', $size;

    my $pct = 100 * ($$info{$subId}{excl} / $fsSize);
    $pct = sprintf '%7.3f', $pct;

    $s .= "$path ${size}KiB $pct\%\n";
  }

  return $s;
}

sub isQuotaEnabled($){
  my $mnt = shift;
  system "btrfs qgroup show \"$mnt\" >/dev/null 2>/dev/null";
  return $? == 0;
}

sub getSnapshots($$){
  my ($dir, $prefix) = @_;
  my @subs = @{getSubvolumePaths($dir)};
  @subs = grep {/^$prefix-\d\d\d\d-\d\d-\d\d_\d+$/} @subs;

  my @sortedSubs = sort @subs;
  for(my $i=0; $i<@subs; $i++){
    if($subs[$i] ne $sortedSubs[$i]){
      die "snapshots are out of order {ID versus date}\n";
    }
  }

  for my $sub(@subs){
    die "$dir/$sub is not a dir\n" if not -d "$dir/$sub";
  }

  return @subs;
}

sub getLastSnapshot($$){
  my ($dir, $prefix) = @_;
  die "not a dir: $dir\n" if not -d $dir;

  my @subs = getSnapshots $dir, $prefix;
  die "no snapshot found for $dir\n" if @subs == 0;
  my $sub = $subs[-1];
  return $sub;
}

sub cleanupSnapshots($$$){
  my ($mountPoint, $prefix, $instances) = @_;
  my @subs = getSnapshots $mountPoint, $prefix;

  if($instances eq 'all' and $prefix =~ /BACKUP/i){
    die "NOT deleting all your backups, do that by hand if you like\n";
  }

  my @toKeep;
  my @toDelete;
  if($instances eq 'all'){
    @toKeep = ();
    @toDelete = @subs;
  }else{
    my @revsubs = reverse sort @subs;
    @toKeep = grep {defined} reverse @revsubs[0 .. $instances-1];
    @toDelete = grep {defined} reverse @revsubs[$instances .. $#revsubs];
  }

  print "to keep (" . scalar(@toKeep) . "):\n ";
  print join "\n ", @toKeep;
  print "\n\n";
  print "to delete (" . scalar(@toDelete) . "):\n ";
  print join "\n ", @toDelete;
  print "\n\n";

  if($instances eq 'all'){
    print "DELETING ALL THESE SNAPSHOTS\n";
    print "ok? [Y/n] ";
    my $ok = <STDIN>;
    if($ok =~ /n/i){
      die "user cancelled\n";
    }
  }else{
    die "ERROR: no snapshots would remain\n" if @toKeep == 0;
  }

  if(@toDelete > 0){
    deleteSnapshots $mountPoint, @toDelete;
  }
}

sub deleteSnapshots($@){
  my ($mountPoint, @toDelete) = @_;

  @toDelete = map {s/\/$//; $_} @toDelete;

  my $subvolumes = getSubvolumes $mountPoint;
  my %subIds = map {$$subvolumes{$_} => $_} keys %$subvolumes;

  for my $sub(@toDelete){
    die "MALFORMED SNAPSHOT NAME: '$sub' contains '/'\n" if $sub =~ /\//;
    die "MISSING SNAPSHOT: $sub\n" if not -d "$mountPoint/$sub";
    die "SUBVOLUME ID NOT FOUND: $sub\n" if not defined $subIds{$sub};
  }

  my @pathsToDelete = map {"$mountPoint/$_"} @toDelete;
  my @qgroupsToDelete = map {"0/$subIds{$_}"} @toDelete;
  run "btrfs", "subvolume", "delete", @pathsToDelete;
  if(isQuotaEnabled($mountPoint)){
    for my $qgroupId(@qgroupsToDelete){
      tryrun "btrfs", "qgroup", "destroy", $qgroupId, $mountPoint;
    }
  }
  print "deleted " . scalar(@toDelete) . " subvolumes\n";
  sync();
}

sub getBtrfsMountDev($){
  my $dir = shift;
  for my $line(`mount`){
    if($line =~ m/^([_a-zA-Z0-9\/\-]+) on $dir type btrfs /){
      return $1;
    }
  }
  return undef;
}

sub guessPrefixes($){
  my $mountPoint = shift;
  my @subs = guessSubvolNames $mountPoint;
  my @prefixWords = map { /^(\w+)/; $1} @subs;
  my %uniqPrefixWords = map { $_ => 1} @prefixWords;
  return sort keys %uniqPrefixWords;
}
sub guessSubvolNames($){
  my $mountPoint = shift;
  $mountPoint =~ s/'/'\\''/g;
  my @subs = `ls '$mountPoint' 2>/dev/null`;
  my %subvolNames;
  for my $sub(@subs){
    if($sub =~ /^(?:.*\/)?(\w+-\d{4}-\d{2}-\d{2}_\d+)$/){
      $subvolNames{$1} = 1;
    }
  }
  return sort keys %subvolNames;
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  my @backupNames = sort keys %$backups;

  my @cmds = qw(
    -h --help
    --sendreceive
    --snapshot
    --cleanup=1 --cleanup=30 --cleanup=all
    --remove
    --delete
    --monitor
    --info
    --bash-complete
  );

  if(@words == 0){
    return (@backupNames, @mntPoints, @cmds);
  }

  if($words[0] =~ /^(--sendreceive)/){
    if(@words == 1 or @words == 2){
      return @mntPoints;
    }elsif(@words == 3 or @words == 4){
      my $src = $words[1];
      return guessSubvolNames $src;
    }
  }

  if($words[0] =~ /^(--snapshot|--lastsnapshot|--cleanup.*)/){
    if(@words == 1){
      return @mntPoints;
    }elsif(@words == 2){
      my $mnt = $words[1];
      my @prefixes = guessPrefixes $mnt;
      push @prefixes, "SNAPSHOT" if $words[0] =~ /^(--snapshot)$/;
      return @prefixes;
    }
  }

  if($words[0] =~ /^(--delete)$/){
    if(@words == 1){
      return @mntPoints;
    }elsif(@words > 1){
      my $mnt = $words[1];
      return guessSubvolNames $mnt;
    }
  }

  if($words[0] =~ /^(--info)$/){
    my @quick = qw(--quick);
    my @sortBy = qw(--sort-by=id --sort-by=path --sort-by=size);
    if(@words == 1){
      return (@quick, @sortBy, @mntPoints);
    }elsif(@words == 2 and $words[1] =~ /^(--quick)$/){
      return (@sortBy, @mntPoints);
    }elsif(@words == 3 and $words[2] =~ /^(--sort-by.*)$/){
      return (@mntPoints);
    }
  }

  return ();
}

sub sync(){
  run "sync";
}

sub monitorPvLog(){
  my $latest = undef;
  my $pid = undef;
  while(1){
    my $prev = $latest;
    $latest = latestPvLogFile();

    if(defined $latest and (not defined $prev or $prev ne $latest)){
      print "\n\nLOG FILE: $latest\n";
      kill $pid if defined $pid;
      $pid = fork;
      if(not $pid){
        exec "tail", "-F", $latest;
      }
    }

    sleep 0.5;
  }
}

sub latestPvLogFile(){
  my @pvLogs = `ls /tmp/BACKUP-*-pv.log 2>/dev/null`;
  chomp foreach @pvLogs;
  @pvLogs = sort grep {/^\/tmp\/BACKUP-\d+-\d+-\d+_\d+-pv\.log$/} @pvLogs;
  return @pvLogs == 0 ? undef : $pvLogs[-1];
}

sub ensureRoot(){
  if(`whoami` ne "root\n"){
    print STDERR "rerunning as root\n";
    exec "sudo", $0, @ARGV;
  }
}

sub run(@){
  print "@_\n";
  system @_;
  die "FAILED: @_\n" if $? != 0;
}
sub tryrun(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
