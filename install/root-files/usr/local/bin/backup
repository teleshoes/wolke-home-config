#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(time);

my $EXEC = basename $0;

my $BACKUP_CONF_FILE = "$ENV{HOME}/.config/backup.conf";
my $LOG_DIR = "/var/log/backup";
my $SUBVOL_CONTAINER = "SUBVOL";

my $DEFAULT_PREFIX_NAME = "SNAPSHOT";
my @PREFIX_NAMES = qw(BACKUP SNAPSHOT DAILY HOURLY FIVEMIN);
my $OK_PREFIX_NAMES = join "|", @PREFIX_NAMES;

my $SUBVOL_DATETIME_FORMAT = "%Y-%m-%d_%H-%M-%S";
my $DATE_TIME_REGEX = "\\d{4}-\\d{2}-\\d{2}_\\d{2}-\\d{2}-\\d{2}";
my $EPOCH_MILLIS_REGEX = "\\d{13}";

my @INFO_SORT_BY_OPTS = qw(id path size);
my $OK_INFO_SORT_BY = join "|", @INFO_SORT_BY_OPTS;
my $DEFAULT_SORT_BY = 'size';

my $DEFAULT_KEEP_SNAPSHOT_COUNT = 30;

my $COMMAND_HELP = "help";
my $COMMAND_BACKUP_RSYNC = "backup-rsync";
my $COMMAND_CHECK_UUIDS = "check-uuids";
my $COMMAND_BACKUP_SENDRECEIVE = "backup-sendreceive";
my $COMMAND_SENDRECEIVE = "sendreceive";
my $COMMAND_SEED_SENDRECEIVE = "seed-sendreceive";
my $COMMAND_LAST_SNAPSHOT = "last-snapshot";
my $COMMAND_SNAPSHOT = "snapshot";
my $COMMAND_SNAPSHOT_SRC = "snapshot-src";
my $COMMAND_SNAPSHOT_DEST = "snapshot-dest";
my $COMMAND_CLEANUP = "cleanup";
my $COMMAND_DELETE = "delete";
my $COMMAND_INFO = "info";
my $COMMAND_BASH_COMPLETE = "bash-complete";

my $DF_USED_BYTES = "usedBytes";
my $DF_AVAIL_BYTES = "availBytes";
my $DF_SIZE_BYTES = "sizeBytes";
my $DF_USED_GIB = "usedGiB";
my $DF_AVAIL_GIB = "availGiB";
my $DF_SIZE_GIB = "sizeGiB";
my $DF_PERCENT = "percent";
my $DF_MOUNTPOINT = "mountpoint";
my $DF_HOST = "host";

my $USAGE = "Usage:
  $EXEC -h|--help
    print this message

  $EXEC [OPTS] BACKUP_NAME
    same as: $EXEC [OPTS] --backup-rsync BACKUP_NAME

  $EXEC [OPTS] SRC_MOUNTPOINT DEST_MOUNTPOINT
    same as: $EXEC [OPTS] --backup-rsync SRC_MOUNTPOINT DEST_MOUNTPOINT

  $EXEC [OPTS] --backup-rsync BACKUP_NAME
    backup with rsync
      -fetch IPMAGIC_NAME from BACKUP_CONF_FILE ($BACKUP_CONF_FILE)
        use `ipmagic.BACKUP_NAME=IPMAGIC_NAME` present,
        unless IPMAGIC_NAME is given on the commandline
      -get SRC_MOUNTPOINT and DEST_MOUNTPOINT and compare UUIDs, as in
        $EXEC [--ipmagic=IPMAGIC_NAME] --check-uuids BACKUP_NAME
      -perform rsync backup, same as:
        $EXEC [--ipmagic=IPMAGIC_NAME] --backup-rsync SRC_MOUNTPOINT DEST_MOUNTPOINT

  $EXEC [OPTS] --backup-rsync SRC_MOUNTPOINT DEST_MOUNTPOINT
    backup with rsync
      -make a new snapshot SNAPSHOT for SRC_MOUNTPOINT, as in:
        $EXEC --snapshot --prefix=BACKUP SRC_MOUNTPOINT
      -fetch HOST using `ipmagic IPMAGIC_NAME --host`, if IPMAGIC_NAME given
      -run rsync from the new SNAPSHOT to DEST_MOUNTPOINT, as in:
        rsync -avP SRC_MOUNTPOINT/SNAPSHOT/ [HOST:]DEST_MOUNTPOINT/ \\
          --exclude=$SUBVOL_CONTAINER
      -make a snapshot also named SNAPSHOT (same timestamp) for DEST_MOUNTPOINT, as in:
        $EXEC [--ipmagic=IPMAGIC_NAME] --snapshot --prefix=BACKUP DEST_MOUNTPOINT

  $EXEC [OPTS] --check-uuids BACKUP_NAME
    check that the correct partitions are mounted for the backup
      -read and parse BACKUP_CONF_FILE ($BACKUP_CONF_FILE)
      -get SRC_MOUNTPOINT and DEST_MOUNTPOINT for BACKUP_NAME
      -get SRC_UUID and DEST_UUID for BACKUP_NAME
      -fetch mountpoint for SRC_UUID:
        lsblk /dev/disk/by-uuid/SRC_UUID
      -fetch mountpoint for DEST_UUID:
        [ipmagic IPMAGIC_NAME] lsblk /dev/disk/by-uuid/DEST_UUID
      -compare mountpoints from lsblk to backup conf file
      -exit with exit code 0 if and fail on mismatch

  $EXEC [OPTS] --backup-sendreceive BACKUP_NAME
    backup using btrfs send/receive
      -fetch IPMAGIC_NAME from BACKUP_CONF_FILE ($BACKUP_CONF_FILE)
        use `ipmagic.BACKUP_NAME=IPMAGIC_NAME` present,
        unless IPMAGIC_NAME is given on the commandline
      -get SRC_MOUNTPOINT and DEST_MOUNTPOINT and compare UUIDs, same as:
        $EXEC [--ipmagic=IPMAGIC_NAME] --check-uuids BACKUP_NAME
      -perform send/receive backup, same as:
        $EXEC [--ipmagic=IPMAGIC_NAME] --backup-sendreceive SRC_MOUNTPOINT DEST_MOUNTPOINT

  $EXEC [OPTS] --backup-sendreceive SRC_MOUNTPOINT DEST_MOUNTPOINT
    backup using btrfs send/receive
      -find last snapshot for SRC_MOUNTPOINT, as in:
      -obtain PARENT_SNAPSHOT for src, as in:
        $EXEC --last-snapshot --prefix=BACKUP SRC_MOUNTPOINT
      -obtain PARENT_SNAPSHOT for dest, as in:
        $EXEC [--ipmagic=IPMAGIC_NAME] --last-snapshot --prefix=BACKUP DEST_MOUNTPOINT
      -fail if PARENT_SNAPSHOT is different for src and dest
      -make a new snapshot SNAPSHOT for SRC_MOUNTPOINT, as in:
        $EXEC --snapshot --prefix=BACKUP SRC_MOUNTPOINT
      -send the diff between the two latest snapshots to DEST_MOUNTPOINT, roughly the same as:
         $EXEC [--ipmagic=IPMAGIC_NAME] --sendreceive \\
           SRC_MOUNTPOINT DEST_MOUNTPOINT SNAPSHOT PARENT_SNAPSHOT
      -run `sync` and `[ipmagic IPMAGIC_NAME] sync`

  $EXEC [OPTS] --sendreceive SRC_MOUNTPOINT DEST_MOUNTPOINT SNAPSHOT [PARENT_SNAPSHOT]
    Call send/receive to send a btrfs image.
      -extract SUBVOL_DIR by removing last path element from SNAPSHOT
         e.g.: SUBVOL/BACKUP/BACKUP_176 => SUBVOL/BACKUP
      -prepare '-p' argument for btrfs send if PARENT_SNAPSHOT is given (no -p if omitted)
      -invoke btrfs send and btrfs receive, roughly equivalent to:
         btrfs send [-p SRC_MOUNTPOINT/PARENT_SNAPSHOT] SRC_MOUNTPOINT/SNAPSHOT \\
         | [ipmagic IPMAGIC_NAME] btrfs receive DEST_MOUNTPOINT/SNAPSHOT

  $EXEC [OPTS] --seed-sendreceive SRC_MOUNTPOINT DEST_MOUNTPOINT
    Make a BACKUP snapshot on SRC_MOUNTPOINT, and call btrfs send/receive
      -make snapshot, same as:
        $EXEC --snapshot --prefix=BACKUP SRC_MOUNTPOINT
      -obtain PARENT_SNAPSHOT, as in:
        $EXEC --last-snapshot --prefix=BACKUP SRC_MOUNTPOINT
      -run btrfs send/receive, as in:
        $EXEC [OPTS] --sendreceive SRC_MOUNTPOINT DEST_MOUNTPOINT PARENT_SNAPSHOT

  $EXEC [OPTS] --last-snapshot [PREFIX] MOUNTPOINT
    Print the last snapshot of the given --prefix=PREFIX
      -get a list of subvolumes, as in:
        [ipmagic IPMAGIC_NAME] btrfs subvolume list MOUNTPOINT
      -filter out subvolumes that do not match:
        $SUBVOL_CONTAINER/<PREFIX>/<PREFIX>_<$SUBVOL_DATETIME_FORMAT>_<MILLIS>
      -ensure that subvolumes are ordered by btrfs the same as MILLIS
      -print the last subvolume

  $EXEC [OPTS] --snapshot [PREFIX] MOUNTPOINT [MOUNTPOINT MOUNTPOINT ..]
    for each MOUNTPOINT, make a read-only snapshot with the given --prefix=PREFIX
      -get SNAPSHOT name:
        $SUBVOL_CONTAINER/<PREFIX>/<PREFIX>_<$SUBVOL_DATETIME_FORMAT>_<MILLIS>
      -create snapshot, as in:
        [ipmagic IPMAGIC_NAME] btrfs subvol snapshot -r MOUNTPOINT MOUNTPOINT/SNAPSHOT

  $EXEC [OPTS] --snapshot-src [PREFIX] BACKUP_NAME [BACKUP_NAME BACKUP_NAME]
   -for each BACKUP_NAME
     -fetch SRC_MOUNTPOINT from BACKUP_CONF_FILE ($BACKUP_CONF_FILE)
     -disregard --ipmagic and IPMAGIC_NAME (create snapshot locally)
     -make a read-only snapshot for SRC_MOUNTPOINT with the given --prefix=PREFIX
      -get SNAPSHOT name:
        $SUBVOL_CONTAINER/<PREFIX>/<PREFIX>_<$SUBVOL_DATETIME_FORMAT>_<MILLIS>
      -create snapshot, as in:
        btrfs subvol snapshot -r SRC_MOUNTPOINT SRC_MOUNTPOINT/SNAPSHOT

  $EXEC [OPTS] --snapshot-dest [PREFIX] BACKUP_NAME [BACKUP_NAME BACKUP_NAME]
   -for each BACKUP_NAME
     -fetch IPMAGIC_NAME and DEST_MOUNTPOINT from BACKUP_CONF_FILE ($BACKUP_CONF_FILE)
     -make a read-only snapshot for DEST_MOUNTPOINT with the given --prefix=PREFIX
      -get SNAPSHOT name:
        $SUBVOL_CONTAINER/<PREFIX>/<PREFIX>_<$SUBVOL_DATETIME_FORMAT>_<MILLIS>
      -create snapshot, as in:
        [ipmagic IPMAGIC_NAME] btrfs subvol snapshot -r DEST_MOUNTPOINT DEST_MOUNTPOINT/SNAPSHOT

  $EXEC [OPTS] --cleanup [PREFIX] MOUNTPOINT
    find subvols for the given --prefix=PREFIX named:
      $SUBVOL_CONTAINER/<PREFIX>/<PREFIX>_*,
    ensuring that the there are at least SNAPSHOT_COUNT left
      (see --keep-snapshot-count=SNAPSHOT_COUNT)
    delete the rest with `btrfs subvol delete`

  $EXEC [OPTS] --cleanup-all [PREFIX] MOUNTPOINT
    same as: $EXEC [OPTS] --remove-all-snapshots --cleanup [PREFIX] MOUNTPOINT
  $EXEC [OPTS] --cleanup=SNAPSHOT_COUNT [PREFIX] MOUNTPOINT
    same as: $EXEC [OPTS] --keep-snapshot-count=SNAPSHOT_COUNT --cleanup [PREFIX] MOUNTPOINT

  $EXEC [OPTS] --delete MOUNTPOINT SUBVOL [SUBVOL SUBVOL ..]
    remove snapshots named SUBVOL
      -delete snapshots and qgroups for each subvol, as in:
        [ipmagic IPMAGIC_NAME] btrfs subvol delete MOUNTPOINT/SUBVOL

  $EXEC [OPTS] --info MOUNTPOINT
    show all btrfs subvolumes and data usage (requires quotas enabled)
    optionally re-enable and rescan btrfs quotas
      -if --info-rescan is given:
        -disable quotas (if enabled), as in:
          [ipmagic IPMAGIC_NAME] btrfs quota disable MOUNTPOINT
        -enable quotas, as in:
          [ipmagic IPMAGIC_NAME] btrfs quota enable MOUNTPOINT
        -rescan quotas, as in:
          [ipmagic IPMAGIC_NAME] btrfs quota rescan <path>
      -get and print subvolume usage info, as in:
          [ipmagic IPMAGIC_NAME] btrfs qgroup show MOUNTPOINT

  $EXEC --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion, one per line
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline

  OPTS
    --ipmagic=IPMAGIC_NAME
      use `ipmagic IPMAGIC_NAME` for remote operations, overriding backup conf
      if IPMAGIC_NAME is the empty string:
        never use `ipmagic`, and perform all operations
      if --ipmagic arg is not given:
        use IPMAGIC_NAME from the backup conf for the BACKUP_NAME
    --local
      never use `ipmagic` for any remote operations
      synonym for --ipmagic=\"\"

    --prefix=PREFIX
      (default is '$DEFAULT_PREFIX_NAME')
      use snapshots named:
        $SUBVOL_CONTAINER/<PREFIX>/<PREFIX>_<$SUBVOL_DATETIME_FORMAT>_<MILLIS>
      PREFIX must contain only letters/numbers/underscores

    PREFIX
      one of the built-in prefix names: $OK_PREFIX_NAMES
      same as: --prefix=PREFIX

    --keep-snapshot-count=SNAPSHOT_COUNT
      number of instances to keep in --cleanup
      SNAPSHOT_COUNT is a positive integer (use --remove-all-snapshots for 0)
      (default is $DEFAULT_KEEP_SNAPSHOT_COUNT)

    --auto-cleanup=SNAPSHOT_COUNT | --ac=SNAPSHOT_COUNT
      cleanup snapshots before creating a new one in --snapshot
        -before creating a snapshot in MOUNTPOINT for PREFIX, cleanup as in:
          $EXEC --cleanup=SNAPSHOT_COUNT [PREFIX] MOUNTPOINT

    --remove-all-snapshots
      set SNAPSHOT_COUNT to 0 for --cleanup

    --info-rescan
      disable/enable/rescan btrfs quotas for --info

    --info-sort-by=[$OK_INFO_SORT_BY]
      sort subvolumes listed by --info/--info-quick
      (default is ($DEFAULT_SORT_BY)
        id:   subvol id, smallest first
        path: subvol path, lexicographically
        size: bytes used exclusively by subvol, largest first

  BACKUP_CONF_FILE
    config file:  $BACKUP_CONF_FILE
      -lines containing only empty space are ignored
      -lines starting with '#' are ignored
      -each line must be one of:
        BACKUP_NAME = SRC_MOUNTPOINT => DEST_MOUNTPOINT
        ipmagic.BACKUP_NAME = IPMAGIC_NAME
        uuid.MOUNTPOINT = UUID
      -e.g.:
        pix = /media/PICTURES => /media/BackupDrive
        ipmagic.pix = home-desktop
        uuid./media/PICTURES = 8f9f9b1e-9b2f-11eb-8c15-0711f5e696a9
        uuid./media/BackupDrive = 965d282c-9b2f-11eb-b521-47c0725542a3

  BACKUP_NAME
    backup names can contain only lower-case letters, numbers and underscores
    (uppercase letters are converted to lowercase in cmdline args and BACKUP_CONF_FILE)
";

sub selectIpmagicName($$$);
sub getBackupMountpoints($$);
sub checkBackupNameUUIDs($$$);
sub checkUUID($$$);

sub backupRsync($$$);

sub backupSendReceive($$$;$);
sub sendReceive($$$$$);
sub getSyncedSnapshot($$$);
sub makeSnapshot($$$$);
sub getSubvolumes($$);
sub getSubvolumePaths($$);
sub getSubvolumeQuotaInfo($$);
sub formatSubvolumeQuotaInfo($$$);
sub isQuotaEnabled($$);
sub getSnapshots($$$);
sub getLastSnapshot($$$);
sub cleanupSnapshots($$$$);
sub deleteSnapshots($$@);
sub getBtrfsMountDev($$);
sub getMountpoint($$);
sub isMountpoint($$);
sub guessMountpoints();
sub guessSubvolNames($);
sub readBackupConf($);
sub readBackupNames($);

sub sync($);
sub df($$);
sub dfGet($$$);
sub formatDF($);
sub formatBytes($$$$);
sub getUsers();
sub createLogFile($$$);
sub startLogging($);
sub stopLogging($);

sub wrapIpmagicCmd($@);
sub wrapIpmagicHostPath($$);

sub run($@);
sub tryrun($@);
sub readProc($@);
sub readProcLines($@);
sub nowMillis();
sub ensureRoot();

sub bashComplete($$);

sub main(@){
  my $command = undef;
  my @commandArgs;
  my $ipmagicName = undef;
  my $prefix = $DEFAULT_PREFIX_NAME;
  my $keepSnapshotCount = $DEFAULT_KEEP_SNAPSHOT_COUNT;
  my $autoCleanupSnapshotCount = undef;
  my $infoRescan = 0;
  my $infoSortBy = $DEFAULT_SORT_BY;

  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      $command = $COMMAND_HELP;
    }elsif($arg =~ /^(--backup-rsync)$/){
      $command = $COMMAND_BACKUP_RSYNC;
    }elsif($arg =~ /^(--check-uuids)$/){
      $command = $COMMAND_CHECK_UUIDS;
    }elsif($arg =~ /^(--backup-sendreceive)$/){
      $command = $COMMAND_BACKUP_SENDRECEIVE;
    }elsif($arg =~ /^(--sendreceive)$/){
      $command = $COMMAND_SENDRECEIVE;
    }elsif($arg =~ /^(--seed-sendreceive)$/){
      $command = $COMMAND_SEED_SENDRECEIVE;
    }elsif($arg =~ /^(--last-snapshot)$/){
      $command = $COMMAND_LAST_SNAPSHOT;
    }elsif($arg =~ /^(--snapshot)$/){
      $command = $COMMAND_SNAPSHOT;
    }elsif($arg =~ /^(--snapshot-src)$/){
      $command = $COMMAND_SNAPSHOT_SRC;
    }elsif($arg =~ /^(--snapshot-dest)$/){
      $command = $COMMAND_SNAPSHOT_DEST;
    }elsif($arg =~ /^(--cleanup)$/){
      $command = $COMMAND_CLEANUP;
    }elsif($arg =~ /^--cleanup-all$/){
      $command = $COMMAND_CLEANUP;
      $keepSnapshotCount = 0;
    }elsif($arg =~ /^--cleanup=([1-9]\d*)$/){
      $command = $COMMAND_CLEANUP;
      $keepSnapshotCount = $1;
    }elsif($arg =~ /^(--delete)$/){
      $command = $COMMAND_DELETE;
    }elsif($arg =~ /^(--info)$/){
      $command = $COMMAND_INFO;
    }elsif($arg =~ /^(--bash-complete)$/){
      $command = $COMMAND_BASH_COMPLETE;
    }elsif($arg =~ /^--ipmagic=(.*)$/){
      $ipmagicName = $1;
    }elsif($arg =~ /^(--local)$/){
      $ipmagicName = "";
    }elsif($arg =~ /^--prefix=(\w+)$/){
      $prefix = $1;
    }elsif($arg =~ /^($OK_PREFIX_NAMES)$/){
      $prefix = $1;
    }elsif($arg =~ /^--keep-snapshot-count=([1-9]\d*)$/){
      $keepSnapshotCount = $1;
    }elsif($arg =~ /^(?:--auto-cleanup|--ac)=([1-9]\d*)$/){
      $autoCleanupSnapshotCount = $1;
    }elsif($arg =~ /^(--remove-all-snapshots)$/){
      $keepSnapshotCount = 0;
    }elsif($arg =~ /^(--info-rescan)$/){
      $infoRescan = 1;
    }elsif($arg =~ /^--info-sort-by=($OK_INFO_SORT_BY)$/){
      $infoSortBy = $1;
    }elsif($arg !~ /^-/){
      push @commandArgs, $arg;
    }else{
      die "ERROR: unknown arg \"$arg\"\n";
    }
  }

  $command = $COMMAND_BACKUP_RSYNC if not defined $command;

  if($command eq $COMMAND_HELP){
    print $USAGE;
    exit 0;
  }elsif($command eq $COMMAND_BACKUP_RSYNC){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 1 and @commandArgs != 2;
    my ($backupName) = @commandArgs if @commandArgs == 1;
    my ($srcMountpoint, $destMountpoint) = @commandArgs if @commandArgs == 2;
    $backupName = lc $backupName if defined $backupName;
    if(defined $backupName and $backupName !~ /^[a-z0-9_]+$/){
      die "ERROR: BACKUP_NAME can contain only lowercase-letters/numbers/underscores\n";
    }
    ensureRoot();

    if(defined $backupName){
      my $conf = readBackupConf($BACKUP_CONF_FILE);
      $ipmagicName = selectIpmagicName($conf, $ipmagicName, $backupName);
      ($srcMountpoint, $destMountpoint) = getBackupMountpoints($conf, $backupName);
      checkBackupNameUUIDs($ipmagicName, $conf, $backupName);
    }

    backupRsync($ipmagicName, $srcMountpoint, $destMountpoint);
  }elsif($command eq $COMMAND_CHECK_UUIDS){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 1;
    my ($backupName) = @commandArgs;
    $backupName = lc $backupName if defined $backupName;
    if(defined $backupName and $backupName !~ /^[a-z0-9_]+$/){
      die "ERROR: BACKUP_NAME can contain only lowercase-letters/numbers/underscores\n";
    }
    ensureRoot();

    my $conf = readBackupConf($BACKUP_CONF_FILE);
    $ipmagicName = selectIpmagicName($conf, $ipmagicName, $backupName);
    checkBackupNameUUIDs($ipmagicName, $conf, $backupName);
    print "UUIDs match\n";
  }elsif($command eq $COMMAND_BACKUP_SENDRECEIVE){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 1 and @commandArgs != 2;
    my ($backupName) = @commandArgs if @commandArgs == 1;
    my ($srcMountpoint, $destMountpoint) = @commandArgs if @commandArgs == 2;
    $backupName = lc $backupName if defined $backupName;
    if(defined $backupName and $backupName !~ /^[a-z0-9_]+$/){
      die "ERROR: BACKUP_NAME can contain only lowercase-letters/numbers/underscores\n";
    }
    ensureRoot();

    if(defined $backupName){
      my $conf = readBackupConf($BACKUP_CONF_FILE);
      $ipmagicName = selectIpmagicName($conf, $ipmagicName, $backupName);
      ($srcMountpoint, $destMountpoint) = getBackupMountpoints($conf, $backupName);
      checkBackupNameUUIDs($ipmagicName, $conf, $backupName);
    }

    my $syncedSnapshot = getSyncedSnapshot($ipmagicName, $srcMountpoint, $destMountpoint);
    my $newSnapshot = makeSnapshot(undef, nowMillis(), $srcMountpoint, "BACKUP");

    sync(undef);

    sendReceive $ipmagicName, $srcMountpoint, $destMountpoint, $newSnapshot, $syncedSnapshot;
    sync($ipmagicName);
  }elsif($command eq $COMMAND_SENDRECEIVE){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 3 and @commandArgs != 4;
    my ($srcMountpoint, $destMountpoint, $snapshot, $parentSnapshot) = @commandArgs;
    ensureRoot();

    sendReceive $ipmagicName, $srcMountpoint, $destMountpoint, $snapshot, $parentSnapshot;
  }elsif($command eq $COMMAND_SEED_SENDRECEIVE){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 2;
    my ($srcMountpoint, $destMountpoint) = @commandArgs;
    ensureRoot();

    my $newSnapshot = makeSnapshot(undef, nowMillis(), $srcMountpoint, "BACKUP");
    sendReceive $ipmagicName, $srcMountpoint, $destMountpoint, $newSnapshot, undef;
  }elsif($command eq $COMMAND_LAST_SNAPSHOT){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 1;
    my ($mountpoint) = @commandArgs;
    ensureRoot();

    $mountpoint =~ s/\/$//;
    die "not a dir: $mountpoint\n" if not tryrun($ipmagicName, "test", "-d", "$mountpoint");

    my $snapshot = getLastSnapshot($ipmagicName, $mountpoint, $prefix);
    print "$snapshot\n";
  }elsif($command eq $COMMAND_SNAPSHOT){
    die "$USAGE\nbad args to $command\n" if @commandArgs < 1;
    my @mountpoints = @commandArgs;
    ensureRoot();

    my $summary = "";

    for my $mountpoint(@mountpoints){
      print "\n\n====$mountpoint====\n";

      my $deletedCount = 0;
      if(defined $autoCleanupSnapshotCount){
        my @deleted = cleanupSnapshots(
          $ipmagicName, $mountpoint, $prefix, $autoCleanupSnapshotCount);
        $deletedCount = @deleted;
        print "\n";
      }

      my $snapshot = makeSnapshot($ipmagicName, nowMillis(), $mountpoint, $prefix);
      sync($ipmagicName);
      $summary .= sprintf "%-15s - created %s (deleted %d)\n",
        $mountpoint, $snapshot, $deletedCount;
    }

    print "\n\n$summary";
  }elsif($command eq $COMMAND_SNAPSHOT_SRC){
    die "$USAGE\nbad args to $command\n" if @commandArgs < 1;
    my @backupNames = @commandArgs;
    @backupNames = map {lc $_} @backupNames;
    ensureRoot();

    my $conf = readBackupConf($BACKUP_CONF_FILE);
    my $summary = "";

    for my $backupName(@backupNames){
      print "\n\n====$backupName====\n";

      my ($srcMountpoint, $destMountpointUnused) = getBackupMountpoints($conf, $backupName);
      my $deletedCount = 0;
      if(defined $autoCleanupSnapshotCount){
        my @deleted = cleanupSnapshots(
          undef, $srcMountpoint, $prefix, $autoCleanupSnapshotCount);
        $deletedCount = @deleted;
        print "\n";
      }

      my $snapshot = makeSnapshot(undef, nowMillis(), $srcMountpoint, $prefix);
      sync(undef);
      $summary .= sprintf "%-15s - created %s (deleted %d)\n",
        $srcMountpoint, $snapshot, $deletedCount;
    }

    print "\n\n$summary";
  }elsif($command eq $COMMAND_SNAPSHOT_DEST){
    die "$USAGE\nbad args to $command\n" if @commandArgs < 1;
    my @backupNames = @commandArgs;
    @backupNames = map {lc $_} @backupNames;
    ensureRoot();

    my $conf = readBackupConf($BACKUP_CONF_FILE);
    my $summary = "";

    for my $backupName(@backupNames){
      print "\n====$backupName====\n";

      my ($srcMountpointUnused, $destMountpoint) = getBackupMountpoints($conf, $backupName);
      my $destIpmagicName = selectIpmagicName($conf, $ipmagicName, $backupName);
      my $deletedCount = 0;
      if(defined $autoCleanupSnapshotCount){
        my @deleted = cleanupSnapshots(
          $destIpmagicName, $destMountpoint, $prefix, $autoCleanupSnapshotCount);
        $deletedCount = @deleted;
        print "\n";
      }

      my $snapshot = makeSnapshot($destIpmagicName, nowMillis(), $destMountpoint, $prefix);
      sync($destIpmagicName);
      $summary .= sprintf "%-15s - created %s (deleted %d)\n",
        $destMountpoint, $snapshot, $deletedCount;
    }

    print "\n\n$summary";
  }elsif($command eq $COMMAND_CLEANUP){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 1;
    my ($mountpoint) = @commandArgs;
    ensureRoot();

    cleanupSnapshots $ipmagicName, $mountpoint, $prefix, $keepSnapshotCount;
  }elsif($command eq $COMMAND_DELETE){
    die "$USAGE\nbad args to $command\n" if @commandArgs < 2;
    my ($mountpoint, @subvols) = @commandArgs;
    ensureRoot();

    deleteSnapshots $ipmagicName, $mountpoint, @subvols;
  }elsif($command eq $COMMAND_INFO){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 1;
    my ($mountpoint) = @commandArgs;
    ensureRoot();

    my $fsSizeBytes = dfGet($ipmagicName, $mountpoint, $DF_SIZE_BYTES);

    if($infoRescan){
      print "(re-)enabling quota and rescanning:\n";
      run $ipmagicName, "btrfs quota disable \"$mountpoint\"";
      run $ipmagicName, "btrfs quota enable \"$mountpoint\"";
      run $ipmagicName, "btrfs quota rescan -w \"$mountpoint\"";
    }

    if(not isQuotaEnabled($ipmagicName, $mountpoint)){
      die "ERROR: btrfs quota is not enabled for $mountpoint\n";
    }

    my $info = getSubvolumeQuotaInfo($ipmagicName, $mountpoint);

    print formatSubvolumeQuotaInfo($fsSizeBytes, $info, $infoSortBy);
  }elsif($command eq $COMMAND_BASH_COMPLETE){
    die "$USAGE\nbad args to $command\n" if @commandArgs != 2;
    my ($cmdLine, $pos) = @commandArgs;

    print map {"$_\n"} bashComplete($cmdLine, $pos);
  }else{
    die "$USAGE\nERROR: unknown command $command\n";
  }
}

sub selectIpmagicName($$$){
  my ($conf, $ipmagicNameArg, $backupName) = @_;
  if(defined $ipmagicNameArg){
    return $ipmagicNameArg eq "" ? undef : $ipmagicNameArg;
  }elsif(defined $$conf{IPMAGIC_NAMES}{$backupName}){
    return $$conf{IPMAGIC_NAMES}{$backupName};
  }else{
    return undef;
  }
}

sub getBackupMountpoints($$){
  my ($conf, $backupName) = @_;
  if(not defined $$conf{BACKUPS}{$backupName}){
    die "ERROR: $backupName missing from $BACKUP_CONF_FILE\n";
  }

  my $srcMountpoint = $$conf{BACKUPS}{$backupName}{SRC_MOUNTPOINT};
  my $destMountpoint = $$conf{BACKUPS}{$backupName}{DEST_MOUNTPOINT};
  return ($srcMountpoint, $destMountpoint);
}

sub checkBackupNameUUIDs($$$){
  my ($ipmagicName, $conf, $backupName) = @_;

  my ($srcMountpoint, $destMountpoint) = getBackupMountpoints($conf, $backupName);
  my $srcUUID = $$conf{UUIDS}{$srcMountpoint};
  my $destUUID = $$conf{UUIDS}{$destMountpoint};
  die "ERROR: missing SRC_UUID for $srcMountpoint\n" if not defined $srcUUID;
  die "ERROR: missing DEST_UUID for $destMountpoint\n" if not defined $destUUID;

  checkUUID(undef, $srcMountpoint, $srcUUID);
  checkUUID($ipmagicName, $destMountpoint, $destUUID);
  print "\nUUIDs match for $srcMountpoint and $destMountpoint\n";
}

sub checkUUID($$$){
  my ($ipmagicName, $expectedMountpoint, $uuid) = @_;
  my $blkDev = "/dev/disk/by-uuid/$uuid";
  if(not tryrun($ipmagicName, "test", "-e", $blkDev)){
    die "ERROR: could not find $blkDev for $expectedMountpoint\n";
  }
  my $actualMountpoint = getMountpoint($ipmagicName, $blkDev);

  if($actualMountpoint ne $expectedMountpoint){
    die "ERROR: $blkDev is not mounted at $expectedMountpoint (actual: \"$actualMountpoint\")\n";
  }
}

sub backupRsync($$$){
  my ($ipmagicName, $srcMountpoint, $destMountpoint) = @_;

  print "\n\nCREATING SRC SNAPSHOT\n";
  my $timeMillis = nowMillis();
  my $newSrcSnapshot = makeSnapshot(undef, $timeMillis, $srcMountpoint, "BACKUP");

  my $src = "$srcMountpoint/$newSrcSnapshot";
  my $dest = wrapIpmagicHostPath($ipmagicName, "$destMountpoint");

  my $logFile = createLogFile($newSrcSnapshot, $srcMountpoint, "rsync");
  print "\n";
  print "LOGS: $logFile\n";
  print "\n";

  my $logHandle = startLogging($logFile);

  my $srcDF = df(undef, $srcMountpoint);
  my $destDFStart = df($ipmagicName, $destMountpoint);

  print "INITIAL DF:\n";
  print formatDF($srcDF) . " (initial)" . "\n";
  print formatDF($destDFStart) . " (initial)" . "\n";
  print "\n";

  my $rsyncStartMillis = nowMillis();
  run undef, "rsync", "-avP", "--del", "$src/", "$dest/", "--exclude=$SUBVOL_CONTAINER";
  my $rsyncEndMillis = nowMillis();
  printf "  elapsed: %s\n", formatMillisHHMMSSFFF($rsyncEndMillis - $rsyncStartMillis);
  print "\n";

  my $syncStartMillis = nowMillis();
  sync($ipmagicName);
  my $syncEndMillis = nowMillis();
  printf "  elapsed: %s\n", formatMillisHHMMSSFFF($syncEndMillis - $syncStartMillis);
  print "\n";

  my $destDFEnd = df($ipmagicName, $destMountpoint);

  print "FINAL DF:\n";
  print formatDF($srcDF) . " (initial)" . "\n";
  print formatDF($destDFStart) . " (initial)" . "\n";
  print formatDF($destDFEnd) . " (final)" . "\n";
  print "\n";

  stopLogging($logHandle);

  print "\n\nCREATING DEST SNAPSHOT\n";
  makeSnapshot($ipmagicName, $timeMillis, $destMountpoint, "BACKUP");

  run undef, "date";
}

sub backupSendReceive($$$;$){
  my ($ipmagicName, $srcMountpoint, $destMountpoint, $seed) = @_;
  $srcMountpoint =~ s/\/$//;
  $destMountpoint =~ s/\/$//;

  if(not defined getBtrfsMountDev(undef, $srcMountpoint)){
    die "$srcMountpoint is not btrfs\n";
  }elsif(not defined getBtrfsMountDev($ipmagicName, $destMountpoint)){
    die "$destMountpoint is not btrfs\n";
  }

  my $syncedSnapshot;
  if(defined $seed and $seed){
    $syncedSnapshot = undef;
  }else{
    $syncedSnapshot = getSyncedSnapshot($ipmagicName, $srcMountpoint, $destMountpoint);
  }

  my $newSnapshot = makeSnapshot(undef, nowMillis(), $srcMountpoint, "BACKUP");

  sync(undef);

  sendReceive $ipmagicName, $srcMountpoint, $destMountpoint, $newSnapshot, $syncedSnapshot;

  sync($ipmagicName);
}

sub sendReceive($$$$$){
  my ($ipmagicName, $sendMountpoint, $receiveMountpoint, $snapshotName, $parentSnapshotName) = @_;

  my $destDir = $snapshotName;
  $destDir =~ s/([^\/]*)$//;
  $destDir = "$receiveMountpoint/$destDir";

  my $parentArg = '';
  if(defined $parentSnapshotName){
    $parentArg = "-p \"$sendMountpoint/$parentSnapshotName\"";
  }

  if(not tryrun($ipmagicName, "test", "-d", "$receiveMountpoint")){
    die "ERROR: dir does not exist on dest: $receiveMountpoint\n";
  }
  if(tryrun($ipmagicName, "test", "-e", "$receiveMountpoint/$snapshotName")){
    die "ERROR: snapshot exists on dest already: $receiveMountpoint/$snapshotName\n";
  }

  run $ipmagicName, "mkdir -p $destDir";

  my $infoLog = createLogFile($snapshotName, $sendMountpoint, "btrfs-info");
  my $pvLog = createLogFile($snapshotName, $sendMountpoint, "btrfs-send-pv");
  my $rcvLog = createLogFile($snapshotName, $sendMountpoint, "btrfs-rcv");
  print "\nLOGS: $infoLog $pvLog $rcvLog\n";

  my @btrfsRemoteCmd = wrapIpmagicCmd($ipmagicName, "btrfs");

  my $dateFmt = `date`;
  chomp $dateFmt;
  print "\n";

  my $startMillis = nowMillis();
  my $startDF = readProc $ipmagicName, "df", $receiveMountpoint;

  run undef, "bash", "-c", "time ( "
    . " btrfs send $parentArg \"$sendMountpoint/$snapshotName\""
    . " | "
    . " pv -r -a -t -b -f 2> >(tee $pvLog 1>&2)"
    . " | "
    . " @btrfsRemoteCmd receive -v -v \"$destDir\" 2> >(tee $rcvLog 1>&2)"
    . " )"
    ;

  my $endMillis = nowMillis();
  my $endDF = readProc $ipmagicName, "df", $receiveMountpoint;

  open FH, "> $infoLog" or die "ERROR: could not write to $infoLog\n$!\n";
  printf FH "%s\nelapsed: %s\n\nINITIAL DF:\n%s\nFINAL DF:\n%s\n",
    $dateFmt, formatMillisHHMMSSFFF($endMillis - $startMillis), $startDF, $endDF;
  close FH;

  print "\nLOGS: $infoLog $pvLog $rcvLog\n";
  print "\n";
  run undef, "cat", $pvLog;
  print "\n";

  if(not tryrun($ipmagicName, "test", "-d", "$receiveMountpoint/$snapshotName")){
    die "snapshot send/receive failed: $receiveMountpoint/$snapshotName\n";
  }
}

sub getSyncedSnapshot($$$){
  my ($ipmagicName, $srcMountpoint, $destMountpoint) = @_;
  $srcMountpoint =~ s/\/$//;
  $destMountpoint =~ s/\/$//;

  my $lastSrc = getLastSnapshot(undef, $srcMountpoint, "BACKUP");
  my $lastDest = getLastSnapshot($ipmagicName, $destMountpoint, "BACKUP");

  if($lastSrc ne $lastDest){
    die "Mismatched last snapshot:\n$srcMountpoint/$lastSrc\n$destMountpoint/$lastDest\n";
  }
  return $lastSrc;
}

sub makeSnapshot($$$$){
  my ($ipmagicName, $timestampMillis, $mountpoint, $prefix) = @_;

  my $epoch = int($timestampMillis / 1000.0 + 0.5);
  my $dateTime = `date --date=\@$epoch +$SUBVOL_DATETIME_FORMAT`;
  chomp $dateTime;

  $mountpoint =~ s/\/+$//;
  die "not a dir: $mountpoint\n" if not tryrun($ipmagicName, "test", "-d", $mountpoint);
  die "not a mountpoint: $mountpoint\n" if not isMountpoint($ipmagicName, $mountpoint);

  my $parentDir = "$SUBVOL_CONTAINER/$prefix";
  run $ipmagicName, "mkdir", "-p", "$mountpoint/$parentDir";

  my $snapshotName = "${prefix}_${dateTime}_${timestampMillis}";

  my $snapshot = "$parentDir/$snapshotName";
  my $snapshotDir = "$mountpoint/$snapshot";

  die "$snapshotDir already exists!\n" if tryrun($ipmagicName, "test", "-e", $snapshotDir);
  run $ipmagicName, "btrfs", "subvolume", "snapshot", "-r", $mountpoint, $snapshotDir;

  my $latestSymlink = "$mountpoint/$parentDir/latest";

  run $ipmagicName, "rm", "-f", $latestSymlink;
  run $ipmagicName, "ln", "-s", $snapshotName, $latestSymlink;

  if($snapshot ne getLastSnapshot($ipmagicName, $mountpoint, $prefix)){
    die "ERROR: snapshot on $mountpoint failed\n";
  }

  return $snapshot;
}

sub getSubvolumes($$){
  my ($ipmagicName, $mountpoint) = @_;
  my @subvolLines = readProcLines($ipmagicName,
    "btrfs", "subvolume", "list", $mountpoint);
  my $subs = {};
  for my $subLine(@subvolLines){
    if($subLine =~ /ID (\d+) gen (\d+) top level (\d+) path (.*)$/){
      my ($id, $gen, $level, $path) = ($1, $2, $3, $4);
      $$subs{$id} = $path;
    }else{
      die "malformed subvolume line: $subLine\n";
    }
  }
  return $subs;
}
sub getSubvolumePaths($$){
  my ($ipmagicName, $mountpoint) = @_;
  my $subs = getSubvolumes($ipmagicName, $mountpoint);
  my $paths = [];
  for my $id(sort {$a <=> $b} keys %$subs){
    push @$paths, $$subs{$id};
  }
  return $paths;
}

sub getSubvolumeQuotaInfo($$){
  my ($ipmagicName, $mountpoint) = @_;

  my @qgroupLines = readProcLines($ipmagicName,
    "btrfs", "qgroup", "show", "--raw", $mountpoint);
  die "invalid output from qgroup show on $mountpoint" if 0
    or @qgroupLines < 3
    or $qgroupLines[0] !~ /^\s*qgroupid\s*rfer\s*excl\s*$/
    or $qgroupLines[1] !~ /^\s*-+\s*-+\s*-+\s*$/
    ;
  shift @qgroupLines; #qgroupid         rfer         excl
  shift @qgroupLines; #--------         ----         ----

  my $subs = getSubvolumes($ipmagicName, $mountpoint);
  my $root = undef;

  my $info = {};
  for my $qgroup(@qgroupLines){
    if($qgroup !~ /^\s*0\/(\d+)\s*(-?\d+)\s*(\d+)/){
      die "Malformed qgroup: $qgroup\n";
    }
    my($subId, $total, $excl) = ($1, $2, $3);
    if(not defined $root and not defined $$subs{$subId}){
      $root = $subId;
      $$subs{$subId} = "root";
    }

    if(not defined $$subs{$subId}){
      print STDERR "WARNING: unknown subvolume $subId\n";
      next;
    }
    die "duplicated subvolume: $subId\n" if defined $$info{$subId};

    $$info{$subId} = {
      path  => $$subs{$subId},
      total => $total,
      excl  => $excl,
    };
  }

  for my $subId(sort keys %$subs){
    if(not defined $$info{$subId}){
      print STDERR "WARNING: missing qgroup for $subId {maybe deleted?)\n";
    }
  }

  return $info;
}

sub formatSubvolumeQuotaInfo($$$){
  my ($fsSize, $info, $sortBy) = @_;
  my $s = '';

  my $sortFcts = {
    id   => sub($$){$_[0] <=> $_[1]},
    size => sub($$){$$info{$_[1]}{excl} <=> $$info{$_[0]}{excl}},
    path => sub($$){$$info{$_[0]}{path} cmp $$info{$_[1]}{path}},
  };

  my $sortFct = $$sortFcts{$sortBy};
  die "unknown sort function: $sortBy\n" if not defined $sortFct;

  my $maxPathLen = 0;
  for my $subId(sort $sortFct (keys %$info)){
    my $len = length $$info{$subId}{path};
    $maxPathLen = $len if $len > $maxPathLen;
  };

  for my $subId(sort $sortFct (keys %$info)){
    my $path = $$info{$subId}{path};
    $path = sprintf "%-${maxPathLen}s", $path;

    my $size = $$info{$subId}{excl};
    $size /= 1024;
    $size = sprintf '%10d', $size;

    my $pct = 100 * ($$info{$subId}{excl} / $fsSize);
    $pct = sprintf '%7.3f', $pct;

    $s .= "$path ${size}KiB $pct\%\n";
  }

  return $s;
}

sub isQuotaEnabled($$){
  my ($ipmagicName, $mountpoint) = @_;
  my $qgroupShowOut = readProc($ipmagicName,
    "btrfs qgroup show \"$mountpoint\" 2>&1");
  if($qgroupShowOut =~ /^qgroupid\s*rfer\s*excl\s*\n/){
    return 1;
  }else{
    return 0;
  }
}

sub getSnapshots($$$){
  my ($ipmagicName, $dir, $prefix) = @_;
  my @subs = @{getSubvolumePaths($ipmagicName, $dir)};
  @subs = grep {/
     ^  ${SUBVOL_CONTAINER}\/
        ${prefix}\/
        ${prefix}_${DATE_TIME_REGEX}_${EPOCH_MILLIS_REGEX}
     $
  /x} @subs;

  my @sortedSubs = sort @subs;
  for(my $i=0; $i<@subs; $i++){
    if($subs[$i] ne $sortedSubs[$i]){
      my $msg = "\n\nWARNING: snapshots are out of order {ID versus date}\n";
      $msg .= "  $subs[$i] vs $sortedSubs[$i]\n";
      $msg .= "  (using date order)\n";
      print STDERR "$msg\n";
      last;
    }
  }
  @subs = @sortedSubs;

  for my $sub(@subs){
    die "$dir/$sub is not a dir\n" if not tryrun($ipmagicName, "test", "-d", "$dir/$sub");
  }

  return @subs;
}

sub getLastSnapshot($$$){
  my ($ipmagicName, $dir, $prefix) = @_;
  die "ERROR: not a dir \"$dir\"\n" if not tryrun($ipmagicName, "test", "-d", $dir);

  my @subs = getSnapshots $ipmagicName, $dir, $prefix;
  die "no '$prefix' snapshot found for $dir\n" if @subs == 0;
  my $lastSub = $subs[-1];

  die "Malformed snapshot: $lastSub\n" if $lastSub !~ /
    ^ ${SUBVOL_CONTAINER}\/
      ${prefix}\/
      ${prefix}_${DATE_TIME_REGEX}_${EPOCH_MILLIS_REGEX}
    $
  /x;
  return $lastSub;
}

sub cleanupSnapshots($$$$){
  my ($ipmagicName, $mountpoint, $prefix, $keepSnapshotCount) = @_;
  my @subs = getSnapshots($ipmagicName, $mountpoint, $prefix);

  my @toKeep;
  my @toDelete;
  my @revsubs = reverse sort @subs;
  @toKeep = grep {defined} reverse @revsubs[0 .. $keepSnapshotCount-1];
  @toDelete = grep {defined} reverse @revsubs[$keepSnapshotCount .. $#revsubs];

  print "to keep (" . scalar(@toKeep) . "):\n ";
  print join "\n ", @toKeep;
  print "\n\n";
  print "to delete (" . scalar(@toDelete) . "):\n ";
  print join "\n ", @toDelete;
  print "\n\n";

  if(@toKeep == 0 and @toDelete > 0){
    print "DELETING ALL THESE SNAPSHOTS\n";
    print "ok? [Y/n] ";
    my $ok = <STDIN>;
    if($ok =~ /n/i){
      die "user cancelled\n";
    }
  }

  if(@toDelete > 0){
    deleteSnapshots $ipmagicName, $mountpoint, @toDelete;
  }
  if(@toKeep == 0){
    my $latestSymlink = "$mountpoint/$SUBVOL_CONTAINER/$prefix/latest";
    tryrun $ipmagicName, "rm", $latestSymlink;

    my $prefixDir = "$mountpoint/$SUBVOL_CONTAINER/$prefix";
    tryrun $ipmagicName, "rmdir", $prefixDir;
  }

  return @toDelete;
}

sub deleteSnapshots($$@){
  my ($ipmagicName, $mountpoint, @toDelete) = @_;

  @toDelete = map {s/\/$//; $_} @toDelete;

  my $subvolumes = getSubvolumes $ipmagicName, $mountpoint;
  my %subIds = map {$$subvolumes{$_} => $_} keys %$subvolumes;

  for my $sub(@toDelete){
    die "MISSING SNAPSHOT: $sub\n" if not tryrun($ipmagicName, "test", "-d", "$mountpoint/$sub");
    die "SUBVOLUME ID NOT FOUND: $sub\n" if not defined $subIds{$sub};
  }

  my @pathsToDelete = map {"$mountpoint/$_"} @toDelete;
  my @qgroupsToDelete = map {"0/$subIds{$_}"} @toDelete;
  run $ipmagicName, "btrfs", "subvolume", "delete", @pathsToDelete;
  if(isQuotaEnabled($ipmagicName, $mountpoint)){
    for my $qgroupId(@qgroupsToDelete){
      tryrun $ipmagicName, "btrfs", "qgroup", "destroy", $qgroupId, $mountpoint;
    }
  }
  print "deleted " . scalar(@toDelete) . " subvolumes\n";
  sync($ipmagicName);
}

sub getBtrfsMountDev($$){
  my ($ipmagicName, $dir) = @_;
  my @mountLines = split /\n/, readProc $ipmagicName, "mount";
  for my $line(@mountLines){
    if($line =~ m/^([_a-zA-Z0-9\/\-]+) on $dir type btrfs /){
      return $1;
    }
  }
  return undef;
}

sub getMountpoint($$){
  my ($ipmagicName, $blkDev) = @_;
  my $dir = readProc($ipmagicName, "lsblk", "-n", "-o", "MOUNTPOINT", $blkDev);
  chomp $dir;
  if(not tryrun($ipmagicName, "test", "-d", $dir)){
    die "ERROR: $dir is not a dir\n";
  }
  return $dir;
}

sub isMountpoint($$){
  my ($ipmagicName, $dir) = @_;
  my $out = readProc($ipmagicName, "mountpoint", $dir);
  if($out =~ /is a mountpoint$/){
    return 1;
  }elsif($out =~ /is not a mountpoint$/){
    return 0;
  }else{
    die "malformed output of 'mountpoint' command: $out\n";
  }
}

sub guessMountpoints(){
  my @mountLines = split /\n/, `mount 2>/dev/null`;
  my @mountpoints;
  for my $line(@mountLines){
    if($line =~ /^\S+ on (.+) type (ext4|btrfs)/){
      push @mountpoints, $1;
    }
  }
  return @mountpoints;
}
sub guessSubvolNames($){
  my ($mountpoint) = @_;
  $mountpoint =~ s/'/'\\''/g;
  my @subs = readProc(undef, "ls -d '$mountpoint'/$SUBVOL_CONTAINER/*/* 2>/dev/null");
  my %subvolNames;
  for my $sub(@subs){
    if($sub =~ /
      ^
      (?:.*\/)?
      (${SUBVOL_CONTAINER}\/\w+\/\w+_${DATE_TIME_REGEX}_${EPOCH_MILLIS_REGEX})
      $
    /){
      $subvolNames{$1} = 1;
    }
  }
  return sort keys %subvolNames;
}

sub readBackupConf($){
  my ($confFile) = @_;

  my $conf = {
    BACKUPS       => {},
    IPMAGIC_NAMES => {},
    UUIDS         => {},
  };

  if(not -f $confFile){
    return $conf;
  }

  open FH, "< $confFile" or die "ERROR: could not read $confFile\n$!\n";
  my @lines = <FH>;
  close FH;

  my $hex4 = "[0-9a0-f]{4}";
  my $hex8 = "[0-9a0-f]{8}";
  my $hex12 = "[0-9a0-f]{12}";

  for my $line(@lines){
    if($line =~ /^\s*(?:#.*)?$/){
      next;
    }elsif($line =~ /^ \s* (\w+) \s* = \s* (.*\S) \s* => \s* (.*\S) \s* $/x){
      my ($backupName, $srcMountpoint, $destMountpoint) = ($1, $2, $3);
      $backupName = lc $backupName;
      if(defined $$conf{BACKUPS}{$backupName}){
        print STDERR "WARNING: duplicate BACKUP_NAME $backupName in $confFile\n";
      }
      $$conf{BACKUPS}{$backupName} = {
        SRC_MOUNTPOINT  => $srcMountpoint,
        DEST_MOUNTPOINT => $destMountpoint,
      };
    }elsif($line =~ /^ \s* ipmagic\.(\w+) \s* = \s* (.*\S) \s* $/x){
      my ($backupName, $ipmagicName) = ($1, $2);
      $backupName = lc $backupName;
      if(defined $$conf{IPMAGIC_NAME}{$backupName}){
        print STDERR "WARNING: duplicate IPMAGIC_NAME for $backupName in $confFile\n";
      }
      $$conf{IPMAGIC_NAMES}{$backupName} = $ipmagicName;
    }elsif($line =~ /^ \s* uuid\.(.*\S) \s* = \s* ($hex8-$hex4-$hex4-$hex4-$hex12) \s* $/x){
      my ($mountpoint, $uuid) = ($1, $2);
      if(defined $$conf{UUIDS}{$mountpoint}){
        print STDERR "WARNING: duplicate UUID for $mountpoint in $confFile\n";
      }
      $$conf{UUIDS}{$mountpoint} = $uuid;
    }else{
      print STDERR "WARNING: malformed config line in $confFile - $line\n";
    }
  }

  return $conf;
}
sub readBackupNames($){
  my ($confFile) = @_;
  my $conf = readBackupConf($confFile);
  return sort keys %{$$conf{BACKUPS}};
}

sub sync($){
  my($ipmagicName) = @_;
  run $ipmagicName, "sync";
}

sub df($$){
  my ($ipmagicName, $mountpoint) = @_;
  my $dfOut = readProc $ipmagicName, "df -B1 --output=used,avail,size \"$mountpoint\"";

  my $host;
  if(defined $ipmagicName){
    $host = readProc undef, "ipmagic", $ipmagicName, "--host";
    chomp $host;
  }else{
    $host = "localhost";
  }

  my ($usedBytes, $availBytes, $sizeBytes);
  if($dfOut =~ /^\s*Used\s+Avail\s+\w+-blocks\s*\n\s*(\d+)\s+(\d+)\s+(\d+)\s*$/){
    ($usedBytes, $availBytes, $sizeBytes) = ($1, $2, $3);
  }else{
    die "ERROR: could not parse output of `df` for $mountpoint on $host\n";
  }

  return {
    $DF_USED_BYTES  => $usedBytes,
    $DF_AVAIL_BYTES => $availBytes,
    $DF_SIZE_BYTES  => $sizeBytes,

    $DF_USED_GIB    => formatBytes(0, 3, 3, $usedBytes),
    $DF_AVAIL_GIB   => formatBytes(0, 3, 3, $availBytes),
    $DF_SIZE_GIB    => formatBytes(0, 3, 3, $sizeBytes),

    $DF_PERCENT     => int(($sizeBytes-$availBytes)/$sizeBytes*100.0 + 0.5),
    $DF_MOUNTPOINT  => $mountpoint,
    $DF_HOST        => $host,
  };
}

sub dfGet($$$){
  my ($ipmagicName, $mountpoint, $dfField) = @_;
  my $df = df($ipmagicName, $mountpoint);
  die "ERROR: unknown df field $dfField\n" if not defined $$df{$dfField};
  return $$df{$dfField};
}

sub formatDF($){
  my ($df) = @_;
  return sprintf("%s / %s   %d%%   avail=%db %-22s   %s",
    $$df{$DF_USED_GIB},
    $$df{$DF_SIZE_GIB},
    $$df{$DF_PERCENT},
    $$df{$DF_AVAIL_BYTES},
    $$df{$DF_MOUNTPOINT},
    $$df{$DF_HOST},
  );
}

sub formatBytes($$$$){
  my ($siUnits, $minPower, $maxPower, $bytes) = @_;
  my ($base, @units);
  if($siUnits){
    $base = 10**3;
    @units = qw(B KB MB GB TB PB EB ZB YB);
  }else{
    $base = 2**10;
    @units = qw(B K M G T P E Z Y);
  }

  my $targetPow = 0;
  for(my $pow = 0; $pow < @units; $pow++){
    if($bytes / $base**($pow) >= 1){
      $targetPow = $pow;
    }else{
      last;
    }
  }

  $targetPow = $maxPower if defined $maxPower and $targetPow > $maxPower;
  $targetPow = $minPower if defined $minPower and $targetPow < $minPower;
  $targetPow = @units - 1 if $targetPow > @units - 1;

  return sprintf "%.1f%s",
    $bytes / $base**($targetPow),
    $units[$targetPow];
}

sub getUsers(){
  open FH, "< /etc/passwd" or die "ERROR: could not read /etc/passwd\n$!\n";
  my @lines = <FH>;
  close FH;

  my @users;
  for my $line(@lines){
    push @users, $1 if $line =~ /^(\w+):/;
  }
  return @users;
}

sub createLogFile($$$){
  my ($snapshotName, $mountpoint, $suffix) = @_;

  # format snapshot name, removing subvol container if present
  # e.g.:
  #   SUBVOL/DAILY/DAILY_2016-07-07_08-52-11_1467895931512/
  #     => DAILY_2016-07-07_08-52-11_1467895931512
  #   SUBVOL/DAILY/DAILY_2016-07-07_08-52-11_1467895931512/
  #     => DAILY_2016-07-07_08-52-11_1467895931512
  #   SUBVOL/DAILY/2016-07-07_08-52-11_1467895931512
  #     => DAILY-2016-07-07_08-52-11_1467895931512
  #   -----apple/dapple@@@###/sun---shine-----
  #     => apple-dapple-sun-shine
  my $fmtSnapshot;
  if($snapshotName =~ /^$SUBVOL_CONTAINER\/(\w+)\/([^\/]+)\/?$/){
    my ($prefix, $basename) = ($1, $2);
    if($basename =~ /\Q$prefix\E/){
      $fmtSnapshot = $basename;
    }else{
      $fmtSnapshot = "${prefix}_${basename}";
    }
  }else{
    $fmtSnapshot = $snapshotName;
  }
  $fmtSnapshot =~ s/[^a-zA-Z0-9_\-]+/-/g;
  $fmtSnapshot =~ s/^-+//g;
  $fmtSnapshot =~ s/-+$//g;
  $fmtSnapshot =~ s/--+/-/g;


  # format mountpoint, removing root-level mount container and user if present
  # e.g.:
  #   /home/
  #     => home
  #   /media/BACKUP_FOO
  #     => BACKUP_FOO
  #   /media/johnson/foo
  #     => foo
  #   /media/abc/def/ghi
  #     media-abc-def-ghi
  #   /mnt/----_----FOO-----bar@@@@###---
  #     => _FOO-bar
  my $fmtMountpoint;
  my $usersRegex = join "|", getUsers();
  if($mountpoint =~ /^\/?(mnt|media)\/($usersRegex)\/([^\/]+)\/?/){
    my ($systemMountContainer, $user, $dirname) = ($1, $2, $3);
    $fmtMountpoint = $dirname;
  }elsif($mountpoint =~ /^\/?(mnt|media)\/([^\/]+)\/?/){
    my ($systemMountContainer, $dirname) = ($1, $2);
    $fmtMountpoint = $dirname;
  }else{
    $fmtMountpoint = $mountpoint;
  }
  $fmtMountpoint =~ s/[^a-zA-Z0-9_\-]+/-/g;
  $fmtMountpoint =~ s/^-+//g;
  $fmtMountpoint =~ s/-+$//g;
  $fmtMountpoint =~ s/--+/-/g;


  my $fmtSuffix = $suffix;
  $fmtSuffix =~ s/[^a-zA-Z0-9_\-]+/-/g;
  $fmtSuffix =~ s/^-+//g;
  $fmtSuffix =~ s/-+$//g;
  $fmtSuffix =~ s/--+/-/g;

  my $logFile = "$LOG_DIR/$fmtSnapshot-$fmtMountpoint-$fmtSuffix.log";
  run undef, "mkdir", "-p", $LOG_DIR;
  run undef, "touch", $logFile;
  return $logFile;
}

sub startLogging($){
  my ($logFile) = @_;

  open my $origSTDOUT, ">&STDOUT";
  open my $origSTDERR, ">&STDERR";

  my $logTeePid = open STDOUT, "| tee -a $logFile"
    or die "ERROR: could not redirect stdout to tee $logFile\n$!\n";
  open STDERR, ">&STDOUT"
    or die "ERROR: could not redirect STDERR to STDOUT\n$!\n";

  my $logHandle = {
    origSTDOUT => $origSTDOUT,
    origSTDERR => $origSTDERR,
    logTeePid => $logTeePid,
  };

  return $logHandle;
}
sub stopLogging($){
  my ($logHandle) = @_;
  system "kill", $$logHandle{logTeePid};
  close STDOUT;
  close STDERR;

  open STDOUT, ">&", $$logHandle{origSTDOUT}
    or die "ERROR: could not restore STDOUT\n";
  open STDERR, ">&", $$logHandle{origSTDERR}
    or die "ERROR: could not restore STDERR\n";

  close $$logHandle{origSTDOUT};
  close $$logHandle{origSTDERR};
}

sub wrapIpmagicCmd($@){
  my ($ipmagicName, @cmd) = @_;
  if(defined $ipmagicName and length $ipmagicName > 0){
    return ("ipmagic", $ipmagicName, "-u", "root", @cmd);
  }else{
    return @cmd;
  }
}

sub wrapIpmagicHostPath($$){
  my ($ipmagicName, $path) = @_;
  if(defined $ipmagicName){
    my $host = readProc(undef, "ipmagic", $ipmagicName, "--host");
    chomp $host;
    return "root\@$host:$path";
  }else{
    return $path;
  }
}

sub run($@){
  my ($ipmagicName, @cmd) = @_;
  print join(" ", wrapIpmagicCmd($ipmagicName, @cmd)) . "\n";
  my $ok = tryrun($ipmagicName, @cmd);
  die "ERROR: \"@cmd\" failed\n" if not $ok;
}

sub tryrun($@){
  my ($ipmagicName, @cmd) = @_;
  @cmd = wrapIpmagicCmd($ipmagicName, @cmd);

  system @cmd;
  if($? == 0){
    return 1;
  }else{
    return 0;
  }
}

sub readProc($@){
  my ($ipmagicName, @cmd) = @_;
  return join '', readProcLines($ipmagicName, @cmd);
}
sub readProcLines($@){
  my ($ipmagicName, @cmd) = @_;
  @cmd = wrapIpmagicCmd($ipmagicName, @cmd);

  open CMD, "-|", @cmd or die "ERROR: could not run @cmd\n";
  my @lines = <CMD>;
  close CMD;

  return @lines;
}

sub formatMillisHHMMSSFFF($){
  my ($millis) = @_;
  my $timeS = int($millis / 1000.0 + 0.5);
  my $h = sprintf "%02d", int($timeS / 60 / 60);
  my $m = sprintf "%02d", int($timeS / 60) % 60;
  my $s = sprintf "%02d", int($timeS) % 60;
  my $f = sprintf "%03d", $millis % 1000;
  return "$h:$m:$s.$f";
}

sub nowMillis(){
  return int(time * 1000 + 0.5);
}

sub ensureRoot(){
  if(`whoami` ne "root\n"){
    print STDERR "rerunning as root\n";
    exec "sudo", $0, @ARGV;
  }
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  my $command = undef;
  my @commandArgs;
  while(@words > 0){
    my $arg = shift @words;
    if($arg =~ /^(-h|--help)$/){
      $command = $COMMAND_HELP;
    }elsif($arg =~ /^(--check-uuids)$/){
      $command = $COMMAND_CHECK_UUIDS;
    }elsif($arg =~ /^(--backup-sendreceive)$/){
      $command = $COMMAND_BACKUP_SENDRECEIVE;
    }elsif($arg =~ /^(--sendreceive)$/){
      $command = $COMMAND_SENDRECEIVE;
    }elsif($arg =~ /^(--seed-sendreceive)$/){
      $command = $COMMAND_SEED_SENDRECEIVE;
    }elsif($arg =~ /^(--last-snapshot)$/){
      $command = $COMMAND_LAST_SNAPSHOT;
    }elsif($arg =~ /^(--snapshot)$/){
      $command = $COMMAND_SNAPSHOT;
    }elsif($arg =~ /^(--snapshot-src)$/){
      $command = $COMMAND_SNAPSHOT_SRC;
    }elsif($arg =~ /^(--snapshot-dest)$/){
      $command = $COMMAND_SNAPSHOT_DEST;
    }elsif($arg =~ /^(--cleanup)$/){
      $command = $COMMAND_CLEANUP;
    }elsif($arg =~ /^--cleanup-all$/){
      $command = $COMMAND_CLEANUP;
    }elsif($arg =~ /^--cleanup=([1-9]\d*)$/){
      $command = $COMMAND_CLEANUP;
    }elsif($arg =~ /^(--delete)$/){
      $command = $COMMAND_DELETE;
    }elsif($arg =~ /^(--info)$/){
      $command = $COMMAND_INFO;
    }elsif($arg =~ /^(--bash-complete)$/){
      $command = $COMMAND_BASH_COMPLETE;
    }elsif($arg !~ /^-/){
      push @commandArgs, $arg;
    }
  }

  my @opts = (
    "--ipmagic=",
    "--local",
    "--prefix=",
    "--keep-snapshot-count=",
    "--remove-all-snapshots",
    "--info-rescan",
    (map {"--info-sort-by=$_"} @INFO_SORT_BY_OPTS),
  );

  my @cmds = qw(
    -h --help
    --backup-rsync
    --check-uuids
    --backup-sendreceive
    --sendreceive
    --seed-sendreceive
    --last-snapshot
    --snapshot
    --snapshot-src
    --snapshot-dest
    --cleanup
    --cleanup-all
    --cleanup=
    --delete
    --info
    --bash-complete
  );

  my @complete = (@opts);
  if(not defined $command){
    @complete = (@complete, @cmds) if @commandArgs == 0;
    @complete = (@complete, readBackupNames($BACKUP_CONF_FILE)) if @commandArgs == 0;
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_HELP){
    @complete = ();
  }elsif($command eq $COMMAND_CHECK_UUIDS){
    @complete = (@complete, readBackupNames($BACKUP_CONF_FILE)) if @commandArgs == 0;
  }elsif($command eq $COMMAND_BACKUP_SENDRECEIVE){
    @complete = (@complete, readBackupNames($BACKUP_CONF_FILE)) if @commandArgs == 0;
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_SENDRECEIVE){
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
    @complete = (@complete, guessSubvolNames($commandArgs[0])) if @commandArgs == 2 or @commandArgs == 3;
  }elsif($command eq $COMMAND_SEED_SENDRECEIVE){
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_LAST_SNAPSHOT){
    @complete = (@complete, @PREFIX_NAMES) if @commandArgs == 0;
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_SNAPSHOT){
    @complete = (@complete, @PREFIX_NAMES) if @commandArgs == 0;
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_SNAPSHOT_SRC or $command eq $COMMAND_SNAPSHOT_DEST){
    @complete = (@complete, @PREFIX_NAMES) if @commandArgs == 0;
    @complete = (@complete, readBackupNames($BACKUP_CONF_FILE)) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_CLEANUP){
    @complete = (@complete, @PREFIX_NAMES) if @commandArgs == 0;
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0 or @commandArgs == 1;
  }elsif($command eq $COMMAND_DELETE){
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0;
    @complete = (@complete, guessSubvolNames($commandArgs[0])) if @commandArgs == 1;
  }elsif($command eq $COMMAND_INFO){
    @complete = (@complete, guessMountpoints()) if @commandArgs == 0;
  }elsif($command eq $COMMAND_BASH_COMPLETE){
    @complete = ();
  }

  return @complete;
}

&main(@ARGV);
