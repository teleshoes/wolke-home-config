#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

sub setMinMaxFreq($$$);
sub freqPctToKHz($$);
sub freqKHzToPct($$);
sub getAllCpus();
sub setGovernor($$);
sub readDev($$);
sub readDevList($$);
sub writeDev($$$);
sub uniq(@);
sub firstElem(@);
sub isAllSame(@);

my $EXEC = basename $0;
my $BASE_DIR='/sys/devices/system/cpu';

my $CMD_GET = "get";
my $CMD_SET_FREQ_MIN_MAX = "set-freq-min-max";
my $CMD_SET_FREQ_MIN = "set-freq-min";
my $CMD_SET_FREQ_MAX = "set-freq-max";
my $CMD_SET_GOV = "set-gov";

my $CPUINFO_MIN_FREQ = "cpuinfo_min_freq";
my $CPUINFO_MAX_FREQ = "cpuinfo_max_freq";
my $SCALING_MIN_FREQ = "scaling_min_freq";
my $SCALING_MAX_FREQ = "scaling_max_freq";
my $SCALING_GOVERNOR = "scaling_governor";
my $SCALING_AVAILABLE_GOVERNORS = "scaling_available_governors";

my $USAGE = "Usage:
  $EXEC [OPTS] --get
    -read MIN_FREQ_KHZ, MAX_FREQ_KHZ, and GOVERNOR for selected cpus (default is all)
    -calculate MIN_FREQ_PCT and MAX_FREQ_PCT for selected cpus
    -get SHARED_MIN_FREQ_PCT, SHARED_MAX_FREQ_PCT, and SHARED_GOVERNOR
      -if all selected cpus have the same value, use that value
      -otherwise, use '???'
    -print: SHARED_MIN_FREQ_PCT% - SHARED_MAX_FREQ_PCT% [SHARED_GOVERNOR]

  $EXEC [OPTS] --set MIN_FREQ_PCT MAX_FREQ_PCT
    same as:
      $EXEC --set-min MIN_FREQ_PCT
      $EXEC --set-max MAX_FREQ_PCT

  $EXEC [OPTS] --min FREQ_PCT
    -for selected cpus (default is all):
      -calculate FREQ_KHZ from CPU_MIN_KHZ, CPU_MAX_KHZ, FREQ_PCT
      -set $SCALING_MIN_FREQ to FREQ_KHZ for selected cpus
  $EXEC [OPTS] --max FREQ_PCT
    -for selected cpus (default is all):
      -calculate FREQ_KHZ from CPU_MIN_KHZ, CPU_MAX_KHZ, FREQ_PCT
      -set $SCALING_MAX_FREQ to FREQ_KHZ for selected cpus

  $EXEC [OPTS] --gov|--governor GOVERNOR
  $EXEC [OPTS] --set-gov|--set-governor GOVERNOR
    set governor to GOVERNOR for selected cpus (default is all)

  OPTS
    -c CPU_NUM,CPU_NUM,CPU_NUM,...
    --cpu CPU_NUM,CPU_NUM,CPU_NUM,...
    --cpus CPU_NUM,CPU_NUM,CPU_NUM,...
    --cpu=CPU_NUM,CPU_NUM,CPU_NUM
    --cpus=CPU_NUM,CPU_NUM,CPU_NUM
      comma-separated list of cpu indexes to include (default is to include all)
      e.g.: -c 0,2,4
            --cpu=3

  GOVERNOR
    scaling governor, e.g.: performance, powersave
  CPU_MIN_KHZ
    value of:
      $BASE_DIR/cpu<CPU_NUM>/cpufreq/$CPUINFO_MIN_FREQ
  CPU_MIN_KHZ
    value of:
      $BASE_DIR/cpu<CPU_NUM>/cpufreq/$CPUINFO_MAX_FREQ
  FREQ_PCT
    cpu frequency as a percentage between the min and max of the cpu
      FREQ_KHZ = FREQ_PCT / 100 * (CPU_MAX_KHZ - CPU_MIN_KHZ) + CPU_MIN_KHZ
  FREQ_KHZ
    cpu frequency in kHz
      FREQ_PCT = 100 * (FREQ_KHZ - CPU_MIN_KHZ) / (CPU_MAX_KHZ - CPU_MIN_KHZ)
  CPU_NUM
    integer index of cpu at $BASE_DIR/cpu<CPU_NUM>
";

sub main(@){
  my $cmd = undef;
  my $minFreqPct = undef;
  my $maxFreqPct = undef;
  my $gov = undef;
  my @cpus;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--get)$/){
      $cmd = $CMD_GET;
    }elsif($arg =~ /^(--set)$/){
      $cmd = $CMD_SET_FREQ_MIN_MAX;
    }elsif($arg =~ /^(--min)$/){
      $cmd = $CMD_SET_FREQ_MIN;
    }elsif($arg =~ /^(--max)$/){
      $cmd = $CMD_SET_FREQ_MAX;
    }elsif($arg =~ /^(--gov|--governor|--set-gov|--set-governor)$/){
      $cmd = $CMD_SET_GOV;
    }elsif($arg =~ /^--cpus?=((?:\d+,)*\d+)$/){
      my $cpuCsv = $1;
      @cpus = split /,/, $cpuCsv;
    }elsif($arg =~ /^(-c|--cpus?)$/ and @_ > 0 and $_[0] =~ /^((?:\d+,)*\d+)$/){
      my $cpuCsv = shift @_;
      @cpus = split /,/, $cpuCsv;
    }elsif($arg =~ /^(\d+|\d*\.\d+)%?$/){
      my $freqPct = $1;
      if($cmd =~ /^($CMD_SET_FREQ_MIN|$CMD_SET_FREQ_MIN_MAX)$/ and not defined $minFreqPct){
        $minFreqPct = $freqPct;
      }elsif($cmd =~ /^($CMD_SET_FREQ_MAX|$CMD_SET_FREQ_MIN_MAX)$/ and not defined $maxFreqPct){
        $maxFreqPct = $freqPct;
      }else{
        die "$USAGE\nERROR: too many FREQ_PCT for cmd $cmd\n";
      }
    }elsif(defined $cmd and $cmd =~ /^($CMD_SET_GOV)$/ and not defined $gov){
      $gov = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  @cpus = getAllCpus() if @cpus == 0;
  @cpus = sort {$a <=> $b} uniq @cpus;

  if($cmd eq $CMD_GET){
    my @minFreqPcts = map {freqKHzToPct($_, readDev($_, $SCALING_MIN_FREQ))} @cpus;
    my @maxFreqPcts = map {freqKHzToPct($_, readDev($_, $SCALING_MAX_FREQ))} @cpus;
    my @governors = map {readDev($_, $SCALING_GOVERNOR)} @cpus;

    my $sharedMinFreqPct = firstElem @minFreqPcts if isAllSame @minFreqPcts;
    my $sharedMaxFreqPct = firstElem @maxFreqPcts if isAllSame @maxFreqPcts;
    my $sharedGovernor = firstElem @governors if isAllSame @governors;

    $sharedMinFreqPct = "???" if not defined $sharedMinFreqPct;
    $sharedMaxFreqPct = "???" if not defined $sharedMaxFreqPct;
    $sharedGovernor = "???" if not defined $sharedGovernor;

    printf "%s%% - %s%% [%s]\n", $sharedMinFreqPct, $sharedMaxFreqPct, $sharedGovernor;
  }elsif($cmd eq $CMD_SET_FREQ_MIN_MAX){
    die "ERROR: missing MIN_FREQ\n" if not defined $minFreqPct;
    die "ERROR: missing MAX_FREQ\n" if not defined $maxFreqPct;
    setMinMaxFreq $minFreqPct, $SCALING_MIN_FREQ, \@cpus;
    setMinMaxFreq $maxFreqPct, $SCALING_MAX_FREQ, \@cpus;
  }elsif($cmd =~ $CMD_SET_FREQ_MIN){
    die "ERROR: missing MIN_FREQ\n" if not defined $minFreqPct;
    setMinMaxFreq $minFreqPct, $SCALING_MIN_FREQ, \@cpus;
  }elsif($cmd =~ $CMD_SET_FREQ_MAX){
    die "ERROR: missing MAX_FREQ\n" if not defined $maxFreqPct;
    setMinMaxFreq $maxFreqPct, $SCALING_MAX_FREQ, \@cpus;
  }elsif($cmd eq $CMD_SET_GOV){
    for my $cpu(@cpus){
      setGovernor($cpu, $gov);
    }
  }else{
    die $USAGE;
  }
}

sub setMinMaxFreq($$$){
  my ($freqPct, $scalingMinMaxFreqDev, $cpus) = @_;
  for my $cpu(@$cpus){
    my $freqKHz = freqPctToKHz $cpu, $freqPct;
    writeDev $cpu, $scalingMinMaxFreqDev, $freqKHz;
  }
}

sub freqPctToKHz($$){
  my ($cpu, $freqPct) = @_;
  my $min = readDev $cpu, $CPUINFO_MIN_FREQ;
  my $max = readDev $cpu, $CPUINFO_MAX_FREQ;
  return $freqPct/100.0 * ($max - $min) + $min;
}

sub freqKHzToPct($$){
  my ($cpu, $freqKHz) = @_;
  my $min = readDev $cpu, $CPUINFO_MIN_FREQ;
  my $max = readDev $cpu, $CPUINFO_MAX_FREQ;
  return 100.0 * ($freqKHz - $min) / ($max - $min);
}

sub getAllCpus(){
  my @cpus;
  for my $cpudir(glob "$BASE_DIR/cpu*"){
    push @cpus, $1 if $cpudir =~ /cpu(\d+)$/;
  }
  return @cpus;
}

sub setGovernor($$){
  my ($cpu, $gov) = @_;
  my %okGovs = map {$_ => 1} readDevList $cpu, $SCALING_AVAILABLE_GOVERNORS;
  if(not defined $okGovs{$gov}){
    die "ERROR: unknown governor $gov\n";
  }
  writeDev($cpu, $SCALING_GOVERNOR, $gov);
}

sub readDev($$){
  my ($cpu, $dev) = @_;
  my $devPath = "$BASE_DIR/cpu$cpu/cpufreq/$dev";
  open FH, "< $devPath" or die "Could not open $devPath for reading\n$!\n";
  my $val = <FH>;
  close FH;
  chomp $val;
  return $val;
}

sub readDevList($$){
  my ($cpu, $dev) = @_;
  my $val = readDev $cpu, $dev;
  my @values = split / /, $val;
  return @values;
}

sub writeDev($$$){
  my ($cpu, $dev, $val) = @_;
  my $devPath = "$BASE_DIR/cpu$cpu/cpufreq/$dev";
  open FH, "> $devPath" or die "Could not open $devPath for writing\n$!\n";
  print FH "$val\n";
  close FH;
}

sub uniq(@){
  my %okElems = map {$_ => 1} @_;
  return keys %okElems;
}

sub firstElem(@){
  return @_ > 0 ? $_[0] : undef;
}

sub isAllSame(@){
  my @arr = @_;
  my $elem = $arr[0] if @arr > 0;
  for my $otherElem(@arr){
    if($elem ne $otherElem){
      return 0;
    }
  }
  return 1;
}

&main(@ARGV);
