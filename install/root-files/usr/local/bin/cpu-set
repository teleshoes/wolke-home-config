#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

sub setMinMaxFreq($$$);
sub getAvgMinMaxFreqPct($$);
sub freqPctToKHz($$);
sub freqKHzToPct($$);
sub getAllCpus();
sub setGovernor($$);
sub sortUniq(@);
sub readDev($$);
sub readDevList($$);
sub writeDev($$$);

my $EXEC = basename $0;
my $BASE_DIR='/sys/devices/system/cpu';

my $CMD_SET_FREQ_MIN_MAX = "set-freq-min-max";
my $CMD_SET_GOV = "set-gov";
my $CMD_SET_FREQ_MIN = "set-freq-min";
my $CMD_SET_FREQ_MAX = "set-freq-max";
my $CMD_GET_MIN_PCT = "get-min-pct";
my $CMD_GET_MAX_PCT = "get-max-pct";

my $CPUINFO_MIN_FREQ = "cpuinfo_min_freq";
my $CPUINFO_MAX_FREQ = "cpuinfo_max_freq";
my $SCALING_MIN_FREQ = "scaling_min_freq";
my $SCALING_MAX_FREQ = "scaling_max_freq";
my $SCALING_GOVERNOR = "scaling_governor";
my $SCALING_AVAILABLE_GOVERNORS = "scaling_available_governors";

my $USAGE = "Usage:
  $EXEC [OPTS] --set MIN_FREQ_PCT MAX_FREQ_PCT
    same as:
      $EXEC --set-min MIN_FREQ_PCT
      $EXEC --set-max MAX_FREQ_PCT

  $EXEC [OPTS] --gov|--governor GOVERNOR
    set governor to GOVERNOR for selected cpus (or all)
    (e.g: performance, powersave, ondemand, userspace)
  $EXEC [OPTS] --min FREQ_PCT
    -for selected cpus (default is all):
      -calculate FREQ_KHZ from CPU_MIN_KHZ, CPU_MAX_KHZ, FREQ_PCT
      -set $SCALING_MIN_FREQ to FREQ_KHZ for selected cpus
  $EXEC [OPTS] --max FREQ_PCT
    -for selected cpus (default is all):
      -calculate FREQ_KHZ from CPU_MIN_KHZ, CPU_MAX_KHZ, FREQ_PCT
      -set $SCALING_MAX_FREQ to FREQ_KHZ for selected cpus

  $EXEC [OPTS] --get-min-pct
    read $SCALING_MIN_FREQ as FREQ_KHZ for selected cpus (or all),
      calculate FREQ_PCT for selected cpus,
      and take the average
  $EXEC [OPTS] --get-max-pct
    read scaling_max_freq as FREQ_KHZ for selected cpus (or all),
      calculate FREQ_PCT for selected cpus,
      and take the average

  OPTS
    -c CPU_NUM,CPU_NUM,CPU_NUM,...
      comma-separated list of cpu indexes to include (default is to include all)
      e.g.: -c 0,2,4
            -c 3

  CPU_MIN_KHZ
    value of:
      $BASE_DIR/cpu<CPU_NUM>/cpufreq/$CPUINFO_MIN_FREQ
  CPU_MIN_KHZ
    value of:
      $BASE_DIR/cpu<CPU_NUM>/cpufreq/$CPUINFO_MAX_FREQ
  FREQ_PCT
    cpu frequency as a percentage between the min and max of the cpu
      FREQ_KHZ = FREQ_PCT / 100 * (CPU_MAX_KHZ - CPU_MIN_KHZ) + CPU_MIN_KHZ
  FREQ_KHZ
    cpu frequency in kHz
      FREQ_PCT = 100 * (FREQ_KHZ - CPU_MIN_KHZ) / (CPU_MAX_KHZ - CPU_MIN_KHZ)
";

sub main(@){
  my $cmd = undef;
  my $minFreqPct = undef;
  my $maxFreqPct = undef;
  my $gov = undef;
  my @cpus;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--set)$/){
      $cmd = $CMD_SET_FREQ_MIN_MAX;
    }elsif($arg =~ /^(--gov|--governor)$/){
      $cmd = $CMD_SET_GOV;
    }elsif($arg =~ /^(--min)$/){
      $cmd = $CMD_SET_FREQ_MIN;
    }elsif($arg =~ /^(--max)$/){
      $cmd = $CMD_SET_FREQ_MAX;
    }elsif($arg =~ /^(--get-min-pct)$/){
      $cmd = $CMD_GET_MIN_PCT;
    }elsif($arg =~ /^(--get-max-pct)$/){
      $cmd = $CMD_GET_MAX_PCT;
    }elsif($arg =~ /^(-c)$/ and @_ > 0){
      my $cpuArg = shift;
      die "malformed cpu arg: $cpuArg\n" if $cpuArg !~ /^(\d+,)*\d+$/;
      @cpus = (@cpus, split /,/, $cpuArg);
    }elsif($arg =~ /^(\d+|\d*\.\d+)%?$/){
      my $freqPct = $1;
      if($cmd =~ /^($CMD_SET_FREQ_MIN|$CMD_SET_FREQ_MIN_MAX)$/ and not defined $minFreqPct){
        $minFreqPct = $freqPct;
      }elsif($cmd =~ /^($CMD_SET_FREQ_MAX|$CMD_SET_FREQ_MIN_MAX)$/ and not defined $maxFreqPct){
        $maxFreqPct = $freqPct;
      }else{
        die "$USAGE\nERROR: too many FREQ_PCT for cmd $cmd\n";
      }
    }elsif($cmd =~ /^($CMD_SET_GOV)$/ and not defined $gov){
      $gov = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  @cpus = @cpus == 0 ? getAllCpus() : sortUniq @cpus;

  if($cmd eq $CMD_SET_FREQ_MIN_MAX){
    die "ERROR: missing MIN_FREQ\n" if not defined $minFreqPct;
    die "ERROR: missing MAX_FREQ\n" if not defined $maxFreqPct;
    setMinMaxFreq $minFreqPct, $SCALING_MIN_FREQ, \@cpus;
    setMinMaxFreq $maxFreqPct, $SCALING_MAX_FREQ, \@cpus;
  }elsif($cmd eq $CMD_SET_GOV){
    for my $cpu(@cpus){
      setGovernor($cpu, $gov);
    }
  }elsif($cmd =~ $CMD_SET_FREQ_MIN){
    die "ERROR: missing MIN_FREQ\n" if not defined $minFreqPct;
    setMinMaxFreq $minFreqPct, $SCALING_MIN_FREQ, \@cpus;
  }elsif($cmd =~ $CMD_SET_FREQ_MAX){
    die "ERROR: missing MAX_FREQ\n" if not defined $maxFreqPct;
    setMinMaxFreq $maxFreqPct, $SCALING_MAX_FREQ, \@cpus;
  }elsif($cmd eq $CMD_GET_MIN_PCT){
    my $pct = getAvgMinMaxFreqPct $SCALING_MIN_FREQ, \@cpus;
    print "$pct\n";
  }elsif($cmd eq $CMD_GET_MAX_PCT){
    my $pct = getAvgMinMaxFreqPct $SCALING_MAX_FREQ, \@cpus;
    print "$pct\n";
  }else{
    die $USAGE;
  }
}

sub setMinMaxFreq($$$){
  my ($freqPct, $scalingMinMaxFreqDev, $cpus) = @_;
  for my $cpu(@$cpus){
    my $freqKHz = freqPctToKHz $cpu, $freqPct;
    writeDev $cpu, $scalingMinMaxFreqDev, $freqKHz;
  }
}

#convert KHz to percentage of (max-min) freq, take mean across all cpus
sub getAvgMinMaxFreqPct($$){
  my ($scalingMinMaxFreqDev, $cpus) = @_;
  my $totalPcts = 0;
  for my $cpu(@$cpus){
    my $freqKHz = readDev $cpu, $scalingMinMaxFreqDev;
    my $pct = freqKHzToPct $cpu, $freqKHz;
    $totalPcts += $pct;
  }
  return sprintf "%d", $totalPcts/@$cpus;
}

sub freqPctToKHz($$){
  my ($cpu, $freqPct) = @_;
  my $min = readDev $cpu, $CPUINFO_MIN_FREQ;
  my $max = readDev $cpu, $CPUINFO_MAX_FREQ;
  return $freqPct/100.0 * ($max - $min) + $min;
}

#return percentage between min and max frequency
sub freqKHzToPct($$){
  my ($cpu, $freqKHz) = @_;
  my $min = readDev $cpu, $CPUINFO_MIN_FREQ;
  my $max = readDev $cpu, $CPUINFO_MAX_FREQ;
  return 100.0 * ($freqKHz - $min) / ($max - $min);
}

#returns the number from all dirs named cpu# in the base dir
sub getAllCpus(){
  my @cpus;
  for my $cpudir(glob "$BASE_DIR/cpu*"){
    push @cpus, $1 if $cpudir =~ /(\d+)$/;
  }
  return @cpus;
}

sub setGovernor($$){
  my ($cpu, $gov) = @_;
  my %okGovs = map {$_ => 1} readDevList $cpu, $SCALING_AVAILABLE_GOVERNORS;
  if(not defined $okGovs{$gov}){
    die "ERROR: unknown governor $gov\n";
  }
  writeDev($cpu, $SCALING_GOVERNOR, $gov);
}

sub sortUniq(@){
  my %okElems = map {$_ => 1} @_;
  return sort keys %okElems;
}

sub readDev($$){
  my ($cpu, $dev) = @_;
  my $devPath = "$BASE_DIR/cpu$cpu/cpufreq/$dev";
  open FH, "< $devPath" or die "Could not open $devPath for reading\n$!\n";
  my $val = <FH>;
  close FH;
  chomp $val;
  return $val;
}

sub readDevList($$){
  my ($cpu, $dev) = @_;
  my $val = readDev $cpu, $dev;
  my @values = split / /, $val;
  return @values;
}

sub writeDev($$$){
  my ($cpu, $dev, $val) = @_;
  my $devPath = "$BASE_DIR/cpu$cpu/cpufreq/$dev";
  open FH, "> $devPath" or die "Could not open $devPath for writing\n$!\n";
  print FH "$val\n";
  close FH;
}

&main(@ARGV);
