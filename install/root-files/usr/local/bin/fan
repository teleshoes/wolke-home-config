#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use List::Util qw(max);

sub parseFanValueOrSyn($);
sub parseFanTempRange($);
sub getTargetFanLevelFromTempRanges($$@);
sub parseLevelOrSyn($);
sub parseConfigFile($);
sub getIT87Dir();
sub readTemp();
sub readFan();
sub getFanLevelByPWM($);
sub readFanLevelStateFile();
sub writeFanLevelStateFile($);
sub setLevel($);
sub setWatchdog($);
sub readFile($);
sub writeFile($$);

my $IBM_DEV_FAN = "/proc/acpi/ibm/fan";

my $IT87_DEV_DIR_PTRN = "/sys/devices/platform/it87.*/hwmon/hwmon*";
my $IT87_DEV_NAME_FAN_PWM_MAIN = "pwm2";
my $IT87_DEV_NAME_FAN_PWM_AUX = "pwm3";
my $IT87_DEV_NAME_FAN_RPM_MAIN = "fan2_input";
my $IT87_DEV_NAME_FAN_RPM_AUX = "fan3_input";
my $IT87_DEV_NAME_TEMP = "temp1_input";

my $CONFIG_FILE = "$ENV{HOME}/.config/fanspeed.conf";
my $STATE_FILE = "/tmp/fanspeed-level";

my $MONITOR_INTERVAL_MILLIS = 10000;

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h
  $EXEC --help
    show this message

  $EXEC
  $EXEC --get
     -if $IBM_DEV_FAN exists:
       -read FAN_LEVEL and SPEED_RPM from $IBM_DEV_FAN
         -FAN_LEVEL is one of the 'level' values
         -SPEED_RPM is the integer 'speed'
       -format SPEED_FMT as \"<SPEED_RPM>RPM\"
     -if $IT87_DEV_DIR_PTRN/ exists:
       -get MIN_PWM as the smallest pwm of:
         $IT87_DEV_NAME_FAN_PWM_MAIN (main)
         $IT87_DEV_NAME_FAN_PWM_AUX (aux)
       -map MIN_PWM to FAN_LEVEL
         among the FAN_LEVEL values that are integers,
         take the highest-numbered FAN_LEVEL with a pwm less than or equal to MIN_PWM
       -read SPEED_RPM_MAIN from $IT87_DEV_NAME_FAN_PWM_MAIN (main)
       -read SPEED_RPM_AUX from $IT87_DEV_NAME_FAN_PWM_AUX (aux)
       -format SPEED_FMT as \"<SPEED_RPM_MAIN>RPM,<SPEED_RPM_AUX>RPM\"
     -read TEMP_C as in: $EXEC --temp
     -print \"<FAN_LEVEL> : <SPEED_FMT> : <TEMP_C>C\"

  $EXEC --temp
     -if $IBM_DEV_FAN exists:
       -read TEMP_C from `acpi`
         -run `acpi -V`, extract first CPU temp as degrees celsius
         -round it to the nearest integer
     -if $IT87_DEV_DIR_PTRN/ exists:
       -read TEMP_C from $IT87_DEV_NAME_TEMP
         -convert from millidegrees celsius to degrees celsius
         -round to the nearest integer
     -print, formatted as:
       \"<TEMP_C>\"

  $EXEC FAN_VALUE
  $EXEC --set=FAN_VALUE
     calculate <FAN_LEVEL> and <WATCHDOG_TIMEOUT_SECONDS> from <FAN_VALUE>
     if $IBM_DEV_FAN exists:
       -set fan level to <FAN_LEVEL> using $IBM_DEV_FAN
     if $IT87_DEV_DIR_PTRN/ exists:
       -calculate PWM from FAN_LEVEL (see <FAN_LEVEL>)
       -set $IT87_DEV_NAME_FAN_PWM_MAIN (main) to PWM
       -set $IT87_DEV_NAME_FAN_PWM_AUX (aux) to PWM
     if given, also set fan watchdog timeout to <WATCHDOG_TIMEOUT_SECONDS>
     write <FAN_LEVEL> (not synonym or watchdog) to $STATE_FILE

  $EXEC --reapply
     set fan level to the <FAN_LEVEL> in $STATE_FILE if it exists
  $EXEC --clear
     remove $STATE_FILE (further calls to --reapply without --set will do nothing)

  $EXEC --watchdog=WATCHDOG_TIMEOUT_SECONDS
     -if $IBM_DEV_FAN exists:
       write 'watchdog WATCHDOG_TIMEOUT_SECONDS' to $IBM_DEV_FAN
       (0 disables the watchdog timeout, value of 1-120 enables it that many seconds)
     -otherwise:
       fail with an error

  $EXEC --monitor [OPTS] FAN_TEMP_RANGE [FAN_TEMP_RANGE]
    -checks the temperature every ${MONITOR_INTERVAL_MILLIS}ms:
      -if the current temp AND fan level matches one of the <FAN_TEMP_RANGE>s:
        do nothing
      -if the current temp matches at least none of the <FAN_TEMP_RANGE>s:
        apply the highest fan level among those <FAN_TEMP_RANGE>s
      -otherwise:
        apply the highest fan level of any <FAN_TEMP_RANGE>

    <OPTS>
       -o | --once
         run exactly once instead of re-running every ${MONITOR_INTERVAL_MILLIS}ms
       -v | --verbose
         print status even when no level change occurs

    <FAN_TEMP_RANGE> = <FAN_LEVEL>:<LOW_TEMP>-<HIGH_TEMP>
      a sequence of 3 non-negative integers, separated with non-alphanumeric characters
      e.g.:   3:60-80    or   7-80,100
      NOTE:
        <FAN_LEVEL> must be greater than 0
        <FAN_TEMP_RANGE>s can overlap temperatures
          (and should, to avoid constant changing)

     e.g.: $EXEC --monitor 1:0-60 2:60-70 3:65-80 7:80-100
        temp  fan  => action
        78    3    => do nothing
        72    2    => 3
        66    2    => do nothing
        66    3    => do nothing
        64    3    => 2
        106   6    => 7

  <FAN_VALUE> = <FAN_LEVEL>
              | <FAN_LEVEL>,<WATCHDOG_TIMEOUT_SECONDS>
              | <SYNONYM>
    argument for $IBM_DEV_FAN level or a synonym
    one of either <LEVEL> or <SYNONYM>

  <FAN_LEVEL> = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | auto | disengaged | full-speed
    for $IBM_DEV_FAN:
      valid arguments for $IBM_DEV_FAN (0-7, \"auto\", or \"disengaged\"/\"full-speed\")
        NOTE:
          0 means FULLY DISABLED and is quite dangerous
          disengaged and full-speed do the same thing, and are (generally) faster than 7
          auto varies based on CPU load and is done by the kernel module or firmware

    for $IT87_DEV_DIR_PTRN:
      FAN_LEVEL  => PWM  | MAINFAN +  AUXFAN | SUBJECTIVE LOUDNESS + COOLING on SER5 Pro
      0          => 0    |    0RPM +    0RPM | actually off, potentially dangerous
      1          => 36   | 1000RPM +  300RPM | practically silent, but cools fairly quick
      2          => 76   | 2000RPM + 1200RPM | just barely audible close by, cools great
      3          => 125  | 3000RPM + 2100RPM | audible across the room but ignoreable
      4          => 155  | 3500RPM + 2500RPM | loud, clearly audible over white noise
      5          => 187  | 4000RPM + 3000RPM | loud and annoying
      6          => 225  | 4500RPM + 3500RPM | very loud and high pitched
      7          => 255  | 4900RPM + 3800RPM | extremely loud
      auto       => 76   | (same as 2)       | (same as 2)
      disengaged => 255  | (same as 7)       | (same as 7)
      full-speed => 255  | (same as 7)       | (same as 7)

      NOTE: for IT87, 'auto' is just a synonym for '2', which is quiet and cool.
            it does not do anything automatically

  <WATCHDOG_TIMEOUT_SECONDS>
    watchdog timeout, as an integer number of seconds between 0 and 120 inclusive
    0 means disabled

  <SYNONYM>
    synonyms are defined in $CONFIG_FILE
      -one per line:
        SYN_NAME = FAN_VALUE

    e.g.:  default=5
           fast=disengaged
           medium=4
           slow=3
           morning=5,60
           evening=1,5

  <SYN_NAME>
    any name, one or more letters or numbers
";

my @OK_LEVELS = qw(0 1 2 3 4 5 6 7 auto disengaged full-speed);
my $OK_LEVELS_RE = "(?:" . join("|", @OK_LEVELS) . ")";

my $IT87_PWM_VALUES_BY_FAN_LEVEL = {
  "0"          =>   0,
  "1"          =>  36,
  "2"          =>  76,
  "3"          => 125,
  "4"          => 155,
  "5"          => 187,
  "6"          => 225,
  "7"          => 255,
  "auto"       =>  76,
  "disengaged" => 255,
  "full-speed" => 255,
};

sub main(@){
  if(@_ == 1 and $_[0] =~ /^(-h|--help)$/){
    print $USAGE;
    exit 0;
  }elsif(@_ == 0 or (@_ == 1 and $_[0] =~ /^(--get)$/)){
    my $fanInfo = readFan();
    my $temp = readTemp();
    my @speeds = @{$$fanInfo{speeds}};
    my $speedFmt = join ",", map {sprintf("%dRPM", $_)} @speeds;
    printf "%s : %s : %dC\n",
      $$fanInfo{level}, $speedFmt, ${temp};
  }elsif(@_ == 0 or (@_ == 1 and $_[0] =~ /^(--temp)$/)){
    my $temp = readTemp();
    printf "%d\n", $temp;
  }elsif(@_ == 1 and $_[0] =~ /^(--reapply)$/){
    my $stateLevel = readFanLevelStateFile();
    my $fanInfo = readFan();
    my $curLevel = $$fanInfo{level};
    if(defined $stateLevel and $stateLevel ne $curLevel){
      my $now = `date`;
      chomp $now;
      print "$now  FAN LEVEL CHANGED: REAPPLYING $curLevel => $stateLevel\n";
      setLevel $stateLevel;
    }
  }elsif(@_ == 1 and $_[0] =~ /^(--clear)$/){
    writeFanLevelStateFile undef;
  }elsif(@_ == 1 and $_[0] =~ /^--watchdog=(\d+)$/){
    my $timeoutSeconds = $1;
    setWatchdog $timeoutSeconds;
  }elsif(@_ >= 1 and $_[0] =~ /^(--monitor)$/){
    my ($monitorCmd, @args) = @_;
    my $once = 0;
    my $verbose = 0;
    while(@args > 0 and $args[0] =~ /^-/){
      my $opt = shift @args;
      if($opt =~ /^(-o|--once)$/){
        $once = 1;
      }elsif($opt =~ /^(-v|--verbose)$/){
        $verbose = 1;
      }else{
        die "ERROR: invalid --monitor OPT: $opt\n";
      }
    }
    my @fanTempRangeFmts = @args;
    die "ERROR: no FAN_TEMP_RANGE given\n" if @fanTempRangeFmts == 0;

    my @fanTempRanges = map {parseFanTempRange $_} @fanTempRangeFmts;
    while(1){
      my $curLevel = ${readFan()}{level};
      my $curTemp = readTemp();
      my $newLevel = getTargetFanLevelFromTempRanges($curLevel, $curTemp, @fanTempRanges);
      my $changed = 0;
      if(defined $newLevel and $newLevel ne $curLevel){
        $changed = 1;
        writeFanLevelStateFile($newLevel);
      }
      if($changed or $verbose){
        my $date = `date`;
        chomp $date;
        $newLevel = $curLevel if not $changed;
        my $changeFmt = $changed ? "" : " (NO CHANGE)";
        print "$date   $curLevel => $newLevel  (${curTemp}C)$changeFmt\n";
        select()->flush();
      }

      if($once){
        last;
      }else{
        sleep $MONITOR_INTERVAL_MILLIS/1000.0;
      }
    }
  }elsif(@_ == 1){
    my $value;
    if($_[0] =~ /^--set=(.+)$/){
      $value = $1;
    }else{
      $value = $_[0];
    }

    my ($level, $watchdogTimeoutSeconds) = parseFanValueOrSyn $value;

    if(not defined $level or $level !~ /^$OK_LEVELS_RE$/){
      die "$USAGE\ninvalid FAN_VALUE: $value\n";
    }

    my $fanInfo = readFan();
    my $curLevel = $$fanInfo{level};
    if($curLevel eq $level){
      print "fan already set to $level\n";
    }else{
      print "$curLevel => $level\n";
      writeFanLevelStateFile($level);
      setLevel $level;
    }
    if(defined $watchdogTimeoutSeconds){
      setWatchdog $watchdogTimeoutSeconds;
    }
  }else{
    die $USAGE;
  }
}

sub parseFanTempRange($){
  my ($fanTempRangeFmt) = @_;
  if($fanTempRangeFmt =~ /^(\d+)\W+(\d+)\W+(\d+)$/){
    my ($fanLevel, $lowTemp, $highTemp) = ($1, $2, $3);
    die "ERROR: low temp > high temp \"$fanTempRangeFmt\"\n" if $lowTemp > $highTemp;
    die "ERROR: fan level must be > 0 in FAN_TEMP_RANGE\n" if $fanLevel <= 0;
    return {level => $1, lowTemp => $lowTemp, highTemp => $highTemp};
  }else{
    die "ERROR: malformed fan temp range: $fanTempRangeFmt\n";
  }
}

sub getTargetFanLevelFromTempRanges($$@){
  my ($curLevel, $curTemp, @fanTempRanges) = @_;
  my @levelsForMatchingTemps;
  my $matchingTempAndLevel = 0;
  for my $fanTempRange(@fanTempRanges){
    my ($level, $low, $high) =
      ($$fanTempRange{level}, $$fanTempRange{lowTemp}, $$fanTempRange{highTemp});
    if($low <= $curTemp && $curTemp <= $high){
      if($curLevel eq $level){
        $matchingTempAndLevel = 1;
        return undef; #no action
      }else{
        push @levelsForMatchingTemps, $level;
      }
    }
  }
  if($matchingTempAndLevel){
    return undef;
  }elsif(@levelsForMatchingTemps > 0){
    return max(@levelsForMatchingTemps);
  }else{
    return max(map {$$_{level}} @fanTempRanges);
  }
}

sub parseFanValueOrSyn($){
  my ($value) = @_;
  if($value =~ /^($OK_LEVELS_RE)$/){
    return ($1, undef);
  }elsif($value =~ /^($OK_LEVELS_RE),(\d+)$/){
    return ($1, $2);
  }else{
    my $confSynonyms = parseConfigFile $CONFIG_FILE;
    if(defined $$confSynonyms{$value}){
      $value = $$confSynonyms{$value};
      if($value =~ /^($OK_LEVELS_RE)$/){
        return ($1, undef);
      }elsif($value =~ /^($OK_LEVELS_RE),(\d+)$/){
        return ($1, $2);
      }else{
        return undef;
      }
    }else{
      return undef;
    }
  }
}

sub parseConfigFile($){
  my ($CONFIG_FILE) = @_;
  my $conf = {};
  if(-f $CONFIG_FILE){
    open FH, "< $CONFIG_FILE" or die "could not read config file: $CONFIG_FILE\n";
    my @lines = <FH>;
    close FH;
    for my $line(@lines){
      next if $line =~ /^\s*(#|$)/;
      if($line =~ /^\s*(\w+)\s*=\s*((?:$OK_LEVELS_RE)(?:,\d+)?)\s*$/){
        my ($key, $val) = ($1, $2);
        $$conf{$key} = $val;
      }else{
        die "malformed config file line: $line";
      }
    }
  }
  return $conf;
}

sub getIT87Dir(){
  my @dirs = grep {-d $_} glob($IT87_DEV_DIR_PTRN);
  if(@dirs > 1){
    die "ERROR: multiple it87 device dirs:\n@dirs\n";
  }elsif(@dirs == 1){
    return $dirs[0];
  }else{
    return undef;
  }
}

sub readTemp(){
  if(-e $IBM_DEV_FAN){
    my $acpi = `acpi -V`;
    if($acpi =~ /, (-?\d+|-?\d*\.\d+) degrees C/){
      return $1;
    }else{
      return undef;
    }
  }

  my $it87Dir = getIT87Dir();
  if(-d $it87Dir){
    my $temp = readFile("$it87Dir/$IT87_DEV_NAME_TEMP");
    if($temp =~ /^\d+$/){
      return int($temp/1000.0 + 0.5);
    }else{
      return undef;
    }
  }

  die "ERROR: could not find any fan/thermal devices\n";
}

sub readFan(){
  if(-e $IBM_DEV_FAN){
    my $devInfo = readFile $IBM_DEV_FAN;
    my ($level, $speed);
    if($devInfo =~ /^level:\s*(\w+)$/m){
      $level = $1;
    }else{
      die "ERROR: could not parse info from $IBM_DEV_FAN:\n$devInfo\n";
    }
    if($devInfo =~ /^speed:\s*(\d+)$/m){
      $speed = $1;
    }else{
      die "ERROR: could not parse info from $IBM_DEV_FAN:\n$devInfo\n";
    }
    return {level => $level, speeds => [$speed]};
  }

  my $it87Dir = getIT87Dir();
  if(-d $it87Dir){
    my $pwmMain = readFile("$it87Dir/$IT87_DEV_NAME_FAN_PWM_MAIN");
    my $pwmAux = readFile("$it87Dir/$IT87_DEV_NAME_FAN_PWM_AUX");
    my $rpmMain = readFile("$it87Dir/$IT87_DEV_NAME_FAN_RPM_MAIN");
    my $rpmAux = readFile("$it87Dir/$IT87_DEV_NAME_FAN_RPM_AUX");
    my $minPwm = $pwmMain < $pwmAux ? $pwmMain : $pwmAux;

    my $level = getFanLevelByPWM($minPwm);
    if(not defined $level){
      die "ERROR: could not parse FAN_LEVEL from it87 PWM\n";
    }
    return {level => $level, speeds => [$rpmMain, $rpmAux]};
  }

  die "ERROR: could not find any fan/thermal devices\n";
}

sub getFanLevelByPWM($){
  my ($pwm) = @_;
  my @numericLevels = grep {$_ =~ /^\d+$/} sort keys %$IT87_PWM_VALUES_BY_FAN_LEVEL;

  for my $level(reverse @numericLevels){
    my $levelPwm = $$IT87_PWM_VALUES_BY_FAN_LEVEL{$level};
    if($levelPwm <= $pwm){
      return $level;
    }
  }

  return undef;
}

sub readFanLevelStateFile(){
  my $level;
  if(-f $STATE_FILE){
    $level = readFile $STATE_FILE;
    chomp $level;
  }
  if(defined $level and $level =~ /^$OK_LEVELS_RE$/){
    return $level;
  }else{
    return undef;
  }
}
sub writeFanLevelStateFile($){
  my ($level) = @_;
  system "rm", "-f", $STATE_FILE;
  if(defined $level){
    writeFile($STATE_FILE, "$level\n");
  }
}

sub setLevel($){
  my ($fanLevel) = @_;
  if(-e $IBM_DEV_FAN){
    writeFile($IBM_DEV_FAN, "level $fanLevel\n");
  }else{
    my $it87Dir = getIT87Dir();
    if(-d $it87Dir){
      my $pwm = $$IT87_PWM_VALUES_BY_FAN_LEVEL{$fanLevel};
      writeFile("$it87Dir/$IT87_DEV_NAME_FAN_PWM_MAIN", "$pwm\n");
      writeFile("$it87Dir/$IT87_DEV_NAME_FAN_PWM_AUX", "$pwm\n");
    }else{
      die "ERROR: could not find any fan/thermal devices\n";
    }
  }
}
sub setWatchdog($){
  my ($watchdogValue) = @_;
  if(-e $IBM_DEV_FAN){
    writeFile($IBM_DEV_FAN, "watchdog $watchdogValue\n");
  }else{
    die "ERROR: could not find $IBM_DEV_FAN for watchdog\n";
  }
}

sub readFile($){
  my ($file) = @_;
  open my $fh, "< $file" or die "ERROR: could not open $file for writing\n$!\n";
  my @lines = <$fh>;
  close $fh;
  if(wantarray){
    return @lines;
  }else{
    return join("", @lines);
  }
}
sub writeFile($$){
  my ($file, $contents) = @_;
  open my $fh, "> $file" or die "ERROR: could not open $file for writing\n$!\n";
  print $fh $contents;
  close $fh;
}

&main(@ARGV);
